"""Holds classes that can be used for defining models in DMS Stan models."""

from abc import ABC, abstractmethod
from typing import Any, Callable, Optional, Union

import numpy as np
import numpy.typing as npt

# We need a variable that keeps track of transformed parameters in this instance
TRANSFORMED_PARAMETER_COUNTER: int = 0  # Used for naming default transformed parameters


class Parameter:
    """Defines a parameter that is sampled from a distribution."""

    def __init__(self, name: str, distribution: "ContinuousDistribution"):
        """
        Records a name for a parameter and a distribution from which the parameter
        will be sampled.
        """
        # Parameters can only be sampled by continuous distributions
        if not isinstance(distribution, ContinuousDistribution):
            raise ValueError(
                "Parameters can only be sampled by continuous distributions"
            )

        # Build a parameter with a name and a distribution
        self.name = name
        self.distribution = distribution

        # Note in the distribution that this parameter is generated by that distribution
        self.distribution.register_parameter(self)

    def __str__(self):
        return f"{self.name} ~ {self.distribution}"


class AbstractDistribution(ABC):
    """Template class for distributions"""

    # Define special types for distributions
    SampleType = Union[int, float, npt.NDArray]
    CombinedDistType = Union["ContinuousDistribution", int, float, npt.NDArray]

    def __init__(self):
        """
        Should be called by all subclasses. Defines the empty generated parameters
        list.
        """
        self.generated_parameters: list[Parameter] = []

    def register_parameter(self, param: Parameter):
        """
        Register a parameter to be sampled from the distribution. The parameter
        becomes referenced in the `generated_parameters` list.
        """
        # If we do not have a `generated_parameters` list, the user forgot to call
        # the parent class's `__init__` method
        if not hasattr(self, "generated_parameters"):
            raise ValueError(
                "No `generated_parameters` list found in the distribution class. "
                "Did you for get to call super().__init__() in the subclass?"
            )

        # Add the parameter to the list of generated parameters
        self.generated_parameters.append(param)

    @abstractmethod
    def sample(self, n: int) -> npt.NDArray:
        """Sample from the distribution"""

    def __str__(self):
        return f"{self.__class__.__name__}"


class TransformedDistribution(AbstractDistribution):
    """
    Class representing a distribution that is the result of combining other distributions
    using mathematical operations.
    """

    def __init__(
        self,
        dist1: AbstractDistribution.CombinedDistType,
        dist2: Optional[AbstractDistribution.CombinedDistType],
    ):
        """
        Create a transformed distribution by combining two continuous distributions.
        """
        # Run the parent class's init
        super().__init__()

        # Store the two distributions
        self.dist1 = dist1
        self.dist2 = dist2

    @abstractmethod
    def sample(self, n: int) -> npt.NDArray:
        """Sample from the distribution"""
        # Sample from the first distribution
        return (
            self.dist1.sample(n)
            if isinstance(self.dist1, ContinuousDistribution)
            else self.dist1
        )

    @abstractmethod
    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: Optional[AbstractDistribution.SampleType],
    ) -> npt.NDArray:
        """Perform the operation on the samples"""


class BinaryTransformedDistribution(TransformedDistribution):
    """
    Identical to the TransformedDistribution class, but only for operations involving
    two distributions. In other words, both distributions must be provided.
    """

    def __init__(
        self,
        dist1: AbstractDistribution.CombinedDistType,
        dist2: AbstractDistribution.CombinedDistType,
    ):
        super().__init__(dist1, dist2)

    def sample(self, n: int) -> npt.NDArray:
        """Sample from the distribution"""
        # Sample from the first distribution using the parent class's method
        sample1 = super().sample(n)

        # Sample from the second distribution
        sample2 = (
            self.dist2.sample(n)
            if isinstance(self.dist2, ContinuousDistribution)
            else self.dist2
        )

        # Perform the operation
        return self.operation(sample1, sample2)

    @abstractmethod
    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ):
        """Perform the operation on the samples"""


class UnaryTransformedDistribution(TransformedDistribution):
    """Transformed distribution that only requires one distribution."""

    def __init__(self, dist1: "ContinuousDistribution"):
        super().__init__(dist1, None)

    def sample(self, n: int) -> npt.NDArray:
        """Sample from the distribution"""
        # Sample from the first distribution using the parent class's method
        return self.operation(super().sample(n))

    @abstractmethod
    def operation(
        self, sample1: AbstractDistribution.SampleType, sample2: None = None
    ) -> npt.NDArray:
        """Perform the operation on the sample."""


class AddDistribution(BinaryTransformedDistribution):
    """Defines a distribution that is the sum of two other distributions."""

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ) -> npt.NDArray:
        return sample1 + sample2


class SubtractDistribution(BinaryTransformedDistribution):
    """Defines a distribution that is the difference of two other distributions."""

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ) -> npt.NDArray:
        return sample1 - sample2


class MultiplyDistribution(BinaryTransformedDistribution):
    """Defines a distribution that is the product of two other distributions."""

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ) -> npt.NDArray:
        return sample1 * sample2


class DivideDistribution(BinaryTransformedDistribution):
    """Defines a distribution that is the quotient of two other distributions."""

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ) -> npt.NDArray:
        return sample1 / sample2


class PowerDistribution(BinaryTransformedDistribution):
    """Defines a distribution that is the power of another distribution."""

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: AbstractDistribution.SampleType,
    ) -> npt.NDArray:
        return sample1**sample2


class NegateDistribution(UnaryTransformedDistribution):
    """Defines a distribution that is the negative of another distribution."""

    def __init__(self, dist1: AbstractDistribution.CombinedDistType):
        super().__init__(dist1)

    def operation(
        self,
        sample1: AbstractDistribution.SampleType,
        sample2: None = None,
    ) -> npt.NDArray:
        return -sample1


class AbsDistribution(UnaryTransformedDistribution):
    """Defines a distribution that is the absolute value of another distribution."""

    def operation(
        self, sample1: AbstractDistribution.SampleType, sample2: None = None
    ) -> npt.NDArray:
        return np.abs(sample1)


class LogDistribution(UnaryTransformedDistribution):
    """Defines a distribution that is the natural logarithm of another distribution."""

    def operation(
        self, sample1: AbstractDistribution.SampleType, sample2: None = None
    ) -> npt.NDArray:
        return np.log(sample1)


class ExpDistribution(UnaryTransformedDistribution):
    """Defines a distribution that is the exponential of another distribution."""

    def operation(
        self, sample1: AbstractDistribution.SampleType, sample2: None = None
    ) -> npt.NDArray:
        return np.exp(sample1)


class Distribution(AbstractDistribution):
    """Abstract class for distributions used in DMS Stan"""

    def __init__(
        self,
        numpy_dist: str,
        stan_to_np_names: dict[str, str],
        *,
        seed: int = 2,
        **parameters,
    ):
        """Sets up random number generation and handles all parameters"""
        # Run the parent class's init
        super().__init__()

        # Define variables with types that are created within this function
        self.rng: np.random.Generator
        self.numpy_dist: Callable[..., npt.NDArray]
        self.parameters: dict[str, Parameter] = {}
        self.constants: dict[str, Any] = {}

        # Define the random number generator
        self.rng = np.random.default_rng(seed)

        # Store the numpy distribution
        self.numpy_dist = getattr(self.rng, numpy_dist)

        # Populate the parameters and constants
        for paramname, val in parameters.items():
            if isinstance(val, Parameter):
                self.parameters[paramname] = val
            else:
                self.constants[paramname] = val

        # All parameter names must be in the stan_to_np_names dictionary
        if missing_names := set(parameters.keys()) - set(stan_to_np_names.keys()):
            raise ValueError(
                f"Missing names in stan_to_np_names: {', '.join(missing_names)}"
            )

        # Store the stan names to numpy names dictionary
        self.stan_to_np_names = stan_to_np_names

    def sample(self, n: int) -> npt.NDArray:
        """Sample from the distribution"""
        # Sample from the parameter distributions
        param_draws = {
            self.stan_to_np_names[name]: param.distribution.sample(n)
            for name, param in self.parameters.items()
        }

        # Add on constants
        param_draws.update(
            {self.stan_to_np_names[name]: val for name, val in self.constants.items()}
        )

        # Sample from this distribution using numpy
        return self.numpy_dist(**param_draws, size=n)


class ContinuousDistribution(Distribution):
    """Base class for continuous distributions."""

    def __add__(self, other: AbstractDistribution.CombinedDistType):
        return AddDistribution(self, other)

    def __radd__(self, other: AbstractDistribution.CombinedDistType):
        return AddDistribution(other, self)

    def __sub__(self, other: AbstractDistribution.CombinedDistType):
        return SubtractDistribution(self, other)

    def __rsub__(self, other: AbstractDistribution.CombinedDistType):
        return SubtractDistribution(other, self)

    def __mul__(self, other: AbstractDistribution.CombinedDistType):
        return MultiplyDistribution(self, other)

    def __rmul__(self, other: AbstractDistribution.CombinedDistType):
        return MultiplyDistribution(other, self)

    def __truediv__(self, other: AbstractDistribution.CombinedDistType):
        return DivideDistribution(self, other)

    def __rtruediv__(self, other: AbstractDistribution.CombinedDistType):
        return DivideDistribution(other, self)

    def __pow__(self, other: AbstractDistribution.CombinedDistType):
        return PowerDistribution(self, other)

    def __rpow__(self, other: AbstractDistribution.CombinedDistType):
        return PowerDistribution(other, self)

    def __neg__(self):
        return NegateDistribution(self)


class DiscreteDistribution(Distribution):
    """Base class for discrete distributions."""


class Normal(ContinuousDistribution):
    """Defines the normal distribution."""

    def __init__(
        self, *, mu: Union[Parameter, float], sigma: Union[Parameter, float], **kwargs
    ):
        # Sigma must be positive
        if not isinstance(sigma, Parameter) and sigma <= 0:
            raise ValueError("`sigma` must be positive")

        super().__init__(
            numpy_dist="normal",
            stan_to_np_names={"mu": "loc", "sigma": "scale"},
            mu=mu,
            sigma=sigma,
            **kwargs,
        )


class HalfNormal(Normal):
    """Defines the half-normal distribution."""

    def __init__(self, *, sigma: Union[Parameter, float], **kwargs):
        super().__init__(mu=0, sigma=sigma, **kwargs)

    # Overwrite the sample method to ensure that the sampled values are positive
    def sample(self, n: int) -> npt.NDArray:
        return np.abs(super().sample(n))


class UnitNormal(Normal):
    """Defines the unit normal distribution."""

    def __init__(self, **kwargs):
        super().__init__(mu=0, sigma=1, **kwargs)


class Binomial(DiscreteDistribution):
    """Defines the binomial distribution."""

    def __init__(
        self, *, theta: Union[Parameter, float], N: Union[Parameter, int], **kwargs
    ):
        # Theta must be between 0 and 1
        if not isinstance(theta, Parameter) and not 0 <= theta <= 1:
            raise ValueError("`theta` must be between 0 and 1")

        super().__init__(
            numpy_dist="binomial",
            stan_to_np_names={"N": "n", "theta": "p"},
            N=N,
            theta=theta,
            **kwargs,
        )


class Poisson(DiscreteDistribution):
    """Defines the Poisson distribution."""

    def __init__(self, *, lambda_: Union[Parameter, float], **kwargs):

        # Lambda must be positive
        if not isinstance(lambda_, Parameter) and lambda_ <= 0:
            raise ValueError("`lambda_` must be positive")

        super().__init__(
            numpy_dist="poisson",
            stan_to_np_names={"lambda_": "lam"},
            lambda_=lambda_,
            **kwargs,
        )


class Multinomial(DiscreteDistribution):
    """Defines the multinomial distribution."""

    def __init__(
        self,
        *,
        theta: Union[Parameter, npt.ArrayLike],
        N: Optional[Union[Parameter, int]] = None,
        **kwargs,
    ):
        # Sample the theta parameter if it is a distribution
        if isinstance(theta, Parameter):
            sampled = np.array(theta.distribution.sample(1))
            sampled = sampled.unsqueeze(0) if sampled.ndim == 1 else sampled

        # Otherwise make sure that it is a 1D array
        else:
            sampled = np.expand_dims(np.array(theta), 0)
            if sampled.ndim != 2:
                raise ValueError("Thetas must be passed as a 1D array")

        # Whether passed as a parameter or not, the thetas must sum to 1
        if not np.allclose(sampled.sum(axis=-1), 1):
            raise ValueError("All arrays of thetas must sum to 1")

        # Run the parent class's init
        super().__init__(
            numpy_dist="multinomial",
            stan_to_np_names={"N": "n", "theta": "pvals"},
            N=N,
            theta=theta,
            **kwargs,
        )

    def sample(self, n: int) -> npt.NDArray:
        # There must be a value for `N` in the parameters if we are sampling
        if (self.parameters.get("N") is None) and (self.constants.get("N") is None):
            raise ValueError(
                "Sampling from a multinomial distribution is only possible when "
                "'N' is provided'"
            )

        return super().sample(n)


class Beta(ContinuousDistribution):
    """Defines the beta distribution."""

    def __init__(
        self, *, alpha: Union[Parameter, float], beta: Union[Parameter, float], **kwargs
    ):

        # Alpha and beta must be positive
        if not isinstance(alpha, Parameter) and alpha <= 0:
            raise ValueError("`alpha` must be positive")
        if not isinstance(beta, Parameter) and beta <= 0:
            raise ValueError("`beta` must be positive")

        super().__init__(
            numpy_dist="beta",
            stan_to_np_names={"alpha": "a", "beta": "b"},
            alpha=alpha,
            beta=beta,
            **kwargs,
        )


class Dirichlet(ContinuousDistribution):
    """Defines the Dirichlet distribution."""

    def __init__(self, *, alpha: Union[Parameter, npt.ArrayLike], **kwargs):
        # All alpha values must be positive
        if isinstance(alpha, Parameter):
            test_alpha = np.array(alpha.distribution.sample(1))
        else:
            test_alpha = np.array(alpha)
        if not np.all(test_alpha > 0):
            raise ValueError("All `alpha` values must be positive")

        super().__init__(
            numpy_dist="dirichlet",
            stan_to_np_names={"alpha": "alpha"},
            alpha=alpha,
            **kwargs,
        )
