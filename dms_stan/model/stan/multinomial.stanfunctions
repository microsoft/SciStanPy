real partial_sum_of_logints(array[] real count_slice, int start, int end) {
    // Used with reduce_sum to calculate the sum of logs of integers.
    vector[end - start + 1] logints;
    for (i in start:end) {
        logints[i - start + 1] = log(i);
    }
    return sum(to_vector(count_slice) .* logints);
}

array[] real get_count_coefficient(array[] int y) {
    // Count how many times the log of an integer shows up in the log factorial
    // component of the multinomial distribution lpmf.
    int N = sum(y); // Total number of trials
    int K = num_elements(y); // Number of categories

    // Everything is lower than 'N', so we know from the start that there is one
    // of all integers from 1 to N. After that, we SUBTRACT one for each integer
    // between 1 and y_k for all y_k in y
    vector[N] count_of_counts = ones_vector(N);
    for (k in 1:K) {
        for (i in 1:(y[k])) {
            count_of_counts[i] -= 1;
        }
    }

    return to_array_1d(count_of_counts);
}

real unparallelized_multinomial_factorial_component_lpmf(array[] int y) {
    return partial_sum_of_logints(get_count_coefficient(y), 1, num_elements(get_count_coefficient(y)));
}

real parallelized_multinomial_factorial_component_lpmf(array[] int y) {
    // Now we can calculate the sum of the logs of each integer 1 to N multiplied
    // by the number of times it shows up in the log factorial.
    return reduce_sum(partial_sum_of_logints, get_count_coefficient(y), 1);
}

real multinomial_partial_scaled_sum_of_logs(array[] int y, int start, int end, vector theta) {
    // Calculates the partial sum of y_i * log(theta_i) for the multinomial distribution
    return sum(to_vector(y) .* log(theta[start:end]));
}

real unparallelized_multinomial_nonfactorial_component_lpmf(array[] int y, vector theta) {
    return multinomial_partial_scaled_sum_of_logs(y, 1, num_elements(y), theta);
}

real parallelized_multinomial_nonfactorial_component_lpmf(array[] int y, vector theta) {
    // Calculates the log probability mass function for the non-factorial component
    // of the multinomial distribution (i.e., y_1 * log(theta_1) + y_2 * log(theta_2) + ...).
    return reduce_sum(multinomial_partial_scaled_sum_of_logs, y, 1, theta);
}