real stable_sigmoid_growth_init_param(real t, real A, real r, real x0) {
  // Calculates the initial abundance parametrization of the sigmoid growth function.
  // We calculate in such a way that should be more numerically stable

  // Define placeholder variables.
  real exponent;
  real exponentiation;
  real res;
  real abundance_change;

  // x0 must be positive and A must be greater than or equal to x0
  if (x0 <= 0) {
    reject("`x0` must be positive");
  }
  if (A < 0) {
    reject("`A` must be positive");
  }


  // Calculate the exponent and relative change in abundance
  exponent = t * r;
  abundance_change = (A - x0) / x0;

  // If the exponent is positive, we go one route. Negative, otherwise.
  if (exponent >= 0.0) {
    exponentiation = exp(exponent);
    res = exponentiation / (exponentiation + abundance_change);
  } else {
    res = 1 / (1 + exp(exponent) * abundance_change);
  }

  // Multiply by the final abundance
  return res * A;
}

real sigmoid_growth_init_param(real t, real A, real r, real x0) {
  // Just an alias for the `stable_sigmoid_growth_init_param` function
  return stable_sigmoid_growth_init_param(t, A, r, x0);
}

vector sigmoid_growth_init_param(real t, vector A, real r, vector x0) {
  // Calculation when x0 and A are vectors
  int N = size(x0);
  vector[N] res;

  // A must be the same size as x0
  if (size(A) != N) {
    reject("The size of `A` must be the same as the size of `x0`");
  }

  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t, A[n], r, x0[n]);
  }
  return res;
}

vector sigmoid_growth_init_param(real t, vector A, vector r, vector x0) {
  // Calculation when x0, A, and r are vectors
  int N = size(x0);
  vector[N] res;

  // r must be the same size as x0 and A
  if (size(r) != N) {
    reject("The size of `r` must be the same as the size of `x0`");
  }
  if (size(A) != N) {
    reject("The size of `A` must be the same as the size of `x0`");
  }

  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t, A[n], r[n], x0[n]);
  }
  return res;
}

vector sigmoid_growth_init_param(vector t, vector A, vector r, vector x0) {
  // Calculation when t, x0, A, and r are vectors
  int N = size(x0);
  vector[N] res;

  // r must be the same size as x0
  if (size(r) != N) {
    reject("The size of `r` must be the same as the size of `x0`");
  }

  // t must be the same size as x0
  if (size(t) != N) {
    reject("The size of `t` must be the same as the size of `x0`");
  }

  // A must be the same size as x0
  if (size(A) != N) {
    reject("The size of `A` must be the same as the size of `x0`");
  }

  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t[n], A[n], r[n], x0[n]);
  }
  return res;
}