real stable_sigmoid_growth_init_param(real t, real x0, real r) {
  // Calculates the initial abundance parametrization of the sigmoid growth function.
  // We calculate in such a way that should be more numerically stable

  // Define placeholder variables.
  real exponent;
  real exponentiation;
  real res;

  // Error if any x values are greater than or equal to 1
  if (x0 >= 1.0) {
    reject("All 'x0' must be less than 1");
  }
  if (x0 <= 0.0) {
    reject("All 'x0' must be greater than 0");
  }

  // Calculate the exponent
  exponent = t * r;

  // If the exponent is positive, we go one route. Negative, otherwise.
  if (exponent >= 0.0) {
    exponentiation = x0 * exp(exponent);
    res = exponentiation / (exponentiation + 1.0 - x0);
  } else {
    res = x0 / ((1 - x0) * exp(-exponent) + x0);
  }
  return res;
}

real sigmoid_growth_init_param(real t, real x0, real r) {
  // Just an alias for the `stable_sigmoid_growth_init_param` function
  return stable_sigmoid_growth_init_param(t, x0, r);
}

vector sigmoid_growth_init_param(real t, vector x0, real r) {
  // Calculation when x0 is a vector
  int N = size(x0);
  vector[N] res;
  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t, x0[n], r);
  }
  return res;
}

vector sigmoid_growth_init_param(real t, vector x0, vector r) {
  // Calculation when x0 and r are vectors
  int N = size(x0);
  vector[N] res;

  // r must be the same size as x0
  if (size(r) != N) {
    reject("The size of `r` must be the same as the size of `x0`");
  }
  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t, x0[n], r[n]);
  }
  return res;
}

vector sigmoid_growth_init_param(vector t, vector x0, vector r) {
  // Calculation when t, x0, and r are vectors
  int N = size(x0);
  vector[N] res;

  // r must be the same size as x0
  if (size(r) != N) {
    reject("The size of `r` must be the same as the size of `x0`");
  }

  // t must be the same size as x0
  if (size(t) != N) {
    reject("The size of `t` must be the same as the size of `x0`");
  }
  for (n in 1:N) {
    res[n] = stable_sigmoid_growth_init_param(t[n], x0[n], r[n]);
  }
  return res;
}