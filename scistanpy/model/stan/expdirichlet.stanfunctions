real vectorized_lbeta(vector alpha) {
    // Computes the log of the beta function for a vector of parameters alpha.
    // This is used in the exp-dirichlet distribution to calculate the normalization
    // constant.
    return lgamma(sum(alpha)) - sum(lgamma(alpha));
}

vector inv_ilr_log_simplex_constrain_jacobian(vector y) {
    // This function comes from here:
    // https://github.com/bob-carpenter/transforms/blob/main/simplex_transforms/stan/transforms/ILR/ILR_functions.stan
    int N = rows(y) + 1;
    vector[N - 1] ns = linspaced_vector(N - 1, 1, N - 1);
    vector[N - 1] w = y ./ sqrt(ns .* (ns + 1));
    vector[N] z = append_row(reverse(cumulative_sum(reverse(w))), 0) - append_row(0, ns .* w);
    real r = log_sum_exp(z);
    vector[N] log_x = z - r;
    jacobian += 0.5 * log(N);
    return log_x;
}

real expdirichlet_unnorm_lpdf(vector y, vector alpha) {
    // Unnormalized log probability density function for the exp-dirichlet distribution.
    // This is the same as the log of the exponential of the dot product of alpha and y.
    return dot_product(alpha, y);
}

real expdirichlet_norm_lpdf(vector y, vector alpha) {
    // Log probability density function for the exp-dirichlet distribution. For
    // a vector y, if the exponential of y is dirichlet distributed, then y is
    // exp-dirichlet distributed. Equivalently, if y is dirichlet distributed,
    // then log(y) is exp-dirichlet distributed. This is calcualted as the dot
    // product of the alpha and y vectors minus the log of the beta function
    return expdirichlet_unnorm_lpdf(y | alpha) + vectorized_lbeta(alpha);
}

vector expdirichlet_rng(vector alpha) {
    // Generate a random sample from the exp-dirichlet distribution.
    // This is done by generating a dirichlet random variable and then taking
    // the logarithm of the result.
    return log(dirichlet_rng(alpha));
}