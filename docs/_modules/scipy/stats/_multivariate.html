<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.stats._multivariate &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.stats._multivariate</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Author: Joris Vankerschaver 2013</span>
<span class="c1">#</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.linalg</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">doccer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">gammaln</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">multigammaln</span><span class="p">,</span> <span class="n">xlogy</span><span class="p">,</span> <span class="n">entr</span><span class="p">,</span> <span class="n">betaln</span><span class="p">,</span>
                           <span class="n">ive</span><span class="p">,</span> <span class="n">loggamma</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">special</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy._lib.array_api_extra</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xpx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib._util</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.linalg.blas</span><span class="w"> </span><span class="kn">import</span> <span class="n">drot</span><span class="p">,</span> <span class="n">get_blas_funcs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._continuous_distns</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">invgamma</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._discrete_distns</span><span class="w"> </span><span class="kn">import</span> <span class="n">binom</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_covariance</span><span class="p">,</span> <span class="n">_rcont</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._qmvnt</span><span class="w"> </span><span class="kn">import</span> <span class="n">_qmvt</span><span class="p">,</span> <span class="n">_qmvn</span><span class="p">,</span> <span class="n">_qauto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._morestats</span><span class="w"> </span><span class="kn">import</span> <span class="n">directional_stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">root_scalar</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;multivariate_normal&#39;</span><span class="p">,</span>
           <span class="s1">&#39;matrix_normal&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dirichlet&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dirichlet_multinomial&#39;</span><span class="p">,</span>
           <span class="s1">&#39;wishart&#39;</span><span class="p">,</span>
           <span class="s1">&#39;invwishart&#39;</span><span class="p">,</span>
           <span class="s1">&#39;multinomial&#39;</span><span class="p">,</span>
           <span class="s1">&#39;special_ortho_group&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ortho_group&#39;</span><span class="p">,</span>
           <span class="s1">&#39;random_correlation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;unitary_group&#39;</span><span class="p">,</span>
           <span class="s1">&#39;multivariate_t&#39;</span><span class="p">,</span>
           <span class="s1">&#39;multivariate_hypergeom&#39;</span><span class="p">,</span>
           <span class="s1">&#39;random_table&#39;</span><span class="p">,</span>
           <span class="s1">&#39;uniform_direction&#39;</span><span class="p">,</span>
           <span class="s1">&#39;vonmises_fisher&#39;</span><span class="p">,</span>
           <span class="s1">&#39;normal_inverse_gamma&#39;</span><span class="p">]</span>

<span class="n">_LOG_2PI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">_LOG_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">_LOG_PI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">MVN_LOCK</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>


<span class="n">_doc_random_state</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="s2">    Used for drawing random variates.</span>
<span class="s2">    If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="s2">    If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="s2">    with seed.</span>
<span class="s2">    If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="s2">    then that object is used.</span>
<span class="s2">    Default is `None`.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove single-dimensional entries from array and convert to scalar,</span>
<span class="sd">    if necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[()]</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_eigvalsh_to_eps</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine which eigenvalues are &quot;small&quot; given the spectrum.</span>

<span class="sd">    This is for compatibility across various linear algebra functions</span>
<span class="sd">    that should agree about whether or not a Hermitian matrix is numerically</span>
<span class="sd">    singular and what is its numerical matrix rank.</span>
<span class="sd">    This is designed to be compatible with scipy.linalg.pinvh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum : 1d ndarray</span>
<span class="sd">        Array of eigenvalues of a Hermitian matrix.</span>
<span class="sd">    cond, rcond : float, optional</span>
<span class="sd">        Cutoff for small eigenvalues.</span>
<span class="sd">        Singular values smaller than rcond * largest_eigenvalue are</span>
<span class="sd">        considered zero.</span>
<span class="sd">        If None or -1, suitable machine precision is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eps : float</span>
<span class="sd">        Magnitude cutoff for numerical negligibility.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">rcond</span>
    <span class="k">if</span> <span class="n">cond</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">1E3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mf">1E6</span><span class="p">}</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">spectrum</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">eps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pinv_1d</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A helper function for computing the pseudoinverse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : iterable of numbers</span>
<span class="sd">        This may be thought of as a vector of eigenvalues or singular values.</span>
<span class="sd">    eps : float</span>
<span class="sd">        Values with magnitude no greater than eps are considered negligible.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v_pinv : 1d float ndarray</span>
<span class="sd">        A vector of pseudo-inverted numbers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">eps</span> <span class="k">else</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_PSD</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute coordinated functions of a symmetric positive semidefinite matrix.</span>

<span class="sd">    This class addresses two issues.  Firstly it allows the pseudoinverse,</span>
<span class="sd">    the logarithm of the pseudo-determinant, and the rank of the matrix</span>
<span class="sd">    to be computed using one call to eigh instead of three.</span>
<span class="sd">    Secondly it allows these functions to be computed in a way</span>
<span class="sd">    that gives mutually compatible results.</span>
<span class="sd">    All of the functions are computed with a common understanding as to</span>
<span class="sd">    which of the eigenvalues are to be considered negligibly small.</span>
<span class="sd">    The functions are designed to coordinate with scipy.linalg.pinvh()</span>
<span class="sd">    but not necessarily with np.linalg.det() or with np.linalg.matrix_rank().</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : array_like</span>
<span class="sd">        Symmetric positive semidefinite matrix (2-D).</span>
<span class="sd">    cond, rcond : float, optional</span>
<span class="sd">        Cutoff for small eigenvalues.</span>
<span class="sd">        Singular values smaller than rcond * largest_eigenvalue are</span>
<span class="sd">        considered zero.</span>
<span class="sd">        If None or -1, suitable machine precision is used.</span>
<span class="sd">    lower : bool, optional</span>
<span class="sd">        Whether the pertinent array data is taken from the lower</span>
<span class="sd">        or upper triangle of M. (Default: lower)</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite</span>
<span class="sd">        numbers. Disabling may give a performance gain, but may result</span>
<span class="sd">        in problems (crashes, non-termination) if the inputs do contain</span>
<span class="sd">        infinities or NaNs.</span>
<span class="sd">    allow_singular : bool, optional</span>
<span class="sd">        Whether to allow a singular matrix.  (Default: True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arguments are similar to those of scipy.linalg.pinvh().</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># Compute the symmetric eigendecomposition.</span>
        <span class="c1"># Note that eigh takes care of array conversion, chkfinite,</span>
        <span class="c1"># and assertion that the matrix is square.</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>

        <span class="n">eps</span> <span class="o">=</span> <span class="n">_eigvalsh_to_eps</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">rcond</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The input matrix must be symmetric positive semidefinite.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_singular</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;When `allow_singular is False`, the input matrix must be &quot;</span>
                   <span class="s2">&quot;symmetric positive definite.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">s_pinv</span> <span class="o">=</span> <span class="n">_pinv_1d</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_pinv</span><span class="p">))</span>

        <span class="c1"># Save the eigenvector basis, and tolerance for testing support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e3</span><span class="o">*</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">]</span>

        <span class="c1"># Initialize the eagerly precomputed attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

        <span class="c1"># Initialize attributes to be lazily computed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pinv</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_support_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether x lies in the support of the distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">in_support</span> <span class="o">=</span> <span class="n">residual</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">return</span> <span class="n">in_support</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multi_rv_generic</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class which encapsulates common functionality between all multivariate</span>
<span class="sd">    distributions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get or set the Generator object for generating random variates.</span>

<span class="sd">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">        singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">        seeded with `seed`.</span>
<span class="sd">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<span class="sd">        that instance is used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>

    <span class="nd">@random_state</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multi_rv_frozen</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class which encapsulates common functionality between all frozen</span>
<span class="sd">    multivariate distributions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_random_state</span>

    <span class="nd">@random_state</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>


<span class="n">_mvn_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">mean : array_like, default: ``[0]``</span>
<span class="s2">    Mean of the distribution.</span>
<span class="s2">cov : array_like or `Covariance`, default: ``[1]``</span>
<span class="s2">    Symmetric positive (semi)definite covariance matrix of the distribution.</span>
<span class="s2">allow_singular : bool, default: ``False``</span>
<span class="s2">    Whether to allow a singular covariance matrix. This is ignored if `cov` is</span>
<span class="s2">    a `Covariance` object.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mvn_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Setting the parameter `mean` to `None` is equivalent to having `mean`</span>
<span class="s2">be the zero-vector. The parameter `cov` can be a scalar, in which case</span>
<span class="s2">the covariance matrix is the identity times that value, a vector of</span>
<span class="s2">diagonal entries for the covariance matrix, a two-dimensional array_like,</span>
<span class="s2">or a `Covariance` object.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mvn_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_mvn_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">mvn_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_mvn_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_mvn_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_mvn_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mvn_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">mvn_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_mvn_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_mvn_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_mvn_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mvn_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_normal_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A multivariate normal random variable.</span>

<span class="sd">    The `mean` keyword specifies the mean. The `cov` keyword specifies the</span>
<span class="sd">    covariance matrix.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, mean=None, cov=1, allow_singular=False)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, mean=None, cov=1, allow_singular=False)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    cdf(x, mean=None, cov=1, allow_singular=False, maxpts=1000000*dim, abseps=1e-5, releps=1e-5, lower_limit=None)</span>
<span class="sd">        Cumulative distribution function.</span>
<span class="sd">    logcdf(x, mean=None, cov=1, allow_singular=False, maxpts=1000000*dim, abseps=1e-5, releps=1e-5)</span>
<span class="sd">        Log of the cumulative distribution function.</span>
<span class="sd">    rvs(mean=None, cov=1, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a multivariate normal distribution.</span>
<span class="sd">    entropy(mean=None, cov=1)</span>
<span class="sd">        Compute the differential entropy of the multivariate normal.</span>
<span class="sd">    fit(x, fix_mean=None, fix_cov=None)</span>
<span class="sd">        Fit a multivariate normal distribution to data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_mvn_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_mvn_doc_callparams_note)s</span>

<span class="sd">    The covariance matrix `cov` may be an instance of a subclass of</span>
<span class="sd">    `Covariance`, e.g. `scipy.stats.CovViaPrecision`. If so, `allow_singular`</span>
<span class="sd">    is ignored.</span>

<span class="sd">    Otherwise, `cov` must be a symmetric positive semidefinite</span>
<span class="sd">    matrix when `allow_singular` is True; it must be (strictly) positive</span>
<span class="sd">    definite when `allow_singular` is False.</span>
<span class="sd">    Symmetry is not checked; only the lower triangular portion is used.</span>
<span class="sd">    The determinant and inverse of `cov` are computed</span>
<span class="sd">    as the pseudo-determinant and pseudo-inverse, respectively, so</span>
<span class="sd">    that `cov` does not need to have full rank.</span>

<span class="sd">    The probability density function for `multivariate_normal` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = \frac{1}{\sqrt{(2 \pi)^k \det \Sigma}}</span>
<span class="sd">               \exp\left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right),</span>

<span class="sd">    where :math:`\mu` is the mean, :math:`\Sigma` the covariance matrix,</span>
<span class="sd">    :math:`k` the rank of :math:`\Sigma`. In case of singular :math:`\Sigma`,</span>
<span class="sd">    SciPy extends this definition according to [1]_.</span>

<span class="sd">    .. versionadded:: 0.14.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Multivariate Normal Distribution - Degenerate Case, Wikipedia,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import multivariate_normal</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 5, 10, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = multivariate_normal.pdf(x, mean=2.5, cov=0.5); y</span>
<span class="sd">    array([ 0.00108914,  0.01033349,  0.05946514,  0.20755375,  0.43939129,</span>
<span class="sd">            0.56418958,  0.43939129,  0.20755375,  0.05946514,  0.01033349])</span>
<span class="sd">    &gt;&gt;&gt; fig1 = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = fig1.add_subplot(111)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, y)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the mean</span>
<span class="sd">    and covariance parameters, returning a &quot;frozen&quot; multivariate normal</span>
<span class="sd">    random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = multivariate_normal(mean=None, cov=1, allow_singular=False)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # mean and covariance fixed.</span>

<span class="sd">    The input quantiles can be any shape of array, as long as the last</span>
<span class="sd">    axis labels the components.  This allows us for instance to</span>
<span class="sd">    display the frozen pdf for a non-isotropic random variable in 2D as</span>
<span class="sd">    follows:</span>

<span class="sd">    &gt;&gt;&gt; x, y = np.mgrid[-1:1:.01, -1:1:.01]</span>
<span class="sd">    &gt;&gt;&gt; pos = np.dstack((x, y))</span>
<span class="sd">    &gt;&gt;&gt; rv = multivariate_normal([0.5, -0.2], [[2.0, 0.3], [0.3, 0.5]])</span>
<span class="sd">    &gt;&gt;&gt; fig2 = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax2 = fig2.add_subplot(111)</span>
<span class="sd">    &gt;&gt;&gt; ax2.contourf(x, y, rv.pdf(pos))</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mvn_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multivariate normal distribution.</span>

<span class="sd">        See `multivariate_normal_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">multivariate_normal_frozen</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span>
                                          <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">,</span>
                                          <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer dimensionality from mean or covariance matrix, ensure that</span>
<span class="sd">        mean and covariance are full vector resp. matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">_covariance</span><span class="o">.</span><span class="n">Covariance</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters_Covariance</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Before `Covariance` classes were introduced,</span>
            <span class="c1"># `multivariate_normal` accepted plain arrays as `cov` and used the</span>
            <span class="c1"># following input validation. To avoid disturbing the behavior of</span>
            <span class="c1"># `multivariate_normal` when plain arrays are used, we use the</span>
            <span class="c1"># original input validation here.</span>
            <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters_psd</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="c1"># After input validation, some methods then processed the arrays</span>
            <span class="c1"># with a `_PSD` object and used that to perform computation.</span>
            <span class="c1"># To avoid branching statements in each method depending on whether</span>
            <span class="c1"># `cov` is an array or `Covariance` object, we always process the</span>
            <span class="c1"># array with `_PSD`, and then use wrapper that satisfies the</span>
            <span class="c1"># `Covariance` interface, `CovViaPSD`.</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">)</span>
            <span class="n">cov_object</span> <span class="o">=</span> <span class="n">_covariance</span><span class="o">.</span><span class="n">CovViaPSD</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters_Covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span> <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mean</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`cov` represents a covariance matrix in </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> dimensions,&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot;and so `mean` must be broadcastable to shape </span><span class="si">{</span><span class="p">(</span><span class="n">dim</span><span class="p">,)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="c1"># Try to infer dimensionality</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dim</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension of random variable must be &quot;</span>
                                 <span class="s2">&quot;a scalar.&quot;</span><span class="p">)</span>

        <span class="c1"># Check input sizes and return full arrays for mean and cov if</span>
        <span class="c1"># necessary</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Array &#39;mean&#39; must be a vector of length </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">rows</span> <span class="o">!=</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Array &#39;cov&#39; must be square if it is two dimensional,&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; but cov.shape = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension mismatch: array &#39;cov&#39; is of shape </span><span class="si">{</span><span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;but &#39;mean&#39; is a vector of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Array &#39;cov&#39; must be at most two-dimensional, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but cov.ndim = </span><span class="si">{</span><span class="n">cov</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust quantiles array so that last axis labels the components of</span>
<span class="sd">        each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the multivariate normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function</span>
<span class="sd">        mean : ndarray</span>
<span class="sd">            Mean of the distribution</span>
<span class="sd">        cov_object : Covariance</span>
<span class="sd">            An object representing the Covariance matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_det_cov</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="k">if</span> <span class="n">dev</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log_det_cov</span> <span class="o">=</span> <span class="n">log_det_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">maha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">cov_object</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="n">dev</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">*</span> <span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="n">log_det_cov</span> <span class="o">+</span> <span class="n">maha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the multivariate normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            Log of the probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="o">~</span><span class="n">cov_object</span><span class="o">.</span><span class="n">_support_mask</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="o">~</span><span class="n">cov_object</span><span class="o">.</span><span class="n">_support_mask</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">maxpts</span><span class="p">,</span> <span class="n">abseps</span><span class="p">,</span> <span class="n">releps</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate normal cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the cumulative distribution function.</span>
<span class="sd">        mean : ndarray</span>
<span class="sd">            Mean of the distribution</span>
<span class="sd">        cov : array_like</span>
<span class="sd">            Covariance matrix of the distribution</span>
<span class="sd">        maxpts : integer</span>
<span class="sd">            The maximum number of points to use for integration</span>
<span class="sd">        abseps : float</span>
<span class="sd">            Absolute error tolerance</span>
<span class="sd">        releps : float</span>
<span class="sd">            Relative error tolerance</span>
<span class="sd">        lower_limit : array_like, optional</span>
<span class="sd">            Lower limit of integration of the cumulative distribution function.</span>
<span class="sd">            Default is negative infinity. Must be broadcastable with `x`.</span>
<span class="sd">        rng : Generator</span>
<span class="sd">            an instance of ``np.random.Generator``, which is used internally</span>
<span class="sd">            for QMC integration.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;cdf&#39; instead.</span>


<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">lower_limit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lower_limit</span><span class="p">)</span>
        <span class="c1"># In 2d, _mvn.mvnun accepts input in which `lower` bound elements</span>
        <span class="c1"># are greater than `x`. Not so in other dimensions. Fix this by</span>
        <span class="c1"># ensuring that lower bounds are indeed lower when passed, then</span>
        <span class="c1"># set signs of resulting CDF manually.</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">mean</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">mean</span>  <span class="c1"># _qmvn only accepts zero mean</span>
        <span class="n">i_swap</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i_swap</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># odd # of swaps -&gt; negative</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i_swap</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i_swap</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i_swap</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i_swap</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># qmvn expects 1-d arguments, so process points sequentially</span>
        <span class="c1"># XXX: if cov.ndim == 2 and limits.ndim == 1, can avoid apply_along_axis</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">func1d</span><span class="p">(</span><span class="n">limits</span><span class="p">):</span>
            <span class="c1"># res0 = _qmvn(maxpts, cov, limits[:n], limits[n:], rng)[0]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_qauto</span><span class="p">(</span><span class="n">_qmvn</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">limits</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="n">n</span><span class="p">:],</span>
                         <span class="n">rng</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">abseps</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">maxpts</span><span class="p">,</span> <span class="n">n_batches</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span> <span class="o">*</span> <span class="n">signs</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">abseps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">releps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the multivariate normal cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>
<span class="sd">        maxpts : integer, optional</span>
<span class="sd">            The maximum number of points to use for integration</span>
<span class="sd">            (default ``1000000*dim``)</span>
<span class="sd">        abseps : float, optional</span>
<span class="sd">            Absolute error tolerance (default 1e-5)</span>
<span class="sd">        releps : float, optional</span>
<span class="sd">            Relative error tolerance (default 1e-5)</span>
<span class="sd">        lower_limit : array_like, optional</span>
<span class="sd">            Lower limit of integration of the cumulative distribution function.</span>
<span class="sd">            Default is negative infinity. Must be broadcastable with `x`.</span>
<span class="sd">        rng : Generator, optional</span>
<span class="sd">            an instance of ``np.random.Generator``, which is used internally</span>
<span class="sd">            for QMC integration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray or scalar</span>
<span class="sd">            Log of the cumulative distribution function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">covariance</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maxpts</span><span class="p">:</span>
            <span class="n">maxpts</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="n">dim</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">maxpts</span><span class="p">,</span> <span class="n">abseps</span><span class="p">,</span> <span class="n">releps</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="c1"># the log of a negative real is complex, and cdf can be negative</span>
        <span class="c1"># if lower limit is greater than upper limit</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cdf</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">cdf</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cdf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">abseps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">releps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate normal cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>
<span class="sd">        maxpts : integer, optional</span>
<span class="sd">            The maximum number of points to use for integration</span>
<span class="sd">            (default ``1000000*dim``)</span>
<span class="sd">        abseps : float, optional</span>
<span class="sd">            Absolute error tolerance (default 1e-5)</span>
<span class="sd">        releps : float, optional</span>
<span class="sd">            Relative error tolerance (default 1e-5)</span>
<span class="sd">        lower_limit : array_like, optional</span>
<span class="sd">            Lower limit of integration of the cumulative distribution function.</span>
<span class="sd">            Default is negative infinity. Must be broadcastable with `x`.</span>
<span class="sd">        rng : Generator, optional</span>
<span class="sd">            an instance of ``np.random.Generator``, which is used internally</span>
<span class="sd">            for QMC integration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray or scalar</span>
<span class="sd">            Cumulative distribution function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">covariance</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maxpts</span><span class="p">:</span>
            <span class="n">maxpts</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">maxpts</span><span class="p">,</span> <span class="n">abseps</span><span class="p">,</span> <span class="n">releps</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a multivariate normal distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `N`), where `N` is the</span>
<span class="sd">            dimension of the random variable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cov_object</span><span class="p">,</span> <span class="n">_covariance</span><span class="o">.</span><span class="n">CovViaPSD</span><span class="p">):</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">covariance</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cov_object</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the differential entropy of the multivariate normal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_mvn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the multivariate normal distribution</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_mvn_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span> <span class="o">*</span> <span class="p">(</span><span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">cov_object</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fix_mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit a multivariate normal distribution to data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray (m, n)</span>
<span class="sd">            Data the distribution is fitted to. Must have two axes.</span>
<span class="sd">            The first axis of length `m` represents the number of vectors</span>
<span class="sd">            the distribution is fitted to. The second axis of length `n`</span>
<span class="sd">            determines the dimensionality of the fitted distribution.</span>
<span class="sd">        fix_mean : ndarray(n, )</span>
<span class="sd">            Fixed mean vector. Must have length `n`.</span>
<span class="sd">        fix_cov: ndarray (n, n)</span>
<span class="sd">            Fixed covariance matrix. Must have shape ``(n, n)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : ndarray (n, )</span>
<span class="sd">            Maximum likelihood estimate of the mean vector</span>
<span class="sd">        cov : ndarray (n, n)</span>
<span class="sd">            Maximum likelihood estimate of the covariance matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input validation for data to be fitted</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must be two-dimensional.&quot;</span><span class="p">)</span>

        <span class="n">n_vectors</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># parameter estimation</span>
        <span class="c1"># reference: https://home.ttic.edu/~shubhendu/Slides/Estimation.pdf</span>
        <span class="k">if</span> <span class="n">fix_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># input validation for `fix_mean`</span>
            <span class="n">fix_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">fix_mean</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fix_mean</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;`fix_mean` must be a one-dimensional array the same &quot;</span>
                       <span class="s2">&quot;length as the dimensionality of the vectors `x`.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">fix_mean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fix_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># input validation for `fix_cov`</span>
            <span class="n">fix_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fix_cov</span><span class="p">)</span>
            <span class="c1"># validate shape</span>
            <span class="k">if</span> <span class="n">fix_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;`fix_cov` must be a two-dimensional square array &quot;</span>
                       <span class="s2">&quot;of same side length as the dimensionality of the &quot;</span>
                       <span class="s2">&quot;vectors `x`.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># validate positive semidefiniteness</span>
            <span class="c1"># a trimmed down copy from _PSD</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">fix_cov</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">_eigvalsh_to_eps</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;`fix_cov` must be symmetric positive semidefinite.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">fix_cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centered_data</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mean</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">centered_data</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">centered_data</span> <span class="o">/</span> <span class="n">n_vectors</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span>


<span class="n">multivariate_normal</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_normal_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abseps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">releps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multivariate normal distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mean : array_like, default: ``[0]``</span>
<span class="sd">            Mean of the distribution.</span>
<span class="sd">        cov : array_like, default: ``[1]``</span>
<span class="sd">            Symmetric positive (semi)definite covariance matrix of the</span>
<span class="sd">            distribution.</span>
<span class="sd">        allow_singular : bool, default: ``False``</span>
<span class="sd">            Whether to allow a singular covariance matrix.</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>
<span class="sd">        maxpts : integer, optional</span>
<span class="sd">            The maximum number of points to use for integration of the</span>
<span class="sd">            cumulative distribution function (default ``1000000*dim``)</span>
<span class="sd">        abseps : float, optional</span>
<span class="sd">            Absolute error tolerance for the cumulative distribution function</span>
<span class="sd">            (default 1e-5)</span>
<span class="sd">        releps : float, optional</span>
<span class="sd">            Relative error tolerance for the cumulative distribution function</span>
<span class="sd">            (default 1e-5)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        When called with the default parameters, this will create a 1D random</span>
<span class="sd">        variable with mean 0 and covariance 1:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_normal</span>
<span class="sd">        &gt;&gt;&gt; r = multivariate_normal()</span>
<span class="sd">        &gt;&gt;&gt; r.mean</span>
<span class="sd">        array([ 0.])</span>
<span class="sd">        &gt;&gt;&gt; r.cov</span>
<span class="sd">        array([[1.]])</span>

<span class="sd">        &quot;&quot;&quot;</span> <span class="c1"># numpy/numpydoc#87  # noqa: E501</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_singular</span> <span class="o">=</span> <span class="n">allow_singular</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">_allow_singular</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maxpts</span><span class="p">:</span>
            <span class="n">maxpts</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpts</span> <span class="o">=</span> <span class="n">maxpts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abseps</span> <span class="o">=</span> <span class="n">abseps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">releps</span> <span class="o">=</span> <span class="n">releps</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">covariance</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">_support_mask</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="n">lower_limit</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="c1"># the log of a negative real is complex, and cdf can be negative</span>
        <span class="c1"># if lower limit is greater than upper limit</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cdf</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">cdf</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cdf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">maxpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abseps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">releps</span><span class="p">,</span>
                              <span class="n">lower_limit</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the differential entropy of the multivariate normal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the multivariate normal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_pdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">log_pdet</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_object</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">*</span> <span class="p">(</span><span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">log_pdet</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># multivariate_normal_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;logcdf&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">multivariate_normal_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                             <span class="n">mvn_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mvn_docdict_params</span><span class="p">)</span>

<span class="n">_matnorm_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">mean : array_like, optional</span>
<span class="s2">    Mean of the distribution (default: `None`)</span>
<span class="s2">rowcov : array_like, optional</span>
<span class="s2">    Among-row covariance matrix of the distribution (default: ``1``)</span>
<span class="s2">colcov : array_like, optional</span>
<span class="s2">    Among-column covariance matrix of the distribution (default: ``1``)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_matnorm_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">If `mean` is set to `None` then a matrix of zeros is used for the mean.</span>
<span class="s2">The dimensions of this matrix are inferred from the shape of `rowcov` and</span>
<span class="s2">`colcov`, if these are provided, or set to ``1`` if ambiguous.</span>

<span class="s2">`rowcov` and `colcov` can be two-dimensional array_likes specifying the</span>
<span class="s2">covariance matrices directly. Alternatively, a one-dimensional array will</span>
<span class="s2">be be interpreted as the entries of a diagonal matrix, and a scalar or</span>
<span class="s2">zero-dimensional array will be interpreted as this value times the</span>
<span class="s2">identity matrix.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_matnorm_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_matnorm_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">matnorm_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_matnorm_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_matnorm_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_matnorm_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_matnorm_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">matnorm_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_matnorm_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_matnorm_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_matnorm_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_matnorm_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">matrix_normal_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A matrix normal random variable.</span>

<span class="sd">    The `mean` keyword specifies the mean. The `rowcov` keyword specifies the</span>
<span class="sd">    among-row covariance matrix. The &#39;colcov&#39; keyword specifies the</span>
<span class="sd">    among-column covariance matrix.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(X, mean=None, rowcov=1, colcov=1)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(X, mean=None, rowcov=1, colcov=1)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(mean=None, rowcov=1, colcov=1, size=1, random_state=None)</span>
<span class="sd">        Draw random samples.</span>
<span class="sd">    entropy(rowcol=1, colcov=1)</span>
<span class="sd">        Differential entropy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_matnorm_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_matnorm_doc_callparams_note)s</span>

<span class="sd">    The covariance matrices specified by `rowcov` and `colcov` must be</span>
<span class="sd">    (symmetric) positive definite. If the samples in `X` are</span>
<span class="sd">    :math:`m \times n`, then `rowcov` must be :math:`m \times m` and</span>
<span class="sd">    `colcov` must be :math:`n \times n`. `mean` must be the same shape as `X`.</span>

<span class="sd">    The probability density function for `matrix_normal` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(X) = (2 \pi)^{-\frac{mn}{2}}|U|^{-\frac{n}{2}} |V|^{-\frac{m}{2}}</span>
<span class="sd">               \exp\left( -\frac{1}{2} \mathrm{Tr}\left[ U^{-1} (X-M) V^{-1}</span>
<span class="sd">               (X-M)^T \right] \right),</span>

<span class="sd">    where :math:`M` is the mean, :math:`U` the among-row covariance matrix,</span>
<span class="sd">    :math:`V` the among-column covariance matrix.</span>

<span class="sd">    The `allow_singular` behaviour of the `multivariate_normal`</span>
<span class="sd">    distribution is not currently supported. Covariance matrices must be</span>
<span class="sd">    full rank.</span>

<span class="sd">    The `matrix_normal` distribution is closely related to the</span>
<span class="sd">    `multivariate_normal` distribution. Specifically, :math:`\mathrm{Vec}(X)`</span>
<span class="sd">    (the vector formed by concatenating the columns  of :math:`X`) has a</span>
<span class="sd">    multivariate normal distribution with mean :math:`\mathrm{Vec}(M)`</span>
<span class="sd">    and covariance :math:`V \otimes U` (where :math:`\otimes` is the Kronecker</span>
<span class="sd">    product). Sampling and pdf evaluation are</span>
<span class="sd">    :math:`\mathcal{O}(m^3 + n^3 + m^2 n + m n^2)` for the matrix normal, but</span>
<span class="sd">    :math:`\mathcal{O}(m^3 n^3)` for the equivalent multivariate normal,</span>
<span class="sd">    making this equivalent form algorithmically inefficient.</span>

<span class="sd">    .. versionadded:: 0.17.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import matrix_normal</span>

<span class="sd">    &gt;&gt;&gt; M = np.arange(6).reshape(3,2); M</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; U = np.diag([1,2,3]); U</span>
<span class="sd">    array([[1, 0, 0],</span>
<span class="sd">           [0, 2, 0],</span>
<span class="sd">           [0, 0, 3]])</span>
<span class="sd">    &gt;&gt;&gt; V = 0.3*np.identity(2); V</span>
<span class="sd">    array([[ 0.3,  0. ],</span>
<span class="sd">           [ 0. ,  0.3]])</span>
<span class="sd">    &gt;&gt;&gt; X = M + 0.1; X</span>
<span class="sd">    array([[ 0.1,  1.1],</span>
<span class="sd">           [ 2.1,  3.1],</span>
<span class="sd">           [ 4.1,  5.1]])</span>
<span class="sd">    &gt;&gt;&gt; matrix_normal.pdf(X, mean=M, rowcov=U, colcov=V)</span>
<span class="sd">    0.023410202050005054</span>

<span class="sd">    &gt;&gt;&gt; # Equivalent multivariate normal</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import multivariate_normal</span>
<span class="sd">    &gt;&gt;&gt; vectorised_X = X.T.flatten()</span>
<span class="sd">    &gt;&gt;&gt; equiv_mean = M.T.flatten()</span>
<span class="sd">    &gt;&gt;&gt; equiv_cov = np.kron(V,U)</span>
<span class="sd">    &gt;&gt;&gt; multivariate_normal.pdf(vectorised_X, mean=equiv_mean, cov=equiv_cov)</span>
<span class="sd">    0.023410202050005054</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the mean</span>
<span class="sd">    and covariance parameters, returning a &quot;frozen&quot; matrix normal</span>
<span class="sd">    random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = matrix_normal(mean=None, rowcov=1, colcov=1)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # mean and covariance fixed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">matnorm_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen matrix normal distribution.</span>

<span class="sd">        See `matrix_normal_frozen` for more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">matrix_normal_frozen</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer dimensionality from mean or covariance matrices. Handle</span>
<span class="sd">        defaults. Ensure compatible dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Process mean</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">meanshape</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meanshape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `mean` must be two dimensional.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">meanshape</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `mean` has invalid shape.&quot;</span><span class="p">)</span>

        <span class="c1"># Process among-row covariance</span>
        <span class="n">rowcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rowcov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rowcov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rowcov</span> <span class="o">=</span> <span class="n">rowcov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">meanshape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rowcov</span> <span class="o">=</span> <span class="n">rowcov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rowcov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rowcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">rowcov</span><span class="p">)</span>
        <span class="n">rowshape</span> <span class="o">=</span> <span class="n">rowcov</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowshape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`rowcov` must be a scalar or a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rowshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rowshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `rowcov` must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rowshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `rowcov` has invalid shape.&quot;</span><span class="p">)</span>
        <span class="n">numrows</span> <span class="o">=</span> <span class="n">rowshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Process among-column covariance</span>
        <span class="n">colcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">colcov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colcov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colcov</span> <span class="o">=</span> <span class="n">colcov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">meanshape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colcov</span> <span class="o">=</span> <span class="n">colcov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">colcov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">colcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">colcov</span><span class="p">)</span>
        <span class="n">colshape</span> <span class="o">=</span> <span class="n">colcov</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colshape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`colcov` must be a scalar or a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">colshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `colcov` must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array `colcov` has invalid shape.&quot;</span><span class="p">)</span>
        <span class="n">numcols</span> <span class="o">=</span> <span class="n">colshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Ensure mean and covariances compatible</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">meanshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arrays `mean` and `rowcov` must have the &quot;</span>
                                 <span class="s2">&quot;same number of rows.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">meanshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numcols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arrays `mean` and `colcov` must have the &quot;</span>
                                 <span class="s2">&quot;same number of columns.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span><span class="p">))</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dims</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust quantiles array so that last two axes labels the components of</span>
<span class="sd">        each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of array `X` is not compatible &quot;</span>
                             <span class="s2">&quot;with the distribution parameters.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">row_prec_rt</span><span class="p">,</span> <span class="n">log_det_rowcov</span><span class="p">,</span>
                <span class="n">col_prec_rt</span><span class="p">,</span> <span class="n">log_det_colcov</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the matrix normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims : tuple</span>
<span class="sd">            Dimensions of the matrix variates</span>
<span class="sd">        X : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function</span>
<span class="sd">        mean : ndarray</span>
<span class="sd">            Mean of the distribution</span>
<span class="sd">        row_prec_rt : ndarray</span>
<span class="sd">            A decomposition such that np.dot(row_prec_rt, row_prec_rt.T)</span>
<span class="sd">            is the inverse of the among-row covariance matrix</span>
<span class="sd">        log_det_rowcov : float</span>
<span class="sd">            Logarithm of the determinant of the among-row covariance matrix</span>
<span class="sd">        col_prec_rt : ndarray</span>
<span class="sd">            A decomposition such that np.dot(col_prec_rt, col_prec_rt.T)</span>
<span class="sd">            is the inverse of the among-column covariance matrix</span>
<span class="sd">        log_det_colcov : float</span>
<span class="sd">            Logarithm of the determinant of the among-column covariance matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="n">roll_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">X</span><span class="o">-</span><span class="n">mean</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">scale_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">col_prec_rt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">roll_dev</span><span class="p">,</span> <span class="n">row_prec_rt</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">maha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">scale_dev</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">numrows</span><span class="o">*</span><span class="n">numcols</span><span class="o">*</span><span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="n">numcols</span><span class="o">*</span><span class="n">log_det_rowcov</span>
                       <span class="o">+</span> <span class="n">numrows</span><span class="o">*</span><span class="n">log_det_colcov</span> <span class="o">+</span> <span class="n">maha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the matrix normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            Quantiles, with the last two axes of `X` denoting the components.</span>
<span class="sd">        %(_matnorm_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : ndarray</span>
<span class="sd">            Log of the probability density function evaluated at `X`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_matnorm_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span>
                                                              <span class="n">colcov</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="n">rowpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">rowcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">colpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">colcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowpsd</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">rowpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="n">colpsd</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                           <span class="n">colpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Matrix normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            Quantiles, with the last two axes of `X` denoting the components.</span>
<span class="sd">        %(_matnorm_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Probability density function evaluated at `X`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_matnorm_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a matrix normal distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_matnorm_doc_default_callparams)s</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `dims`), where `dims` is the</span>
<span class="sd">            dimension of the random matrices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_matnorm_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">dims</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span>
                                                              <span class="n">colcov</span><span class="p">)</span>
        <span class="n">rowchol</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">rowcov</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">colchol</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">colcov</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># We aren&#39;t generating standard normal variates with size=(size,</span>
        <span class="c1"># dims[0], dims[1]) directly to ensure random variates remain backwards</span>
        <span class="c1"># compatible. See https://github.com/scipy/scipy/pull/12312 for more</span>
        <span class="c1"># details.</span>
        <span class="n">std_norm</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jp,ipq,kq-&gt;ijk&#39;</span><span class="p">,</span>
                               <span class="n">rowchol</span><span class="p">,</span> <span class="n">std_norm</span><span class="p">,</span> <span class="n">colchol</span><span class="p">,</span>
                               <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the matrix normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rowcov : array_like, optional</span>
<span class="sd">            Among-row covariance matrix of the distribution (default: ``1``)</span>
<span class="sd">        colcov : array_like, optional</span>
<span class="sd">            Among-column covariance matrix of the distribution (default: ``1``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        entropy : float</span>
<span class="sd">            Entropy of the distribution</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_matnorm_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dummy_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rowcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">colcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">dims</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dummy_mean</span><span class="p">,</span>
                                                           <span class="n">rowcov</span><span class="p">,</span>
                                                           <span class="n">colcov</span><span class="p">)</span>
        <span class="n">rowpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">rowcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">colpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">colcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">rowpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="n">colpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">row_cov_logdet</span><span class="p">,</span> <span class="n">col_cov_logdet</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">_LOG_2PI</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">row_cov_logdet</span> <span class="o">+</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">col_cov_logdet</span><span class="p">)</span>


<span class="n">matrix_normal</span> <span class="o">=</span> <span class="n">matrix_normal_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">matrix_normal_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a frozen matrix normal distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_matnorm_doc_default_callparams)s</span>
<span class="sd">    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">        If `seed` is `None` the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import matrix_normal</span>

<span class="sd">    &gt;&gt;&gt; distn = matrix_normal(mean=np.zeros((3,3)))</span>
<span class="sd">    &gt;&gt;&gt; X = distn.rvs(); X</span>
<span class="sd">    array([[-0.02976962,  0.93339138, -0.09663178],</span>
<span class="sd">           [ 0.67405524,  0.28250467, -0.93308929],</span>
<span class="sd">           [-0.31144782,  0.74535536,  1.30412916]])</span>
<span class="sd">    &gt;&gt;&gt; distn.pdf(X)</span>
<span class="sd">    2.5160642368346784e-05</span>
<span class="sd">    &gt;&gt;&gt; distn.logpdf(X)</span>
<span class="sd">    -10.590229595124615</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colcov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">matrix_normal_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowcov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">colcov</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">rowcov</span><span class="p">,</span> <span class="n">colcov</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpsd</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colcov</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowpsd</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">rowpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpsd</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">colpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowcov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">colcov</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
                              <span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">colpsd</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># matrix_normal_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">,</span> <span class="s1">&#39;entropy&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">matrix_normal_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">matrix_normal_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                             <span class="n">matnorm_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">matnorm_docdict_params</span><span class="p">)</span>

<span class="n">_dirichlet_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">alpha : array_like</span>
<span class="s2">    The concentration parameters. The number of entries determines the</span>
<span class="s2">    dimensionality of the distribution.</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">_dirichlet_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_dirichlet_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">dirichlet_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_dirichlet_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_dirichlet_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">dirichlet_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_dirichlet_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_dirichlet_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All parameters must be greater than 0&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">alpha</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter vector &#39;a&#39; must be one dimensional, &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;but a.shape = </span><span class="si">{</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">alpha</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dirichlet_check_input</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vector &#39;x&#39; must have either the same number &quot;</span>
                         <span class="s2">&quot;of entries as, or one entry fewer than, &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;parameter vector &#39;a&#39;, but alpha.shape = </span><span class="si">{</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;and x.shape = </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">xk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">xk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">xk</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input must be one dimensional or a two &quot;</span>
                             <span class="s2">&quot;dimensional matrix containing the entries.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each entry in &#39;x&#39; must be greater than or equal &quot;</span>
                         <span class="s2">&quot;to zero.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each entry in &#39;x&#39; must be smaller or equal one.&quot;</span><span class="p">)</span>

    <span class="c1"># Check x_i &gt; 0 or alpha_i &gt; 1</span>
    <span class="n">xeq0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">alphalt1</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">alphalt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">alphalt1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">chk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">xeq0</span><span class="p">,</span> <span class="n">alphalt1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chk</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each entry in &#39;x&#39; must be greater than zero if its &quot;</span>
                         <span class="s2">&quot;alpha is less than one.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">10e-10</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input vector &#39;x&#39; must lie within the normal &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;simplex. but np.sum(x, 0) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_lnB</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Internal helper function to compute the log of the useful quotient.</span>

<span class="sd">    .. math::</span>

<span class="sd">        B(\alpha) = \frac{\prod_{i=1}{K}\Gamma(\alpha_i)}</span>
<span class="sd">                         {\Gamma\left(\sum_{i=1}^{K} \alpha_i \right)}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : scalar</span>
<span class="sd">        Helper quotient, internal use only</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">dirichlet_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A Dirichlet random variable.</span>

<span class="sd">    The ``alpha`` keyword specifies the concentration parameters of the</span>
<span class="sd">    distribution.</span>

<span class="sd">    .. versionadded:: 0.15.0</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, alpha)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, alpha)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(alpha, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a Dirichlet distribution.</span>
<span class="sd">    mean(alpha)</span>
<span class="sd">        The mean of the Dirichlet distribution</span>
<span class="sd">    var(alpha)</span>
<span class="sd">        The variance of the Dirichlet distribution</span>
<span class="sd">    cov(alpha)</span>
<span class="sd">        The covariance of the Dirichlet distribution</span>
<span class="sd">    entropy(alpha)</span>
<span class="sd">        Compute the differential entropy of the Dirichlet distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_dirichlet_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each :math:`\alpha` entry must be positive. The distribution has only</span>
<span class="sd">    support on the simplex defined by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \sum_{i=1}^{K} x_i = 1</span>

<span class="sd">    where :math:`0 &lt; x_i &lt; 1`.</span>

<span class="sd">    If the quantiles don&#39;t lie within the simplex, a ValueError is raised.</span>

<span class="sd">    The probability density function for `dirichlet` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = \frac{1}{\mathrm{B}(\boldsymbol\alpha)} \prod_{i=1}^K x_i^{\alpha_i - 1}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">        \mathrm{B}(\boldsymbol\alpha) = \frac{\prod_{i=1}^K \Gamma(\alpha_i)}</span>
<span class="sd">                                     {\Gamma\bigl(\sum_{i=1}^K \alpha_i\bigr)}</span>

<span class="sd">    and :math:`\boldsymbol\alpha=(\alpha_1,\ldots,\alpha_K)`, the</span>
<span class="sd">    concentration parameters and :math:`K` is the dimension of the space</span>
<span class="sd">    where :math:`x` takes values.</span>

<span class="sd">    Note that the `dirichlet` interface is somewhat inconsistent.</span>
<span class="sd">    The array returned by the rvs function is transposed</span>
<span class="sd">    with respect to the format expected by the pdf and logpdf.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import dirichlet</span>

<span class="sd">    Generate a dirichlet random variable</span>

<span class="sd">    &gt;&gt;&gt; quantiles = np.array([0.2, 0.2, 0.6])  # specify quantiles</span>
<span class="sd">    &gt;&gt;&gt; alpha = np.array([0.4, 5, 15])  # specify concentration parameters</span>
<span class="sd">    &gt;&gt;&gt; dirichlet.pdf(quantiles, alpha)</span>
<span class="sd">    0.2843831684937255</span>

<span class="sd">    The same PDF but following a log scale</span>

<span class="sd">    &gt;&gt;&gt; dirichlet.logpdf(quantiles, alpha)</span>
<span class="sd">    -1.2574327653159187</span>

<span class="sd">    Once we specify the dirichlet distribution</span>
<span class="sd">    we can then calculate quantities of interest</span>

<span class="sd">    &gt;&gt;&gt; dirichlet.mean(alpha)  # get the mean of the distribution</span>
<span class="sd">    array([0.01960784, 0.24509804, 0.73529412])</span>
<span class="sd">    &gt;&gt;&gt; dirichlet.var(alpha) # get variance</span>
<span class="sd">    array([0.00089829, 0.00864603, 0.00909517])</span>
<span class="sd">    &gt;&gt;&gt; dirichlet.entropy(alpha)  # calculate the differential entropy</span>
<span class="sd">    -4.3280162474082715</span>

<span class="sd">    We can also return random samples from the distribution</span>

<span class="sd">    &gt;&gt;&gt; dirichlet.rvs(alpha, size=1, random_state=1)</span>
<span class="sd">    array([[0.00766178, 0.24670518, 0.74563305]])</span>
<span class="sd">    &gt;&gt;&gt; dirichlet.rvs(alpha, size=2, random_state=2)</span>
<span class="sd">    array([[0.01639427, 0.1292273 , 0.85437844],</span>
<span class="sd">           [0.00156917, 0.19033695, 0.80809388]])</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix</span>
<span class="sd">    concentration parameters, returning a &quot;frozen&quot; Dirichlet</span>
<span class="sd">    random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = dirichlet(alpha)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # concentration parameters fixed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">dirichlet_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dirichlet_frozen</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the Dirichlet probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lnB</span> <span class="o">=</span> <span class="n">_lnB</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span> <span class="n">lnB</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xlogy</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the Dirichlet probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            Log of the probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_dirichlet_check_input</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Dirichlet probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            The probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_dirichlet_check_input</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the Dirichlet distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu : ndarray or scalar</span>
<span class="sd">            Mean of the Dirichlet distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the Dirichlet distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        v : ndarray or scalar</span>
<span class="sd">            Variance of the Dirichlet distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">alpha0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="n">alpha0</span> <span class="o">*</span> <span class="n">alpha0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Covariance matrix of the Dirichlet distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cov : ndarray</span>
<span class="sd">            The covariance matrix of the distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">alpha0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">alpha0</span>

        <span class="n">cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">alpha0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differential entropy of the Dirichlet distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the Dirichlet distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">alpha0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">lnB</span> <span class="o">=</span> <span class="n">_lnB</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">lnB</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha0</span> <span class="o">-</span> <span class="n">K</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw random samples from a Dirichlet distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_doc_default_callparams)s</span>
<span class="sd">        size : int, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `N`), where `N` is the</span>
<span class="sd">            dimension of the random variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_state</span><span class="o">.</span><span class="n">dirichlet</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>


<span class="n">dirichlet</span> <span class="o">=</span> <span class="n">dirichlet_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">dirichlet_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">_dirichlet_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">dirichlet_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># multivariate_normal_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;entropy&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">dirichlet_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">dirichlet_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">dirichlet_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">dirichlet_docdict_params</span><span class="p">)</span>


<span class="n">_wishart_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">df : int</span>
<span class="s2">    Degrees of freedom, must be greater than or equal to dimension of the</span>
<span class="s2">    scale matrix</span>
<span class="s2">scale : array_like</span>
<span class="s2">    Symmetric positive definite scale matrix of the distribution</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_wishart_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_wishart_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_wishart_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">wishart_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_wishart_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_wishart_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">wishart_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_wishart_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_wishart_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">wishart_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A Wishart random variable.</span>

<span class="sd">    The `df` keyword specifies the degrees of freedom. The `scale` keyword</span>
<span class="sd">    specifies the scale matrix, which must be symmetric and positive definite.</span>
<span class="sd">    In this context, the scale matrix is often interpreted in terms of a</span>
<span class="sd">    multivariate normal precision matrix (the inverse of the covariance</span>
<span class="sd">    matrix). These arguments must satisfy the relationship</span>
<span class="sd">    ``df &gt; scale.ndim - 1``, but see notes on using the `rvs` method with</span>
<span class="sd">    ``df &lt; scale.ndim``.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, df, scale)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, df, scale)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(df, scale, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a Wishart distribution.</span>
<span class="sd">    entropy()</span>
<span class="sd">        Compute the differential entropy of the Wishart distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    scipy.linalg.LinAlgError</span>
<span class="sd">        If the scale matrix `scale` is not positive definite.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    invwishart, chi2</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_callparams_note)s</span>

<span class="sd">    The scale matrix `scale` must be a symmetric positive definite</span>
<span class="sd">    matrix. Singular matrices, including the symmetric positive semi-definite</span>
<span class="sd">    case, are not supported. Symmetry is not checked; only the lower triangular</span>
<span class="sd">    portion is used.</span>

<span class="sd">    The Wishart distribution is often denoted</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_p(\nu, \Sigma)</span>

<span class="sd">    where :math:`\nu` is the degrees of freedom and :math:`\Sigma` is the</span>
<span class="sd">    :math:`p \times p` scale matrix.</span>

<span class="sd">    The probability density function for `wishart` has support over positive</span>
<span class="sd">    definite matrices :math:`S`; if :math:`S \sim W_p(\nu, \Sigma)`, then</span>
<span class="sd">    its PDF is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(S) = \frac{|S|^{\frac{\nu - p - 1}{2}}}{2^{ \frac{\nu p}{2} }</span>
<span class="sd">               |\Sigma|^\frac{\nu}{2} \Gamma_p \left ( \frac{\nu}{2} \right )}</span>
<span class="sd">               \exp\left( -tr(\Sigma^{-1} S) / 2 \right)</span>

<span class="sd">    If :math:`S \sim W_p(\nu, \Sigma)` (Wishart) then</span>
<span class="sd">    :math:`S^{-1} \sim W_p^{-1}(\nu, \Sigma^{-1})` (inverse Wishart).</span>

<span class="sd">    If the scale matrix is 1-dimensional and equal to one, then the Wishart</span>
<span class="sd">    distribution :math:`W_1(\nu, 1)` collapses to the :math:`\chi^2(\nu)`</span>
<span class="sd">    distribution.</span>

<span class="sd">    The algorithm [2]_ implemented by the `rvs` method may</span>
<span class="sd">    produce numerically singular matrices with :math:`p - 1 &lt; \nu &lt; p`; the</span>
<span class="sd">    user may wish to check for this condition and generate replacement samples</span>
<span class="sd">    as necessary.</span>


<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M.L. Eaton, &quot;Multivariate Statistics: A Vector Space Approach&quot;,</span>
<span class="sd">           Wiley, 1983.</span>
<span class="sd">    .. [2] W.B. Smith and R.R. Hocking, &quot;Algorithm AS 53: Wishart Variate</span>
<span class="sd">           Generator&quot;, Applied Statistics, vol. 21, pp. 341-345, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import wishart, chi2</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(1e-5, 8, 100)</span>
<span class="sd">    &gt;&gt;&gt; w = wishart.pdf(x, df=3, scale=1); w[:5]</span>
<span class="sd">    array([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])</span>
<span class="sd">    &gt;&gt;&gt; c = chi2.pdf(x, 3); c[:5]</span>
<span class="sd">    array([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, w)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The input quantiles can be any shape of array, as long as the last</span>
<span class="sd">    axis labels the components.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the degrees</span>
<span class="sd">    of freedom and scale parameters, returning a &quot;frozen&quot; Wishart random</span>
<span class="sd">    variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = wishart(df=1, scale=1)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # degrees of freedom and scale fixed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen Wishart distribution.</span>

<span class="sd">        See `wishart_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">wishart_frozen</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">scale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">scale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array &#39;scale&#39; must be square if it is two dimensional,&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; but scale.scale = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">scale</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Array &#39;scale&#39; must be at most two-dimensional, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but scale.ndim = </span><span class="si">{</span><span class="n">scale</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom must be a scalar.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">&lt;=</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom must be greater than the &quot;</span>
                             <span class="s2">&quot;dimension of scale matrix minus 1.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust quantiles array so that last axis labels the components of</span>
<span class="sd">        each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Quantiles must be square if they are two dimensional,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; but x.shape = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Quantiles must be square in the first two dimensions &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;if they are three dimensional, but x.shape = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantiles must be at most two-dimensional with an &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;additional dimension for multiple components, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but x.ndim = </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Now we have 3-dim array; should have shape [dim, dim, *]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Quantiles have incompatible dimensions: should&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; be </span><span class="si">{</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="si">}</span><span class="s1">, got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">size</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Size must be an integer or tuple of integers;&#39;</span>
                 <span class="s1">&#39; thus must have dimension &lt;= 1.&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39; Got size.ndim = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">size</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        scale : ndarray</span>
<span class="sd">            Scale matrix</span>
<span class="sd">        log_det_scale : float</span>
<span class="sd">            Logarithm of the determinant of the scale matrix</span>
<span class="sd">        C : ndarray</span>
<span class="sd">            Cholesky factorization of the scale matrix, lower triangular.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log determinant of x</span>
        <span class="c1"># Note: x has components along the last axis, so that x.T has</span>
        <span class="c1"># components alone the 0-th axis. Then since det(A) = det(A&#39;), this</span>
        <span class="c1"># gives us a 1-dim vector of determinants</span>

        <span class="c1"># Retrieve tr(scale^{-1} x)</span>
        <span class="n">log_det_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">scale_inv_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">tr_scale_inv_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">log_det_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">scale_inv_x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">C</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">tr_scale_inv_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_inv_x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>

        <span class="c1"># Log PDF</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_det_x</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tr_scale_inv_x</span><span class="p">)</span> <span class="o">-</span>
               <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="n">_LOG_2</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span> <span class="o">*</span> <span class="n">log_det_scale</span> <span class="o">+</span>
                <span class="n">multigammaln</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">            Each quantile must be a symmetric positive definite matrix.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Log of the probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

        <span class="c1"># Cholesky decomposition of scale, get log(det(scale))</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">log_det_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">            Each quantile must be a symmetric positive definite matrix.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;mean&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">df</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : float</span>
<span class="sd">            The mean of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mode of the Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;mode&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&gt;=</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="o">-</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mode of the Wishart distribution</span>

<span class="sd">        Only valid if the degrees of freedom are greater than the dimension of</span>
<span class="sd">        the scale matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mode : float or None</span>
<span class="sd">            The Mode of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;var&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># 1 x dim array</span>
        <span class="n">var</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">diag</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">*=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var : float</span>
<span class="sd">            The variance of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_standard_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            Number of variates to generate</span>
<span class="sd">        shape : iterable</span>
<span class="sd">            Shape of the variates to generate</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        random_state : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                        `numpy.random.RandomState`}, optional</span>

<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;rvs&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Random normal variates for off-diagonal elements</span>
        <span class="n">n_tril</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">covariances</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="n">n_tril</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">n_tril</span><span class="p">,))</span>

        <span class="c1"># Random chi-square variates for diagonal elements</span>
        <span class="n">variances</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[</span><span class="n">random_state</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="n">df</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span>
                                                          <span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create the A matri(ces) - lower triangular</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

        <span class="c1"># Input the covariances</span>
        <span class="n">size_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">tril_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">size_idx</span> <span class="o">+</span> <span class="n">tril_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariances</span>

        <span class="c1"># Input the variances</span>
        <span class="n">diag_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">size_idx</span> <span class="o">+</span> <span class="n">diag_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">variances</span>

        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            Number of variates to generate</span>
<span class="sd">        shape : iterable</span>
<span class="sd">            Shape of the variates to generate</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        C : ndarray</span>
<span class="sd">            Cholesky factorization of the scale matrix, lower triangular.</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;rvs&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Calculate the matrices A, which are actually lower triangular</span>
        <span class="c1"># Cholesky factorizations of a matrix B such that B ~ W(df, I)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standard_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Calculate SA = C A A&#39; C&#39;, where SA ~ W(df, scale)</span>
        <span class="c1"># Note: this is the product of a (lower) (lower) (lower)&#39; (lower)&#39;</span>
        <span class="c1">#       or, denoting B = AA&#39;, it is C B C&#39; where C is the lower</span>
        <span class="c1">#       triangular Cholesky factorization of the scale matrix.</span>
        <span class="c1">#       this appears to conflict with the instructions in [1]_, which</span>
        <span class="c1">#       suggest that it should be D&#39; B D where D is the lower</span>
        <span class="c1">#       triangular factorization of the scale matrix. However, it is</span>
        <span class="c1">#       meant to refer to the Bartlett (1933) representation of a</span>
        <span class="c1">#       Wishart random variate as L A A&#39; L&#39; where L is lower triangular</span>
        <span class="c1">#       so it appears that understanding D&#39; to be upper triangular</span>
        <span class="c1">#       is either a typo in or misreading of [1]_.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">CA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">CA</span><span class="p">,</span> <span class="n">CA</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>
<span class="sd">        size : integer or iterable of integers, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray</span>
<span class="sd">            Random variates of shape (`size`) + (``dim``, ``dim``), where</span>
<span class="sd">            ``dim`` is the dimension of the scale matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Cholesky decomposition of scale</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the differential entropy of the Wishart.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        log_det_scale : float</span>
<span class="sd">            Logarithm of the determinant of the scale matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;entropy&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_det_scale</span> <span class="o">+</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LOG_2</span> <span class="o">+</span>
            <span class="n">multigammaln</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">-</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="p">[</span><span class="n">psi</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
            <span class="p">)</span> <span class="o">+</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the differential entropy of the Wishart.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the Wishart distribution</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">log_det_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cholesky_logdet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute Cholesky decomposition and determine (log(det(scale)).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : ndarray</span>
<span class="sd">            Scale matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_decomp : ndarray</span>
<span class="sd">            The Cholesky decomposition of `scale`.</span>
<span class="sd">        logdet : scalar</span>
<span class="sd">            The log of the determinant of `scale`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This computation of ``logdet`` is equivalent to</span>
<span class="sd">        ``np.linalg.slogdet(scale)``.  It is ~2x faster though.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_decomp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logdet</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_decomp</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">c_decomp</span><span class="p">,</span> <span class="n">logdet</span>


<span class="n">wishart</span> <span class="o">=</span> <span class="n">wishart_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">wishart_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a frozen Wishart distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : array_like</span>
<span class="sd">        Degrees of freedom of the distribution</span>
<span class="sd">    scale : array_like</span>
<span class="sd">        Scale matrix of the distribution</span>
<span class="sd">    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">        singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">        seeded with `seed`.</span>
<span class="sd">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<span class="sd">        that instance is used.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">wishart_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># Wishart and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">,</span> <span class="s1">&#39;entropy&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">wishart_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">wishart_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">invwishart_gen</span><span class="p">(</span><span class="n">wishart_gen</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An inverse Wishart random variable.</span>

<span class="sd">    The `df` keyword specifies the degrees of freedom. The `scale` keyword</span>
<span class="sd">    specifies the scale matrix, which must be symmetric and positive definite.</span>
<span class="sd">    In this context, the scale matrix is often interpreted in terms of a</span>
<span class="sd">    multivariate normal covariance matrix.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, df, scale)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, df, scale)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(df, scale, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from an inverse Wishart distribution.</span>
<span class="sd">    entropy(df, scale)</span>
<span class="sd">        Differential entropy of the distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    scipy.linalg.LinAlgError</span>
<span class="sd">        If the scale matrix `scale` is not positive definite.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    wishart</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_callparams_note)s</span>

<span class="sd">    The scale matrix `scale` must be a symmetric positive definite</span>
<span class="sd">    matrix. Singular matrices, including the symmetric positive semi-definite</span>
<span class="sd">    case, are not supported. Symmetry is not checked; only the lower triangular</span>
<span class="sd">    portion is used.</span>

<span class="sd">    The inverse Wishart distribution is often denoted</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_p^{-1}(\nu, \Psi)</span>

<span class="sd">    where :math:`\nu` is the degrees of freedom and :math:`\Psi` is the</span>
<span class="sd">    :math:`p \times p` scale matrix.</span>

<span class="sd">    The probability density function for `invwishart` has support over positive</span>
<span class="sd">    definite matrices :math:`S`; if :math:`S \sim W^{-1}_p(\nu, \Sigma)`,</span>
<span class="sd">    then its PDF is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(S) = \frac{|\Sigma|^\frac{\nu}{2}}{2^{ \frac{\nu p}{2} }</span>
<span class="sd">               |S|^{\frac{\nu + p + 1}{2}} \Gamma_p \left(\frac{\nu}{2} \right)}</span>
<span class="sd">               \exp\left( -tr(\Sigma S^{-1}) / 2 \right)</span>

<span class="sd">    If :math:`S \sim W_p^{-1}(\nu, \Psi)` (inverse Wishart) then</span>
<span class="sd">    :math:`S^{-1} \sim W_p(\nu, \Psi^{-1})` (Wishart).</span>

<span class="sd">    If the scale matrix is 1-dimensional and equal to one, then the inverse</span>
<span class="sd">    Wishart distribution :math:`W_1(\nu, 1)` collapses to the</span>
<span class="sd">    inverse Gamma distribution with parameters shape = :math:`\frac{\nu}{2}`</span>
<span class="sd">    and scale = :math:`\frac{1}{2}`.</span>

<span class="sd">    Instead of inverting a randomly generated Wishart matrix as described in [2],</span>
<span class="sd">    here the algorithm in [4] is used to directly generate a random inverse-Wishart</span>
<span class="sd">    matrix without inversion.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M.L. Eaton, &quot;Multivariate Statistics: A Vector Space Approach&quot;,</span>
<span class="sd">           Wiley, 1983.</span>
<span class="sd">    .. [2] M.C. Jones, &quot;Generating Inverse Wishart Matrices&quot;, Communications</span>
<span class="sd">           in Statistics - Simulation and Computation, vol. 14.2, pp.511-514,</span>
<span class="sd">           1985.</span>
<span class="sd">    .. [3] Gupta, M. and Srivastava, S. &quot;Parametric Bayesian Estimation of</span>
<span class="sd">           Differential Entropy and Relative Entropy&quot;. Entropy 12, 818 - 843.</span>
<span class="sd">           2010.</span>
<span class="sd">    .. [4] S.D. Axen, &quot;Efficiently generating inverse-Wishart matrices and</span>
<span class="sd">           their Cholesky factors&quot;, :arXiv:`2310.15884v1`. 2023.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import invwishart, invgamma</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0.01, 1, 100)</span>
<span class="sd">    &gt;&gt;&gt; iw = invwishart.pdf(x, df=6, scale=1)</span>
<span class="sd">    &gt;&gt;&gt; iw[:3]</span>
<span class="sd">    array([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])</span>
<span class="sd">    &gt;&gt;&gt; ig = invgamma.pdf(x, 6/2., scale=1./2)</span>
<span class="sd">    &gt;&gt;&gt; ig[:3]</span>
<span class="sd">    array([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, iw)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The input quantiles can be any shape of array, as long as the last</span>
<span class="sd">    axis labels the components.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the degrees</span>
<span class="sd">    of freedom and scale parameters, returning a &quot;frozen&quot; inverse Wishart</span>
<span class="sd">    random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = invwishart(df=1, scale=1)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # degrees of freedom and scale fixed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen inverse Wishart distribution.</span>

<span class="sd">        See `invwishart_frozen` for more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">invwishart_frozen</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the inverse Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function.</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        log_det_scale : float</span>
<span class="sd">            Logarithm of the determinant of the scale matrix</span>
<span class="sd">        C : ndarray</span>
<span class="sd">            Cholesky factorization of the scale matrix, lower triangular.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve tr(scale x^{-1})</span>
        <span class="n">log_det_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">tr_scale_x_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">trsm</span> <span class="o">=</span> <span class="n">get_blas_funcs</span><span class="p">((</span><span class="s1">&#39;trsm&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">Cx</span><span class="p">,</span> <span class="n">log_det_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">trsm</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">tr_scale_x_inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_det_x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">tr_scale_x_inv</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Log PDF</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span> <span class="o">*</span> <span class="n">log_det_scale</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tr_scale_x_inv</span><span class="p">)</span> <span class="o">-</span>
               <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="n">_LOG_2</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">+</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_det_x</span><span class="p">)</span> <span class="o">-</span>
               <span class="n">multigammaln</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the inverse Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">            Each quantile must be a symmetric positive definite matrix.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Log of the probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">log_det_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverse Wishart probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">            Each quantile must be a symmetric positive definite matrix.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;mean&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&gt;</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the inverse Wishart distribution.</span>

<span class="sd">        Only valid if the degrees of freedom are greater than the dimension of</span>
<span class="sd">        the scale matrix plus one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : float or None</span>
<span class="sd">            The mean of the distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mode of the inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;mode&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span> <span class="o">+</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mode of the inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mode : float</span>
<span class="sd">            The Mode of the distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;var&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&gt;</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># 1 x dim array</span>
            <span class="n">var</span> <span class="o">+=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">diag</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">/=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the inverse Wishart distribution.</span>

<span class="sd">        Only valid if the degrees of freedom are greater than the dimension of</span>
<span class="sd">        the scale matrix plus three.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var : float</span>
<span class="sd">            The variance of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inv_standard_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            Number of variates to generate</span>
<span class="sd">        shape : iterable</span>
<span class="sd">            Shape of the variates to generate</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        random_state : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                        `numpy.random.RandomState`}, optional</span>

<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A : ndarray</span>
<span class="sd">            Random variates of shape (`shape`) + (``dim``, ``dim``).</span>
<span class="sd">            Each slice `A[..., :, :]` is lower-triangular, and its</span>
<span class="sd">            inverse is the lower Cholesky factor of a draw from</span>
<span class="sd">            `invwishart(df, np.eye(dim))`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;rvs&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

        <span class="c1"># Random normal variates for off-diagonal elements</span>
        <span class="n">tri_rows</span><span class="p">,</span> <span class="n">tri_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n_tril</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tri_rows</span><span class="p">,</span> <span class="n">tri_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">n_tril</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Random chi variates for diagonal elements</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">chi_dfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">rows</span>
        <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">chi_dfs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span>
        <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from an inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            Number of variates to generate</span>
<span class="sd">        shape : iterable</span>
<span class="sd">            Shape of the variates to generate</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the scale matrix</span>
<span class="sd">        df : int</span>
<span class="sd">            Degrees of freedom</span>
<span class="sd">        C : ndarray</span>
<span class="sd">            Cholesky factorization of the scale matrix, lower triangular.</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;rvs&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Get random draws A such that inv(A) ~ iW(df, I)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_standard_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Calculate SA = (CA)&#39;^{-1} (CA)^{-1} ~ iW(df, scale)</span>
        <span class="n">trsm</span> <span class="o">=</span> <span class="n">get_blas_funcs</span><span class="p">((</span><span class="s1">&#39;trsm&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,))</span>
        <span class="n">trmm</span> <span class="o">=</span> <span class="n">get_blas_funcs</span><span class="p">((</span><span class="s1">&#39;trmm&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,))</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Calculate CA</span>
                <span class="c1"># Get CA = C A^{-1} via triangular solver</span>
                <span class="n">CA</span> <span class="o">=</span> <span class="n">trsm</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># get SA</span>
                <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">trmm</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">CA</span><span class="p">,</span> <span class="n">CA</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trans_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from an inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>
<span class="sd">        size : integer or iterable of integers, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray</span>
<span class="sd">            Random variates of shape (`size`) + (``dim``, ``dim``), where</span>
<span class="sd">            ``dim`` is the dimension of the scale matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Cholesky decomposition of scale</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">):</span>
        <span class="c1"># reference: eq. (17) from ref. 3</span>
        <span class="n">psi_eval_points</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">psi_eval_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">psi_eval_points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">multigammaln</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> \
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_det_scale</span> <span class="o">-</span> <span class="n">_LOG_2</span><span class="p">)</span> <span class="o">-</span> \
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">+</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">psi</span><span class="p">(</span><span class="n">psi_eval_points</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">psi_eval_points</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">log_det_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky_logdet</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">log_det_scale</span><span class="p">)</span>


<span class="n">invwishart</span> <span class="o">=</span> <span class="n">invwishart_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">invwishart_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen inverse Wishart distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : array_like</span>
<span class="sd">            Degrees of freedom of the distribution</span>
<span class="sd">        scale : array_like</span>
<span class="sd">            Scale matrix of the distribution</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`}, optional</span>
<span class="sd">            If `seed` is None the `numpy.random.Generator` singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``Generator`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` instance then that instance is</span>
<span class="sd">            used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">invwishart_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">scale</span>
        <span class="p">)</span>

        <span class="c1"># Get the determinant via Cholesky factorization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_det_scale</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># inverse Wishart and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">invwishart_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">wishart_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">wishart_docdict_params</span><span class="p">)</span>

<span class="n">_multinomial_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">n : int</span>
<span class="s2">    Number of trials</span>
<span class="s2">p : array_like</span>
<span class="s2">    Probability of a trial falling into each category; should sum to 1</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_multinomial_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">`n` should be a nonnegative integer. Each element of `p` should be in the</span>
<span class="s2">interval :math:`[0,1]` and the elements should sum to 1. If they do not sum to</span>
<span class="s2">1, the last element of the `p` array is not used and is replaced with the</span>
<span class="s2">remaining probability left over from the earlier elements.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_multinomial_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_multinomial_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">multinomial_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_multinomial_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_multinomial_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">multinomial_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_multinomial_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_multinomial_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multinomial_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A multinomial random variable.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pmf(x, n, p)</span>
<span class="sd">        Probability mass function.</span>
<span class="sd">    logpmf(x, n, p)</span>
<span class="sd">        Log of the probability mass function.</span>
<span class="sd">    rvs(n, p, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a multinomial distribution.</span>
<span class="sd">    entropy(n, p)</span>
<span class="sd">        Compute the entropy of the multinomial distribution.</span>
<span class="sd">    cov(n, p)</span>
<span class="sd">        Compute the covariance matrix of the multinomial distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_callparams_note)s</span>

<span class="sd">    The probability mass function for `multinomial` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = \frac{n!}{x_1! \cdots x_k!} p_1^{x_1} \cdots p_k^{x_k},</span>

<span class="sd">    supported on :math:`x=(x_1, \ldots, x_k)` where each :math:`x_i` is a</span>
<span class="sd">    nonnegative integer and their sum is :math:`n`.</span>

<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from scipy.stats import multinomial</span>
<span class="sd">    &gt;&gt;&gt; rv = multinomial(8, [0.3, 0.2, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; rv.pmf([1, 3, 4])</span>
<span class="sd">    0.042000000000000072</span>

<span class="sd">    The multinomial distribution for :math:`k=2` is identical to the</span>
<span class="sd">    corresponding binomial distribution (tiny numerical differences</span>
<span class="sd">    notwithstanding):</span>

<span class="sd">    &gt;&gt;&gt; from scipy.stats import binom</span>
<span class="sd">    &gt;&gt;&gt; multinomial.pmf([3, 4], n=7, p=[0.4, 0.6])</span>
<span class="sd">    0.29030399999999973</span>
<span class="sd">    &gt;&gt;&gt; binom.pmf(3, 7, 0.4)</span>
<span class="sd">    0.29030400000000012</span>

<span class="sd">    The functions ``pmf``, ``logpmf``, ``entropy``, and ``cov`` support</span>
<span class="sd">    broadcasting, under the convention that the vector parameters (``x`` and</span>
<span class="sd">    ``p``) are interpreted as if each row along the last axis is a single</span>
<span class="sd">    object. For instance:</span>

<span class="sd">    &gt;&gt;&gt; multinomial.pmf([[3, 4], [3, 5]], n=[7, 8], p=[.3, .7])</span>
<span class="sd">    array([0.2268945,  0.25412184])</span>

<span class="sd">    Here, ``x.shape == (2, 2)``, ``n.shape == (2,)``, and ``p.shape == (2,)``,</span>
<span class="sd">    but following the rules mentioned above they behave as if the rows</span>
<span class="sd">    ``[3, 4]`` and ``[3, 5]`` in ``x`` and ``[.3, .7]`` in ``p`` were a single</span>
<span class="sd">    object, and as if we had ``x.shape = (2,)``, ``n.shape = (2,)``, and</span>
<span class="sd">    ``p.shape = ()``. To obtain the individual elements without broadcasting,</span>
<span class="sd">    we would do this:</span>

<span class="sd">    &gt;&gt;&gt; multinomial.pmf([3, 4], n=7, p=[.3, .7])</span>
<span class="sd">    0.2268945</span>
<span class="sd">    &gt;&gt;&gt; multinomial.pmf([3, 5], 8, p=[.3, .7])</span>
<span class="sd">    0.25412184</span>

<span class="sd">    This broadcasting also works for ``cov``, where the output objects are</span>
<span class="sd">    square matrices of size ``p.shape[-1]``. For example:</span>

<span class="sd">    &gt;&gt;&gt; multinomial.cov([4, 5], [[.3, .7], [.4, .6]])</span>
<span class="sd">    array([[[ 0.84, -0.84],</span>
<span class="sd">            [-0.84,  0.84]],</span>
<span class="sd">           [[ 1.2 , -1.2 ],</span>
<span class="sd">            [-1.2 ,  1.2 ]]])</span>

<span class="sd">    In this example, ``n.shape == (2,)`` and ``p.shape == (2, 2)``, and</span>
<span class="sd">    following the rules above, these broadcast as if ``p.shape == (2,)``.</span>
<span class="sd">    Thus the result should also be of shape ``(2,)``, but since each output is</span>
<span class="sd">    a :math:`2 \times 2` matrix, the result in fact has shape ``(2, 2, 2)``,</span>
<span class="sd">    where ``result[0]`` is equal to ``multinomial.cov(n=4, p=[.3, .7])`` and</span>
<span class="sd">    ``result[1]`` is equal to ``multinomial.cov(n=5, p=[.4, .6])``.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the `n` and</span>
<span class="sd">    `p` parameters, returning a &quot;frozen&quot; multinomial random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = multinomial(n=7, p=[.3, .7])</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given</span>
<span class="sd">    &gt;&gt;&gt; # degrees of freedom and scale fixed.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.stats.binom : The binomial distribution.</span>
<span class="sd">    numpy.random.Generator.multinomial : Sampling from the multinomial distribution.</span>
<span class="sd">    scipy.stats.multivariate_hypergeom :</span>
<span class="sd">        The multivariate hypergeometric distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
            <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">multinomial_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multinomial distribution.</span>

<span class="sd">        See `multinomial_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">multinomial_frozen</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns: n_, p_, npcond.</span>

<span class="sd">        n_ and p_ are arrays of the correct shape; npcond is a boolean array</span>
<span class="sd">        flagging values out of the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">p_adjusted</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># only make adjustment when it&#39;s significant</span>
        <span class="n">i_adjusted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i_adjusted</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_adjusted</span><span class="p">[</span><span class="n">i_adjusted</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i_adjusted</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Some rows of `p` do not sum to 1.0 within tolerance of &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">eps</span><span class="si">=}</span><span class="s2">. Currently, the last element of these rows is adjusted &quot;</span>
                       <span class="s2">&quot;to compensate, but this condition will produce NaNs &quot;</span>
                       <span class="s2">&quot;beginning in SciPy 1.18.0. Please ensure that rows of `p` sum &quot;</span>
                       <span class="s2">&quot;to 1.0 to avoid futher disruption.&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># true for bad p</span>
        <span class="n">pcond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pcond</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># true for bad n</span>
        <span class="n">ncond</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ncond</span> <span class="o">|</span> <span class="n">pcond</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns: x_, xcond.</span>

<span class="sd">        x_ is an int array; xcond is a boolean array flagging values out of the</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be an array.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of each quantile should be size of p: &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, but expected &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># true for x out of the domain</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xx</span> <span class="o">!=</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">cond</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_checkresult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">bad_value</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_value</span>
        <span class="k">elif</span> <span class="n">cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bad_value</span>
            <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_value</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xlogy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the Multinomial probability mass function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpmf : ndarray or scalar</span>
<span class="sd">            Log of the probability mass function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">xcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># replace values for which x was out of the domain; broadcast</span>
        <span class="c1"># xcond to the right shape</span>
        <span class="n">xcond_</span> <span class="o">=</span> <span class="n">xcond</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npcond</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">xcond_</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="c1"># replace values bad for n or p; broadcast npcond to the right shape</span>
        <span class="n">npcond_</span> <span class="o">=</span> <span class="n">npcond</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xcond</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">npcond_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multinomial probability mass function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pmf : ndarray or scalar</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the Multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : float</span>
<span class="sd">            The mean of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">p</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">npcond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Covariance matrix of the multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cov : ndarray</span>
<span class="sd">            The covariance matrix of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">nn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,...k-&gt;...jk&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># change the diagonal</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">npcond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the entropy of the multinomial distribution.</span>

<span class="sd">        The entropy is computed using this expression:</span>

<span class="sd">        .. math::</span>

<span class="sd">            f(x) = - \log n! - n\sum_{i=1}^k p_i \log p_i +</span>
<span class="sd">            \sum_{i=1}^k \sum_{x=0}^n \binom n x p_i^x(1-p_i)^{n-x} \log x!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the Multinomial distribution</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">term1</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">entr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">term1</span> <span class="o">-=</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">new_axes_needed</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">new_axes_needed</span>

        <span class="n">term2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">gammaln</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                       <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">new_axes_needed</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span><span class="p">,</span> <span class="n">npcond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a Multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>
<span class="sd">        size : integer or iterable of integers, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of shape (`size`, `len(p)`)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>


<span class="n">multinomial</span> <span class="o">=</span> <span class="n">multinomial_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multinomial_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a frozen Multinomial distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        number of trials</span>
<span class="sd">    p: array_like</span>
<span class="sd">        probability of a trial falling into each category; should sum to 1</span>
<span class="sd">    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">        singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">        seeded with `seed`.</span>
<span class="sd">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<span class="sd">        that instance is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">multinomial_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># monkey patch self._dist</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npcond</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span> <span class="o">=</span> <span class="n">_process_parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># multinomial and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpmf&#39;</span><span class="p">,</span> <span class="s1">&#39;pmf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">multinomial_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">multinomial_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">multinomial_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                      <span class="n">multinomial_docdict_params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">special_ortho_group_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A Special Orthogonal matrix (SO(N)) random variable.</span>

<span class="sd">    Return a random rotation matrix, drawn from the Haar distribution</span>
<span class="sd">    (the only uniform distribution on SO(N)) with a determinant of +1.</span>

<span class="sd">    The `dim` keyword specifies the dimension N.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    rvs(dim=None, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from SO(N).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : scalar</span>
<span class="sd">        Dimension of matrices</span>
<span class="sd">    seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``rvs`` method returns a random rotation matrix drawn from the Haar</span>
<span class="sd">    distribution, the only uniform distribution on SO(N). The algorithm generates</span>
<span class="sd">    a Haar-distributed orthogonal matrix in O(N) using the ``rvs`` method of</span>
<span class="sd">    `ortho_group`, then adjusts the matrix to ensure that the determinant is +1.</span>

<span class="sd">    For a random rotation in three dimensions, see</span>
<span class="sd">    `scipy.spatial.transform.Rotation.random`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import special_ortho_group</span>
<span class="sd">    &gt;&gt;&gt; x = special_ortho_group.rvs(3)</span>

<span class="sd">    &gt;&gt;&gt; np.dot(x, x.T)</span>
<span class="sd">    array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],</span>
<span class="sd">           [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],</span>
<span class="sd">           [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.linalg</span>
<span class="sd">    &gt;&gt;&gt; scipy.linalg.det(x)</span>
<span class="sd">    1.0</span>

<span class="sd">    This generates one random matrix from SO(3). It is orthogonal and</span>
<span class="sd">    has a determinant of 1.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the `dim`</span>
<span class="sd">    parameter, returning a &quot;frozen&quot; special_ortho_group random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = special_ortho_group(5)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the</span>
<span class="sd">    &gt;&gt;&gt; # dimension parameter fixed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ortho_group, scipy.spatial.transform.Rotation.random</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen SO(N) distribution.</span>

<span class="sd">        See `special_ortho_group_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">special_ortho_group_frozen</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension N must be specified; it cannot be inferred.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Dimension of rotation must be specified,</span>
<span class="s2">                                and must be a scalar nonnegative integer.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from SO(N).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : integer</span>
<span class="sd">            Dimension of rotation space (N).</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random size N-dimensional matrices, dimension (size, dim, dim)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">ortho_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">dets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span><span class="p">:</span>
            <span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">dets</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">q</span>

<span class="n">special_ortho_group</span> <span class="o">=</span> <span class="n">special_ortho_group_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">special_ortho_group_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen SO(N) distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : scalar</span>
<span class="sd">            Dimension of matrices</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import special_ortho_group</span>
<span class="sd">        &gt;&gt;&gt; g = special_ortho_group(5)</span>
<span class="sd">        &gt;&gt;&gt; x = g.rvs()</span>

<span class="sd">        &quot;&quot;&quot;</span> <span class="c1"># numpy/numpydoc#87  # noqa: E501</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">special_ortho_group_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ortho_group_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An Orthogonal matrix (O(N)) random variable.</span>

<span class="sd">    Return a random orthogonal matrix, drawn from the O(N) Haar</span>
<span class="sd">    distribution (the only uniform distribution on O(N)).</span>

<span class="sd">    The `dim` keyword specifies the dimension N.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    rvs(dim=None, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from O(N).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : scalar</span>
<span class="sd">        Dimension of matrices</span>
<span class="sd">    seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is closely related to `special_ortho_group`.</span>

<span class="sd">    Some care is taken to avoid numerical error, as per the paper by Mezzadri.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Mezzadri, &quot;How to generate random matrices from the classical</span>
<span class="sd">           compact groups&quot;, :arXiv:`math-ph/0609050v2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import ortho_group</span>
<span class="sd">    &gt;&gt;&gt; x = ortho_group.rvs(3)</span>

<span class="sd">    &gt;&gt;&gt; np.dot(x, x.T)</span>
<span class="sd">    array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],</span>
<span class="sd">           [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],</span>
<span class="sd">           [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.linalg</span>
<span class="sd">    &gt;&gt;&gt; np.fabs(scipy.linalg.det(x))</span>
<span class="sd">    1.0</span>

<span class="sd">    This generates one random matrix from O(3). It is orthogonal and</span>
<span class="sd">    has a determinant of +1 or -1.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the `dim`</span>
<span class="sd">    parameter, returning a &quot;frozen&quot; ortho_group random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = ortho_group(5)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the</span>
<span class="sd">    &gt;&gt;&gt; # dimension parameter fixed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    special_ortho_group</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen O(N) distribution.</span>

<span class="sd">        See `ortho_group_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ortho_group_frozen</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension N must be specified; it cannot be inferred.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension of rotation must be specified,&quot;</span>
                             <span class="s2">&quot;and must be a scalar nonnegative integer.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from O(N).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : integer</span>
<span class="sd">            Dimension of rotation space (N).</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random size N-dimensional matrices, dimension (size, dim, dim)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span> <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="c1"># The last two dimensions are the rows and columns of R matrices.</span>
        <span class="c1"># Extract the diagonals. Note that this eliminates a dimension.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Add back a dimension for proper broadcasting: we&#39;re dividing</span>
        <span class="c1"># each row of each R matrix by the diagonal of the R matrix.</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># to broadcast properly</span>
        <span class="k">return</span> <span class="n">q</span>


<span class="n">ortho_group</span> <span class="o">=</span> <span class="n">ortho_group_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ortho_group_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen O(N) distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : scalar</span>
<span class="sd">            Dimension of matrices</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import ortho_group</span>
<span class="sd">        &gt;&gt;&gt; g = ortho_group(5)</span>
<span class="sd">        &gt;&gt;&gt; x = g.rvs()</span>

<span class="sd">        &quot;&quot;&quot;</span> <span class="c1"># numpy/numpydoc#87  # noqa: E501</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">ortho_group_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">random_correlation_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A random correlation matrix.</span>

<span class="sd">    Return a random correlation matrix, given a vector of eigenvalues.</span>
<span class="sd">    The returned matrix is symmetric positive semidefinite with unit diagonal.</span>

<span class="sd">    The `eigs` keyword specifies the eigenvalues of the correlation matrix,</span>
<span class="sd">    and implies the dimension.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    rvs(eigs=None, random_state=None)</span>
<span class="sd">        Draw random correlation matrices, all with eigenvalues eigs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eigs : 1d ndarray</span>
<span class="sd">        Eigenvalues of correlation matrix. All eigenvalues need to be non-negative and</span>
<span class="sd">        need to sum to the number of eigenvalues.</span>
<span class="sd">    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">        singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">        seeded with `seed`.</span>
<span class="sd">        If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">        then that instance is used.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for input parameter checks</span>
<span class="sd">    diag_tol : float, optional</span>
<span class="sd">        Tolerance for deviation of the diagonal of the resulting</span>
<span class="sd">        matrix. Default: 1e-7</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        Floating point error prevented generating a valid correlation</span>
<span class="sd">        matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rvs : ndarray or scalar</span>
<span class="sd">        Random size N-dimensional matrices, dimension (size, dim, dim),</span>
<span class="sd">        each having eigenvalues eigs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Generates a random correlation matrix following a numerically stable</span>
<span class="sd">    algorithm spelled out by Davies &amp; Higham. This algorithm uses a single O(N)</span>
<span class="sd">    similarity transformation to construct a symmetric positive semi-definite</span>
<span class="sd">    matrix, and applies a series of Givens rotations to scale it to have ones</span>
<span class="sd">    on the diagonal.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Davies, Philip I; Higham, Nicholas J; &quot;Numerically stable generation</span>
<span class="sd">           of correlation matrices and their factors&quot;, BIT 2000, Vol. 40,</span>
<span class="sd">           No. 4, pp. 640 651</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import random_correlation</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; x = random_correlation.rvs((.5, .8, 1.2, 1.5), random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 1.        , -0.02423399,  0.03130519,  0.4946965 ],</span>
<span class="sd">           [-0.02423399,  1.        ,  0.20334736,  0.04039817],</span>
<span class="sd">           [ 0.03130519,  0.20334736,  1.        ,  0.02694275],</span>
<span class="sd">           [ 0.4946965 ,  0.04039817,  0.02694275,  1.        ]])</span>
<span class="sd">    &gt;&gt;&gt; import scipy.linalg</span>
<span class="sd">    &gt;&gt;&gt; e, v = scipy.linalg.eigh(x)</span>
<span class="sd">    &gt;&gt;&gt; e</span>
<span class="sd">    array([ 0.5,  0.8,  1.2,  1.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-13</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen random correlation matrix.</span>

<span class="sd">        See `random_correlation_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random_correlation_frozen</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                         <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
        <span class="n">eigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">eigs</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">eigs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">eigs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array &#39;eigs&#39; must be a vector of length &quot;</span>
                             <span class="s2">&quot;greater than 1.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eigs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sum of eigenvalues must equal dimensionality.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eigs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">tol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All eigenvalues must be non-negative.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">eigs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_givens_to_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aii</span><span class="p">,</span> <span class="n">ajj</span><span class="p">,</span> <span class="n">aij</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes a 2x2 Givens matrix to put 1&#39;s on the diagonal.</span>

<span class="sd">        The input matrix is a 2x2 symmetric matrix M = [ aii aij ; aij ajj ].</span>

<span class="sd">        The output matrix g is a 2x2 anti-symmetric matrix of the form</span>
<span class="sd">        [ c s ; -s c ];  the elements c and s are returned.</span>

<span class="sd">        Applying the output matrix to the input matrix (as b=g.T M g)</span>
<span class="sd">        results in a matrix with bii=1, provided tr(M) - det(M) &gt;= 1</span>
<span class="sd">        and floating point issues do not occur. Otherwise, some other</span>
<span class="sd">        valid rotation is returned. When tr(M)==2, also bjj=1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aiid</span> <span class="o">=</span> <span class="n">aii</span> <span class="o">-</span> <span class="mf">1.</span>
        <span class="n">ajjd</span> <span class="o">=</span> <span class="n">ajj</span> <span class="o">-</span> <span class="mf">1.</span>

        <span class="k">if</span> <span class="n">ajjd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># ajj==1, so swap aii and ajj to avoid division by zero</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span>

        <span class="n">dd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">aij</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">aiid</span><span class="o">*</span><span class="n">ajjd</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># The choice of t should be chosen to avoid cancellation [1]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">aij</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">aij</span><span class="p">))</span> <span class="o">/</span> <span class="n">ajjd</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Underflow</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a psd matrix m, rotate to put one&#39;s on the diagonal, turning it</span>
<span class="sd">        into a correlation matrix.  This also requires the trace equal the</span>
<span class="sd">        dimensionality. Note: modifies input matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check requirements for in-place Givens</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="ow">and</span>
                <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_givens_to_1</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

            <span class="c1"># Use BLAS to apply Givens rotations in-place. Equivalent to:</span>
            <span class="c1"># g = np.eye(d)</span>
            <span class="c1"># g[i, i] = g[j,j] = c</span>
            <span class="c1"># g[j, i] = -s; g[i, j] = s</span>
            <span class="c1"># m = np.dot(g.T, np.dot(m, g))</span>
            <span class="n">mv</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">drot</span><span class="p">(</span><span class="n">mv</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
                 <span class="n">offx</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">incx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offy</span><span class="o">=</span><span class="n">j</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">incy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">drot</span><span class="p">(</span><span class="n">mv</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
                 <span class="n">offx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">incx</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">offy</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">incy</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
                 <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-13</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random correlation matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigs : 1d ndarray</span>
<span class="sd">            Eigenvalues of correlation matrix</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            Tolerance for input parameter checks</span>
<span class="sd">        diag_tol : float, optional</span>
<span class="sd">            Tolerance for deviation of the diagonal of the resulting</span>
<span class="sd">            matrix. Default: 1e-7</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            Floating point error prevented generating a valid correlation</span>
<span class="sd">            matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random size N-dimensional matrices, dimension (size, dim, dim),</span>
<span class="sd">            each having eigenvalues eigs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">ortho_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">eigs</span><span class="p">)),</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Set the trace of m</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_corr</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>  <span class="c1"># Carefully rotate to unit diagonal</span>

        <span class="c1"># Check diagonal</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">diag_tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to generate a valid correlation matrix&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span>


<span class="n">random_correlation</span> <span class="o">=</span> <span class="n">random_correlation_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">random_correlation_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-13</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen random correlation matrix distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigs : 1d ndarray</span>
<span class="sd">            Eigenvalues of correlation matrix</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            Tolerance for input parameter checks</span>
<span class="sd">        diag_tol : float, optional</span>
<span class="sd">            Tolerance for deviation of the diagonal of the resulting</span>
<span class="sd">            matrix. Default: 1e-7</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            Floating point error prevented generating a valid correlation</span>
<span class="sd">            matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random size N-dimensional matrices, dimension (size, dim, dim),</span>
<span class="sd">            each having eigenvalues eigs.</span>
<span class="sd">        &quot;&quot;&quot;</span> <span class="c1"># numpy/numpydoc#87  # noqa: E501</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">random_correlation_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag_tol</span> <span class="o">=</span> <span class="n">diag_tol</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                              <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diag_tol</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">unitary_group_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A matrix-valued U(N) random variable.</span>

<span class="sd">    Return a random unitary matrix.</span>

<span class="sd">    The `dim` keyword specifies the dimension N.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    rvs(dim=None, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from U(N).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : scalar</span>
<span class="sd">        Dimension of matrices.</span>
<span class="sd">    seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is similar to `ortho_group`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Mezzadri, &quot;How to generate random matrices from the classical</span>
<span class="sd">           compact groups&quot;, :arXiv:`math-ph/0609050v2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import unitary_group</span>
<span class="sd">    &gt;&gt;&gt; x = unitary_group.rvs(3)</span>

<span class="sd">    &gt;&gt;&gt; np.dot(x, x.conj().T)</span>
<span class="sd">    array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],</span>
<span class="sd">           [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],</span>
<span class="sd">           [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])  # may vary</span>

<span class="sd">    This generates one random matrix from U(3). The dot product confirms that</span>
<span class="sd">    it is unitary up to machine precision.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the `dim`</span>
<span class="sd">    parameter, return a &quot;frozen&quot; unitary_group random variable:</span>

<span class="sd">    &gt;&gt;&gt; rv = unitary_group(5)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ortho_group</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen (U(N)) n-dimensional unitary matrix distribution.</span>

<span class="sd">        See `unitary_group_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unitary_group_frozen</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension N must be specified; it cannot be inferred.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension of rotation must be specified,&quot;</span>
                             <span class="s2">&quot;and must be a scalar nonnegative integer.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from U(N).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : integer</span>
<span class="sd">            Dimension of space (N).</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random size N-dimensional matrices, dimension (size, dim, dim)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span> <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="o">+</span>
                            <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)))</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="c1"># The last two dimensions are the rows and columns of R matrices.</span>
        <span class="c1"># Extract the diagonals. Note that this eliminates a dimension.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Add back a dimension for proper broadcasting: we&#39;re dividing</span>
        <span class="c1"># each row of each R matrix by the diagonal of the R matrix.</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># to broadcast properly</span>
        <span class="k">return</span> <span class="n">q</span>


<span class="n">unitary_group</span> <span class="o">=</span> <span class="n">unitary_group_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">unitary_group_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen (U(N)) n-dimensional unitary matrix distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : scalar</span>
<span class="sd">            Dimension of matrices</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import unitary_group</span>
<span class="sd">        &gt;&gt;&gt; x = unitary_group(3)</span>
<span class="sd">        &gt;&gt;&gt; x.rvs()</span>

<span class="sd">        &quot;&quot;&quot;</span> <span class="c1"># numpy/numpydoc#87  # noqa: E501</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">unitary_group_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="n">_mvt_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">loc : array_like, optional</span>
<span class="s2">    Location of the distribution. (default ``0``)</span>
<span class="s2">shape : array_like, optional</span>
<span class="s2">    Positive semidefinite matrix of the distribution. (default ``1``)</span>
<span class="s2">df : float, optional</span>
<span class="s2">    Degrees of freedom of the distribution; must be greater than zero.</span>
<span class="s2">    If ``np.inf`` then results are multivariate normal. The default is ``1``.</span>
<span class="s2">allow_singular : bool, optional</span>
<span class="s2">    Whether to allow a singular matrix. (default ``False``)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mvt_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Setting the parameter `loc` to ``None`` is equivalent to having `loc`</span>
<span class="s2">be the zero-vector. The parameter `shape` can be a scalar, in which case</span>
<span class="s2">the shape matrix is the identity times that value, a vector of</span>
<span class="s2">diagonal entries for the shape matrix, or a two-dimensional array_like.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mvt_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">mvt_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_mvt_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_mvt_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_mvt_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mvt_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">mvt_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_mvt_doc_default_callparams&#39;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="s1">&#39;_mvt_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mvt_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_t_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A multivariate t-distributed random variable.</span>

<span class="sd">    The `loc` parameter specifies the location. The `shape` parameter specifies</span>
<span class="sd">    the positive semidefinite shape matrix. The `df` parameter specifies the</span>
<span class="sd">    degrees of freedom.</span>

<span class="sd">    In addition to calling the methods below, the object itself may be called</span>
<span class="sd">    as a function to fix the location, shape matrix, and degrees of freedom</span>
<span class="sd">    parameters, returning a &quot;frozen&quot; multivariate t-distribution random.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, loc=None, shape=1, df=1, allow_singular=False)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, loc=None, shape=1, df=1, allow_singular=False)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    cdf(x, loc=None, shape=1, df=1, allow_singular=False, *,</span>
<span class="sd">        maxpts=None, lower_limit=None, random_state=None)</span>
<span class="sd">        Cumulative distribution function.</span>
<span class="sd">    rvs(loc=None, shape=1, df=1, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a multivariate t-distribution.</span>
<span class="sd">    entropy(loc=None, shape=1, df=1)</span>
<span class="sd">        Differential entropy of a multivariate t-distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_mvt_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_mvt_doc_callparams_note)s</span>
<span class="sd">    The matrix `shape` must be a (symmetric) positive semidefinite matrix. The</span>
<span class="sd">    determinant and inverse of `shape` are computed as the pseudo-determinant</span>
<span class="sd">    and pseudo-inverse, respectively, so that `shape` does not need to have</span>
<span class="sd">    full rank.</span>

<span class="sd">    The probability density function for `multivariate_t` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = \frac{\Gamma((\nu + p)/2)}{\Gamma(\nu/2)\nu^{p/2}\pi^{p/2}|\Sigma|^{1/2}}</span>
<span class="sd">               \left[1 + \frac{1}{\nu} (\mathbf{x} - \boldsymbol{\mu})^{\top}</span>
<span class="sd">               \boldsymbol{\Sigma}^{-1}</span>
<span class="sd">               (\mathbf{x} - \boldsymbol{\mu}) \right]^{-(\nu + p)/2},</span>

<span class="sd">    where :math:`p` is the dimension of :math:`\mathbf{x}`,</span>
<span class="sd">    :math:`\boldsymbol{\mu}` is the :math:`p`-dimensional location,</span>
<span class="sd">    :math:`\boldsymbol{\Sigma}` the :math:`p \times p`-dimensional shape</span>
<span class="sd">    matrix, and :math:`\nu` is the degrees of freedom.</span>

<span class="sd">    .. versionadded:: 1.6.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Arellano-Valle et al. &quot;Shannon Entropy and Mutual Information for</span>
<span class="sd">           Multivariate Skew-Elliptical Distributions&quot;. Scandinavian Journal</span>
<span class="sd">           of Statistics. Vol. 40, issue 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The object may be called (as a function) to fix the `loc`, `shape`,</span>
<span class="sd">    `df`, and `allow_singular` parameters, returning a &quot;frozen&quot;</span>
<span class="sd">    multivariate_t random variable:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">    &gt;&gt;&gt; rv = multivariate_t([1.0, -0.5], [[2.1, 0.3], [0.3, 1.5]], df=2)</span>
<span class="sd">    &gt;&gt;&gt; # Frozen object with the same methods but holding the given location,</span>
<span class="sd">    &gt;&gt;&gt; # scale, and degrees of freedom fixed.</span>

<span class="sd">    Create a contour plot of the PDF.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x, y = np.mgrid[-1:3:.01, -2:1.5:.01]</span>
<span class="sd">    &gt;&gt;&gt; pos = np.dstack((x, y))</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_aspect(&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.contourf(x, y, rv.pdf(pos))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a multivariate t-distributed random variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seed : Random state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mvt_docdict_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multivariate t-distribution.</span>

<span class="sd">        See `multivariate_t_frozen` for parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multivariate_normal_frozen</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                              <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">,</span>
                                              <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">multivariate_t_frozen</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                                     <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate t-distribution probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the probability density function.</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : Probability density function evaluated at `x`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">        &gt;&gt;&gt; x = [0.4, 5]</span>
<span class="sd">        &gt;&gt;&gt; loc = [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; shape = [[1, 0.1], [0.1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; df = 7</span>
<span class="sd">        &gt;&gt;&gt; multivariate_t.pdf(x, loc, shape, df)</span>
<span class="sd">        0.00075713</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">shape_info</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">)</span>
        <span class="n">logpdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
                              <span class="n">dim</span><span class="p">,</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logpdf</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the multivariate t-distribution probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the log of the probability density</span>
<span class="sd">            function.</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : Log of the probability density function evaluated at `x`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">        &gt;&gt;&gt; x = [0.4, 5]</span>
<span class="sd">        &gt;&gt;&gt; loc = [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; shape = [[1, 0.1], [0.1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; df = 7</span>
<span class="sd">        &gt;&gt;&gt; multivariate_t.logpdf(x, loc, shape, df)</span>
<span class="sd">        -7.1859802</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pdf : Probability density function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">shape_info</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">log_pdet</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span>
                            <span class="n">shape_info</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_pdet</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Utility method `pdf`, `logpdf` for parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability density</span>
<span class="sd">            function.</span>
<span class="sd">        loc : ndarray</span>
<span class="sd">            Location of the distribution.</span>
<span class="sd">        prec_U : ndarray</span>
<span class="sd">            A decomposition such that `np.dot(prec_U, prec_U.T)` is the inverse</span>
<span class="sd">            of the shape matrix.</span>
<span class="sd">        log_pdet : float</span>
<span class="sd">            Logarithm of the determinant of the shape matrix.</span>
<span class="sd">        df : float</span>
<span class="sd">            Degrees of freedom of the distribution.</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of the quantiles x.</span>
<span class="sd">        rank : int</span>
<span class="sd">            Rank of the shape matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be called</span>
<span class="sd">        directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_pdet</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">loc</span>
        <span class="n">maha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span> <span class="o">+</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">gammaln</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">dim</span><span class="o">/</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">log_pdet</span>
        <span class="n">E</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">df</span><span class="p">)</span> <span class="o">*</span> <span class="n">maha</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span> <span class="o">-</span> <span class="n">D</span> <span class="o">+</span> <span class="n">E</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># All of this -  random state validation, maxpts, apply_along_axis,</span>
        <span class="c1"># etc. needs to go in this private method unless we want</span>
        <span class="c1"># frozen distribution&#39;s `cdf` method to duplicate it or call `cdf`,</span>
        <span class="c1"># which would require re-processing parameters</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">maxpts</span><span class="p">:</span>
            <span class="n">maxpts</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">dim</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">lower_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">lower_limit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lower_limit</span><span class="p">)</span>

        <span class="c1"># remove the mean</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">lower_limit</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">,</span> <span class="n">lower_limit</span> <span class="o">-</span> <span class="n">loc</span>

        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">)</span>
        <span class="n">i_swap</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i_swap</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># odd # of swaps -&gt; negative</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i_swap</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i_swap</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i_swap</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i_swap</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func1d</span><span class="p">(</span><span class="n">limits</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
            <span class="k">return</span> <span class="n">_qmvt</span><span class="p">(</span><span class="n">maxpts</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rng</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span> <span class="o">*</span> <span class="n">signs</span>
        <span class="c1"># Fixing the output shape for existing distributions is a separate</span>
        <span class="c1"># issue. For now, let&#39;s keep this consistent with pdf.</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate t-distribution cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the cumulative distribution function.</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>
<span class="sd">        maxpts : int, optional</span>
<span class="sd">            Maximum number of points to use for integration. The default is</span>
<span class="sd">            1000 times the number of dimensions.</span>
<span class="sd">        lower_limit : array_like, optional</span>
<span class="sd">            Lower limit of integration of the cumulative distribution function.</span>
<span class="sd">            Default is negative infinity. Must be broadcastable with `x`.</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray or scalar</span>
<span class="sd">            Cumulative distribution function evaluated at `x`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">        &gt;&gt;&gt; x = [0.4, 5]</span>
<span class="sd">        &gt;&gt;&gt; loc = [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; shape = [[1, 0.1], [0.1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; df = 7</span>
<span class="sd">        &gt;&gt;&gt; multivariate_t.cdf(x, loc, shape, df)</span>
<span class="sd">        0.64798491</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">)</span><span class="o">.</span><span class="n">_M</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">maxpts</span><span class="p">,</span>
                         <span class="n">lower_limit</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multivariate_normal</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">entropy</span><span class="p">()</span>

        <span class="n">shape_info</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape_term</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">shape_info</span><span class="o">.</span><span class="n">log_pdet</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">regular</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
            <span class="n">halfsum</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="n">df</span><span class="p">)</span>
            <span class="n">half_df</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="o">-</span><span class="n">gammaln</span><span class="p">(</span><span class="n">halfsum</span><span class="p">)</span> <span class="o">+</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">half_df</span><span class="p">)</span>
                <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="n">halfsum</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">psi</span><span class="p">(</span><span class="n">halfsum</span><span class="p">)</span> <span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">half_df</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">shape_term</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">asymptotic</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
            <span class="c1"># Formula from Wolfram Alpha:</span>
            <span class="c1"># &quot;asymptotic expansion -gammaln((m+d)/2) + gammaln(d/2) + (m*log(d*pi))/2</span>
            <span class="c1">#  + ((m+d)/2) * (digamma((m+d)/2) - digamma(d/2))&quot;</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">dim</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">_entropy</span><span class="p">()</span> <span class="o">+</span> <span class="n">dim</span> <span class="o">/</span> <span class="n">df</span>
                <span class="o">-</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="o">**-</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mi">4</span>
                <span class="o">+</span> <span class="n">dim</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="o">**-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">6</span>
                <span class="o">+</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="n">dim</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">dim</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="o">**-</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mi">24</span>
                <span class="o">+</span> <span class="n">dim</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">dim</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">dim</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="o">**-</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">30</span>
                <span class="o">+</span> <span class="n">shape_term</span>
            <span class="p">)[()]</span>

        <span class="c1"># preserves ~12 digits accuracy up to at least `dim=1e5`. See gh-18465.</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xpx</span><span class="o">.</span><span class="n">apply_where</span><span class="p">(</span><span class="n">df</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">asymptotic</span><span class="p">,</span> <span class="n">regular</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the differential entropy of a multivariate</span>
<span class="sd">        t-distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : float</span>
<span class="sd">            Differential entropy</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a multivariate t-distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `P`), where `P` is the</span>
<span class="sd">            dimension of the random variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">        &gt;&gt;&gt; x = [0.4, 5]</span>
<span class="sd">        &gt;&gt;&gt; loc = [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; shape = [[1, 0.1], [0.1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; df = 7</span>
<span class="sd">        &gt;&gt;&gt; multivariate_t.rvs(loc, shape, df)</span>
<span class="sd">        array([[0.93477495, 3.00408716]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For implementation details, see equation (3):</span>
        <span class="c1">#</span>
        <span class="c1">#    Hofert, &quot;On Sampling from the Multivariatet Distribution&quot;, 2013</span>
        <span class="c1">#     http://rjournal.github.io/archive/2013-2/hofert.pdf</span>
        <span class="c1">#</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">df</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust quantiles array so that last axis labels the components of</span>
<span class="sd">        each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer dimensionality from location array and shape matrix, handle</span>
<span class="sd">        defaults, and ensure compatible dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">loc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Array &#39;loc&#39; must be a vector of length </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">rows</span> <span class="o">!=</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Array &#39;cov&#39; must be square if it is two dimensional,&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; but cov.shape = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Dimension mismatch: array &#39;cov&#39; is of shape </span><span class="si">%s</span><span class="s2">,&quot;</span>
                       <span class="s2">&quot; but &#39;loc&#39; is a vector of length </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Array &#39;cov&#39; must be at most two-dimensional, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but cov.ndim = </span><span class="si">{</span><span class="n">shape</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Process degrees of freedom.</span>
        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;df&#39; must be greater than zero.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;df&#39; is &#39;nan&#39; but must be greater than zero or &#39;np.inf&#39;.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_t_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multivariate t distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_mvt_doc_default_callparams)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_t</span>
<span class="sd">        &gt;&gt;&gt; loc = np.zeros(3)</span>
<span class="sd">        &gt;&gt;&gt; shape = np.eye(3)</span>
<span class="sd">        &gt;&gt;&gt; df = 10</span>
<span class="sd">        &gt;&gt;&gt; dist = multivariate_t(loc, shape, df)</span>
<span class="sd">        &gt;&gt;&gt; dist.rvs()</span>
<span class="sd">        array([[ 0.81412036, -1.53612361,  0.42199647]])</span>
<span class="sd">        &gt;&gt;&gt; dist.pdf([1, 1, 1])</span>
<span class="sd">        array([0.01237803])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">multivariate_t_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">dim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_info</span> <span class="o">=</span> <span class="n">_PSD</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">allow_singular</span><span class="o">=</span><span class="n">allow_singular</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_info</span><span class="o">.</span><span class="n">U</span>
        <span class="n">log_pdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_info</span><span class="o">.</span><span class="n">log_pdet</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">log_pdet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">shape_info</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">maxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                               <span class="n">maxpts</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span>
                              <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                              <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                              <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="n">multivariate_t</span> <span class="o">=</span> <span class="n">multivariate_t_gen</span><span class="p">()</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># multivariate_t_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">,</span> <span class="s1">&#39;entropy&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">multivariate_t_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">multivariate_t_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                             <span class="n">mvt_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mvt_docdict_params</span><span class="p">)</span>


<span class="n">_mhg_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">m : array_like</span>
<span class="s2">    The number of each type of object in the population.</span>
<span class="s2">    That is, :math:`m[i]` is the number of objects of</span>
<span class="s2">    type :math:`i`.</span>
<span class="s2">n : array_like</span>
<span class="s2">    The number of samples taken from the population.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mhg_doc_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">`m` must be an array of positive integers. If the quantile</span>
<span class="s2">:math:`i` contains values out of the range :math:`[0, m_i]`</span>
<span class="s2">where :math:`m_i` is the number of objects of type :math:`i`</span>
<span class="s2">in the population or if the parameters are inconsistent with one</span>
<span class="s2">another (e.g. ``x.sum() != n``), methods return the appropriate</span>
<span class="s2">value (e.g. ``0`` for ``pmf``). If `m` or `n` contain negative</span>
<span class="s2">values, the result will contain ``nan`` there.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_mhg_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_mhg_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">mhg_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_mhg_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mhg_doc_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">mhg_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_mhg_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_mhg_doc_frozen_callparams_note</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_hypergeom_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A multivariate hypergeometric random variable.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pmf(x, m, n)</span>
<span class="sd">        Probability mass function.</span>
<span class="sd">    logpmf(x, m, n)</span>
<span class="sd">        Log of the probability mass function.</span>
<span class="sd">    rvs(m, n, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a multivariate hypergeometric</span>
<span class="sd">        distribution.</span>
<span class="sd">    mean(m, n)</span>
<span class="sd">        Mean of the multivariate hypergeometric distribution.</span>
<span class="sd">    var(m, n)</span>
<span class="sd">        Variance of the multivariate hypergeometric distribution.</span>
<span class="sd">    cov(m, n)</span>
<span class="sd">        Compute the covariance matrix of the multivariate</span>
<span class="sd">        hypergeometric distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_callparams_note)s</span>

<span class="sd">    The probability mass function for `multivariate_hypergeom` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        P(X_1 = x_1, X_2 = x_2, \ldots, X_k = x_k) = \frac{\binom{m_1}{x_1}</span>
<span class="sd">        \binom{m_2}{x_2} \cdots \binom{m_k}{x_k}}{\binom{M}{n}}, \\ \quad</span>
<span class="sd">        (x_1, x_2, \ldots, x_k) \in \mathbb{N}^k \text{ with }</span>
<span class="sd">        \sum_{i=1}^k x_i = n</span>

<span class="sd">    where :math:`m_i` are the number of objects of type :math:`i`, :math:`M`</span>
<span class="sd">    is the total number of objects in the population (sum of all the</span>
<span class="sd">    :math:`m_i`), and :math:`n` is the size of the sample to be taken</span>
<span class="sd">    from the population.</span>

<span class="sd">    .. versionadded:: 1.6.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To evaluate the probability mass function of the multivariate</span>
<span class="sd">    hypergeometric distribution, with a dichotomous population of size</span>
<span class="sd">    :math:`10` and :math:`20`, at a sample of size :math:`12` with</span>
<span class="sd">    :math:`8` objects of the first type and :math:`4` objects of the</span>
<span class="sd">    second type, use:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.stats import multivariate_hypergeom</span>
<span class="sd">    &gt;&gt;&gt; multivariate_hypergeom.pmf(x=[8, 4], m=[10, 20], n=12)</span>
<span class="sd">    0.0025207176631464523</span>

<span class="sd">    The `multivariate_hypergeom` distribution is identical to the</span>
<span class="sd">    corresponding `hypergeom` distribution (tiny numerical differences</span>
<span class="sd">    notwithstanding) when only two types (good and bad) of objects</span>
<span class="sd">    are present in the population as in the example above. Consider</span>
<span class="sd">    another example for a comparison with the hypergeometric distribution:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.stats import hypergeom</span>
<span class="sd">    &gt;&gt;&gt; multivariate_hypergeom.pmf(x=[3, 1], m=[10, 5], n=4)</span>
<span class="sd">    0.4395604395604395</span>
<span class="sd">    &gt;&gt;&gt; hypergeom.pmf(k=3, M=15, n=4, N=10)</span>
<span class="sd">    0.43956043956044005</span>

<span class="sd">    The functions ``pmf``, ``logpmf``, ``mean``, ``var``, ``cov``, and ``rvs``</span>
<span class="sd">    support broadcasting, under the convention that the vector parameters</span>
<span class="sd">    (``x``, ``m``, and ``n``) are interpreted as if each row along the last</span>
<span class="sd">    axis is a single object. For instance, we can combine the previous two</span>
<span class="sd">    calls to `multivariate_hypergeom` as</span>

<span class="sd">    &gt;&gt;&gt; multivariate_hypergeom.pmf(x=[[8, 4], [3, 1]], m=[[10, 20], [10, 5]],</span>
<span class="sd">    ...                            n=[12, 4])</span>
<span class="sd">    array([0.00252072, 0.43956044])</span>

<span class="sd">    This broadcasting also works for ``cov``, where the output objects are</span>
<span class="sd">    square matrices of size ``m.shape[-1]``. For example:</span>

<span class="sd">    &gt;&gt;&gt; multivariate_hypergeom.cov(m=[[7, 9], [10, 15]], n=[8, 12])</span>
<span class="sd">    array([[[ 1.05, -1.05],</span>
<span class="sd">            [-1.05,  1.05]],</span>
<span class="sd">           [[ 1.56, -1.56],</span>
<span class="sd">            [-1.56,  1.56]]])</span>

<span class="sd">    That is, ``result[0]`` is equal to</span>
<span class="sd">    ``multivariate_hypergeom.cov(m=[7, 9], n=8)`` and ``result[1]`` is equal</span>
<span class="sd">    to ``multivariate_hypergeom.cov(m=[10, 15], n=12)``.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the `m`</span>
<span class="sd">    and `n` parameters, returning a &quot;frozen&quot; multivariate hypergeometric</span>
<span class="sd">    random variable.</span>

<span class="sd">    &gt;&gt;&gt; rv = multivariate_hypergeom(m=[10, 20], n=12)</span>
<span class="sd">    &gt;&gt;&gt; rv.pmf(x=[8, 4])</span>
<span class="sd">    0.0025207176631464523</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.stats.hypergeom : The hypergeometric distribution.</span>
<span class="sd">    scipy.stats.multinomial : The multinomial distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] The Multivariate Hypergeometric Distribution,</span>
<span class="sd">           http://www.randomservices.org/random/urn/MultiHypergeometric.html</span>
<span class="sd">    .. [2] Thomas J. Sargent and John Stachurski, 2020,</span>
<span class="sd">           Multivariate Hypergeometric Distribution</span>
<span class="sd">           https://python.quantecon.org/multi_hyper.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mhg_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen multivariate_hypergeom distribution.</span>

<span class="sd">        See `multivariate_hypergeom_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">multivariate_hypergeom_frozen</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;m&#39; must an array of integers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;n&#39; must an array of integers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;m&#39; must be an array with&quot;</span>
                             <span class="s2">&quot; at least one dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">mcond</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="n">M</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">ncond</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mcond</span><span class="p">,</span> <span class="n">ncond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mcond</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">ncond</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;x&#39; must an array of integers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;x&#39; must be an array with&quot;</span>
                             <span class="s2">&quot; at least one dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of each quantile must be size of &#39;m&#39;: &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but expected </span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">xcond</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xcond</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xcond</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_checkresult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">bad_value</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_value</span>
        <span class="k">elif</span> <span class="n">cond</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bad_value</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mxcond</span><span class="p">,</span> <span class="n">ncond</span><span class="p">):</span>
        <span class="c1"># This equation of the pmf comes from the relation,</span>
        <span class="c1"># n combine r = beta(n+1, 1) / beta(r+1, n-r+1)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="o">~</span><span class="n">mxcond</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">mxcond</span><span class="p">]</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">~</span><span class="n">ncond</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="o">~</span><span class="n">ncond</span><span class="p">]</span>
        <span class="n">num</span><span class="p">[</span><span class="o">~</span><span class="n">mxcond</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">betaln</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">betaln</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">den</span><span class="p">[</span><span class="o">~</span><span class="n">ncond</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">betaln</span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">betaln</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">num</span><span class="p">[</span><span class="n">mxcond</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">den</span><span class="p">[</span><span class="n">ncond</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">-</span> <span class="n">den</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the multivariate hypergeometric probability mass function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpmf : ndarray or scalar</span>
<span class="sd">            Log of the probability mass function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mcond</span><span class="p">,</span> <span class="n">ncond</span><span class="p">,</span> <span class="n">mncond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xcond</span><span class="p">,</span>
         <span class="n">xcond_reduced</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">mxcond</span> <span class="o">=</span> <span class="n">mcond</span> <span class="o">|</span> <span class="n">xcond</span>
        <span class="n">ncond</span> <span class="o">=</span> <span class="n">ncond</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mxcond</span><span class="p">,</span> <span class="n">ncond</span><span class="p">)</span>

        <span class="c1"># replace values for which x was out of the domain; broadcast</span>
        <span class="c1"># xcond to the right shape</span>
        <span class="n">xcond_</span> <span class="o">=</span> <span class="n">xcond_reduced</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mncond</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">xcond_</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="c1"># replace values bad for n or m; broadcast</span>
        <span class="c1"># mncond to the right shape</span>
        <span class="n">mncond_</span> <span class="o">=</span> <span class="n">mncond</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xcond_reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mncond_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multivariate hypergeometric probability mass function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pmf : ndarray or scalar</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the multivariate hypergeometric distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : array_like or scalar</span>
<span class="sd">            The mean of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mncond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mncond</span> <span class="o">=</span> <span class="p">(</span><span class="n">mncond</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">|</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mncond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the multivariate hypergeometric distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            The variances of the components of the distribution.  This is</span>
<span class="sd">            the diagonal of the covariance matrix of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mncond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="o">/</span><span class="n">M</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="n">M</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mncond</span> <span class="o">=</span> <span class="p">(</span><span class="n">mncond</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">|</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">mncond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Covariance matrix of the multivariate hypergeometric distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cov : array_like</span>
<span class="sd">            The covariance matrix of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># see [1]_ for the formula and [2]_ for implementation</span>
        <span class="c1"># cov( x_i,x_j ) = -n * (M-n)/(M-1) * (K_i*K_j) / (M**2)</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mncond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...j-&gt;...ij&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># check for empty arrays</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># diagonal entries need to be computed differently</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mncond</span> <span class="o">=</span> <span class="p">(</span><span class="n">mncond</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">|</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkresult</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">mncond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a multivariate hypergeometric distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>
<span class="sd">        size : integer or iterable of integers, optional</span>
<span class="sd">            Number of samples to draw. Default is ``None``, in which case a</span>
<span class="sd">            single variate is returned as an array with shape ``m.shape``.</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : array_like</span>
<span class="sd">            Random variates of shape ``size`` or ``m.shape``</span>
<span class="sd">            (if ``size=None``).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        Also note that NumPy&#39;s `multivariate_hypergeometric` sampler is not</span>
<span class="sd">        used as it doesn&#39;t support broadcasting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">M</span>

        <span class="c1"># This sampler has been taken from numpy gh-13794</span>
        <span class="c1"># https://github.com/numpy/numpy/pull/13794</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
            <span class="n">n0mask</span> <span class="o">=</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">rvs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">n0mask</span> <span class="o">*</span>
                           <span class="n">random_state</span><span class="o">.</span><span class="n">hypergeometric</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span>
                                                       <span class="n">rem</span> <span class="o">+</span> <span class="n">n0mask</span><span class="p">,</span>
                                                       <span class="n">n</span> <span class="o">+</span> <span class="n">n0mask</span><span class="p">,</span>
                                                       <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">))</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">rvs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">rvs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>

        <span class="k">return</span> <span class="n">rvs</span>


<span class="n">multivariate_hypergeom</span> <span class="o">=</span> <span class="n">multivariate_hypergeom_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">multivariate_hypergeom_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">multivariate_hypergeom_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">mcond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncond</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">mncond</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># monkey patch self._dist</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mcond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncond</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mncond</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span> <span class="o">=</span> <span class="n">_process_parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                              <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                              <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># multivariate_hypergeom and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpmf&#39;</span><span class="p">,</span> <span class="s1">&#39;pmf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">multivariate_hypergeom_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">multivariate_hypergeom_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mhg_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                      <span class="n">mhg_docdict_params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">random_table_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Contingency tables from independent samples with fixed marginal sums.</span>

<span class="sd">    This is the distribution of random tables with given row and column vector</span>
<span class="sd">    sums. This distribution represents the set of random tables under the null</span>
<span class="sd">    hypothesis that rows and columns are independent. It is used in hypothesis</span>
<span class="sd">    tests of independence.</span>

<span class="sd">    Because of assumed independence, the expected frequency of each table</span>
<span class="sd">    element can be computed from the row and column sums, so that the</span>
<span class="sd">    distribution is completely determined by these two vectors.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    logpmf(x)</span>
<span class="sd">        Log-probability of table `x` to occur in the distribution.</span>
<span class="sd">    pmf(x)</span>
<span class="sd">        Probability of table `x` to occur in the distribution.</span>
<span class="sd">    mean(row, col)</span>
<span class="sd">        Mean table.</span>
<span class="sd">    rvs(row, col, size=None, method=None, random_state=None)</span>
<span class="sd">        Draw random tables with given row and column vector sums.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_doc_row_col)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_row_col_note)s</span>

<span class="sd">    Random elements from the distribution are generated either with Boyett&#39;s</span>
<span class="sd">    [1]_ or Patefield&#39;s algorithm [2]_. Boyett&#39;s algorithm has</span>
<span class="sd">    O(N) time and space complexity, where N is the total sum of entries in the</span>
<span class="sd">    table. Patefield&#39;s algorithm has O(K x log(N)) time complexity, where K is</span>
<span class="sd">    the number of cells in the table and requires only a small constant work</span>
<span class="sd">    space. By default, the `rvs` method selects the fastest algorithm based on</span>
<span class="sd">    the input, but you can specify the algorithm with the keyword `method`.</span>
<span class="sd">    Allowed values are &quot;boyett&quot; and &quot;patefield&quot;.</span>

<span class="sd">    .. versionadded:: 1.10.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import random_table</span>

<span class="sd">    &gt;&gt;&gt; row = [1, 5]</span>
<span class="sd">    &gt;&gt;&gt; col = [2, 3, 1]</span>
<span class="sd">    &gt;&gt;&gt; random_table.mean(row, col)</span>
<span class="sd">    array([[0.33333333, 0.5       , 0.16666667],</span>
<span class="sd">           [1.66666667, 2.5       , 0.83333333]])</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the row</span>
<span class="sd">    and column vector sums, returning a &quot;frozen&quot; distribution.</span>

<span class="sd">    &gt;&gt;&gt; dist = random_table(row, col)</span>
<span class="sd">    &gt;&gt;&gt; dist.rvs(random_state=123)</span>
<span class="sd">    array([[1, 0, 0],</span>
<span class="sd">           [1, 3, 1]])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. Boyett, AS 144 Appl. Statist. 28 (1979) 329-332</span>
<span class="sd">    .. [2] W.M. Patefield, AS 159 Appl. Statist. 30 (1981) 91-97</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen distribution of tables with given marginals.</span>

<span class="sd">        See `random_table_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random_table_frozen</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log-probability of table to occur in the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_x)s</span>
<span class="sd">        %(_doc_row_col)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpmf : ndarray or scalar</span>
<span class="sd">            Log of the probability mass function evaluated at `x`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_row_col_note)s</span>

<span class="sd">        If row and column marginals of `x` do not match `row` and `col`,</span>
<span class="sd">        negative infinity is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import random_table</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; x = [[1, 5, 1], [2, 3, 1]]</span>
<span class="sd">        &gt;&gt;&gt; row = np.sum(x, axis=1)</span>
<span class="sd">        &gt;&gt;&gt; col = np.sum(x, axis=0)</span>
<span class="sd">        &gt;&gt;&gt; random_table.logpmf(x, row, col)</span>
<span class="sd">        -1.6306401200847027</span>

<span class="sd">        Alternatively, the object may be called (as a function) to fix the row</span>
<span class="sd">        and column vector sums, returning a &quot;frozen&quot; distribution.</span>

<span class="sd">        &gt;&gt;&gt; d = random_table(row, col)</span>
<span class="sd">        &gt;&gt;&gt; d.logpmf(x)</span>
<span class="sd">        -1.6306401200847027</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must be at least two-dimensional&quot;</span><span class="p">)</span>

        <span class="n">dtype_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype_is_int</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must contain only integral values&quot;</span><span class="p">)</span>

        <span class="c1"># x does not contain NaN if we arrive here</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must contain only non-negative values&quot;</span><span class="p">)</span>

        <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of `x` must agree with `row`&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of `x` must agree with `col`&quot;</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">r2</span> <span class="o">==</span> <span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">c2</span> <span class="o">==</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">lnfac</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">res</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lnfac</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lnfac</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                     <span class="o">-</span> <span class="n">lnfac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lnfac</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">res</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Probability of table to occur in the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_x)s</span>
<span class="sd">        %(_doc_row_col)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pmf : ndarray or scalar</span>
<span class="sd">            Probability mass function evaluated at `x`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_row_col_note)s</span>

<span class="sd">        If row and column marginals of `x` do not match `row` and `col`,</span>
<span class="sd">        zero is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import random_table</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; x = [[1, 5, 1], [2, 3, 1]]</span>
<span class="sd">        &gt;&gt;&gt; row = np.sum(x, axis=1)</span>
<span class="sd">        &gt;&gt;&gt; col = np.sum(x, axis=0)</span>
<span class="sd">        &gt;&gt;&gt; random_table.pmf(x, row, col)</span>
<span class="sd">        0.19580419580419592</span>

<span class="sd">        Alternatively, the object may be called (as a function) to fix the row</span>
<span class="sd">        and column vector sums, returning a &quot;frozen&quot; distribution.</span>

<span class="sd">        &gt;&gt;&gt; d = random_table(row, col)</span>
<span class="sd">        &gt;&gt;&gt; d.pmf(x)</span>
<span class="sd">        0.19580419580419592</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of distribution of conditional tables.</span>
<span class="sd">        %(_doc_mean_params)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: ndarray</span>
<span class="sd">            Mean of the distribution.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_row_col_note)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import random_table</span>

<span class="sd">        &gt;&gt;&gt; row = [1, 5]</span>
<span class="sd">        &gt;&gt;&gt; col = [2, 3, 1]</span>
<span class="sd">        &gt;&gt;&gt; random_table.mean(row, col)</span>
<span class="sd">        array([[0.33333333, 0.5       , 0.16666667],</span>
<span class="sd">               [1.66666667, 2.5       , 0.83333333]])</span>

<span class="sd">        Alternatively, the object may be called (as a function) to fix the row</span>
<span class="sd">        and column vector sums, returning a &quot;frozen&quot; distribution.</span>

<span class="sd">        &gt;&gt;&gt; d = random_table(row, col)</span>
<span class="sd">        &gt;&gt;&gt; d.mean()</span>
<span class="sd">        array([[0.33333333, 0.5       , 0.16666667],</span>
<span class="sd">               [1.66666667, 2.5       , 0.83333333]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random tables with fixed column and row marginals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_row_col)s</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Which method to use, &quot;boyett&quot; or &quot;patefield&quot;. If None (default),</span>
<span class="sd">            selects the fastest method for this input.</span>
<span class="sd">        %(_doc_random_state)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray</span>
<span class="sd">            Random 2D tables of shape (`size`, `len(row)`, `len(col)`).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_row_col_note)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import random_table</span>

<span class="sd">        &gt;&gt;&gt; row = [1, 5]</span>
<span class="sd">        &gt;&gt;&gt; col = [2, 3, 1]</span>
<span class="sd">        &gt;&gt;&gt; random_table.rvs(row, col, random_state=123)</span>
<span class="sd">        array([[1., 0., 0.],</span>
<span class="sd">               [1., 3., 1.]])</span>

<span class="sd">        Alternatively, the object may be called (as a function) to fix the row</span>
<span class="sd">        and column vector sums, returning a &quot;frozen&quot; distribution.</span>

<span class="sd">        &gt;&gt;&gt; d = random_table(row, col)</span>
<span class="sd">        &gt;&gt;&gt; d.rvs(random_state=123)</span>
<span class="sd">        array([[1., 0., 0.],</span>
<span class="sd">               [1., 3., 1.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">size</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_size_shape</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_rvs_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that row and column vectors are one-dimensional, that they do</span>
<span class="sd">        not contain negative or non-integer entries, and that the sums over</span>
<span class="sd">        both vectors are equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`row` must be one-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`col` must be one-dimensional&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each element of `row` must be non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each element of `col` must be non-negative&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sums over `row` and `col` must be equal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each element of `row` must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each element of `col` must be an integer&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_size_shape</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of samples to be drawn and the shape of the output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`size` must be a non-negative integer or `None`&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">shape</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_rvs_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">known_methods</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kc">None</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rvs_select</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
            <span class="s2">&quot;boyett&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rvs_boyett</span><span class="p">,</span>
            <span class="s2">&quot;patefield&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rvs_patefield</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">known_methods</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; not recognized, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;must be one of </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">known_methods</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs_select</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># benchmarks show that this value is about 1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># number of cells</span>
        <span class="c1"># n + 1 guards against failure if n == 0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rvs_patefield</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rvs_boyett</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs_boyett</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_rcont</span><span class="o">.</span><span class="n">rvs_rcont1</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs_patefield</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_rcont</span><span class="o">.</span><span class="n">rvs_rcont2</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="n">random_table</span> <span class="o">=</span> <span class="n">random_table_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">random_table_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">random_table_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># monkey patch self._dist</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span> <span class="o">=</span> <span class="n">_process_parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># optimisations are possible here</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>


<span class="n">_ctab_doc_row_col</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">row : array_like</span>
<span class="s2">    Sum of table entries in each row.</span>
<span class="s2">col : array_like</span>
<span class="s2">    Sum of table entries in each column.&quot;&quot;&quot;</span>

<span class="n">_ctab_doc_x</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">x : array-like</span>
<span class="s2">   Two-dimensional table of non-negative integers, or a</span>
<span class="s2">   multi-dimensional array with the last two dimensions</span>
<span class="s2">   corresponding with the tables.&quot;&quot;&quot;</span>

<span class="n">_ctab_doc_row_col_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The row and column vectors must be one-dimensional, not empty,</span>
<span class="s2">and each sum up to the same value. They cannot contain negative</span>
<span class="s2">or noninteger entries.&quot;&quot;&quot;</span>

<span class="n">_ctab_doc_mean_params</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="si">{</span><span class="n">_ctab_doc_row_col</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_ctab_doc_row_col_note_frozen</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">_ctab_docdict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;_doc_random_state&quot;</span><span class="p">:</span> <span class="n">_doc_random_state</span><span class="p">,</span>
    <span class="s2">&quot;_doc_row_col&quot;</span><span class="p">:</span> <span class="n">_ctab_doc_row_col</span><span class="p">,</span>
    <span class="s2">&quot;_doc_x&quot;</span><span class="p">:</span> <span class="n">_ctab_doc_x</span><span class="p">,</span>
    <span class="s2">&quot;_doc_mean_params&quot;</span><span class="p">:</span> <span class="n">_ctab_doc_mean_params</span><span class="p">,</span>
    <span class="s2">&quot;_doc_row_col_note&quot;</span><span class="p">:</span> <span class="n">_ctab_doc_row_col_note</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_ctab_docdict_frozen</span> <span class="o">=</span> <span class="n">_ctab_docdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">_ctab_docdict_frozen</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">&quot;_doc_row_col&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_doc_mean_params&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_doc_row_col_note&quot;</span><span class="p">:</span> <span class="n">_ctab_doc_row_col_note_frozen</span><span class="p">,</span>
<span class="p">})</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_docfill</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">docdict</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">template</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">docdict</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># random_table and fill in default strings in class docstrings</span>
<span class="n">_docfill</span><span class="p">(</span><span class="n">random_table_gen</span><span class="p">,</span> <span class="n">_ctab_docdict</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpmf&#39;</span><span class="p">,</span> <span class="s1">&#39;pmf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">random_table_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">random_table_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">_docfill</span><span class="p">(</span><span class="n">method_frozen</span><span class="p">,</span> <span class="n">_ctab_docdict_frozen</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="n">_docfill</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">_ctab_docdict</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">uniform_direction_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A vector-valued uniform direction.</span>

<span class="sd">    Return a random direction (unit vector). The `dim` keyword specifies</span>
<span class="sd">    the dimensionality of the space.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    rvs(dim=None, size=1, random_state=None)</span>
<span class="sd">        Draw random directions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : scalar</span>
<span class="sd">        Dimension of directions.</span>
<span class="sd">    seed : {None, int, `numpy.random.Generator`,</span>
<span class="sd">            `numpy.random.RandomState`}, optional</span>

<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This distribution generates unit vectors uniformly distributed on</span>
<span class="sd">    the surface of a hypersphere. These can be interpreted as random</span>
<span class="sd">    directions.</span>
<span class="sd">    For example, if `dim` is 3, 3D vectors from the surface of :math:`S^2`</span>
<span class="sd">    will be sampled.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Marsaglia, G. (1972). &quot;Choosing a Point from the Surface of a</span>
<span class="sd">           Sphere&quot;. Annals of Mathematical Statistics. 43 (2): 645-646.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import uniform_direction</span>
<span class="sd">    &gt;&gt;&gt; x = uniform_direction.rvs(3)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(x)</span>
<span class="sd">    1.</span>

<span class="sd">    This generates one random direction, a vector on the surface of</span>
<span class="sd">    :math:`S^2`.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to return a frozen</span>
<span class="sd">    distribution with fixed `dim` parameter. Here,</span>
<span class="sd">    we create a `uniform_direction` with ``dim=3`` and draw 5 observations.</span>
<span class="sd">    The samples are then arranged in an array of shape 5x3.</span>

<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; uniform_sphere_dist = uniform_direction(3)</span>
<span class="sd">    &gt;&gt;&gt; unit_vectors = uniform_sphere_dist.rvs(5, random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; unit_vectors</span>
<span class="sd">    array([[ 0.56688642, -0.1332634 , -0.81294566],</span>
<span class="sd">           [-0.427126  , -0.74779278,  0.50830044],</span>
<span class="sd">           [ 0.3793989 ,  0.92346629,  0.05715323],</span>
<span class="sd">           [ 0.36428383, -0.92449076, -0.11231259],</span>
<span class="sd">           [-0.27733285,  0.94410968, -0.17816678]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen n-dimensional uniform direction distribution.</span>

<span class="sd">        See `uniform_direction` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">uniform_direction_frozen</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension N must be specified; it cannot be inferred.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension of vector must be specified, &quot;</span>
                             <span class="s2">&quot;and must be an integer greater than 0.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from S(N-1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : integer</span>
<span class="sd">            Dimension of space (N).</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Given a shape of, for example, (m,n,k), m*n*k samples are</span>
<span class="sd">            generated, and packed in an m-by-n-by-k arrangement.</span>
<span class="sd">            Because each sample is N-dimensional, the output shape</span>
<span class="sd">            is (m,n,k,N). If no shape is specified, a single (N-D)</span>
<span class="sd">            sample is returned.</span>
<span class="sd">        random_state : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                        `numpy.random.RandomState`}, optional</span>

<span class="sd">            Pseudorandom number generator state used to generate resamples.</span>

<span class="sd">            If `random_state` is ``None`` (or `np.random`), the</span>
<span class="sd">            `numpy.random.RandomState` singleton is used.</span>
<span class="sd">            If `random_state` is an int, a new ``RandomState`` instance is</span>
<span class="sd">            used, seeded with `random_state`.</span>
<span class="sd">            If `random_state` is already a ``Generator`` or ``RandomState``</span>
<span class="sd">            instance then that instance is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray</span>
<span class="sd">            Random direction vectors</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">_sample_uniform_direction</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>


<span class="n">uniform_direction</span> <span class="o">=</span> <span class="n">uniform_direction_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">uniform_direction_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen n-dimensional uniform direction distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension of matrices</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                `numpy.random.RandomState`}, optional</span>

<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.stats import uniform_direction</span>
<span class="sd">        &gt;&gt;&gt; x = uniform_direction(3)</span>
<span class="sd">        &gt;&gt;&gt; x.rvs()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">uniform_direction_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_sample_uniform_direction</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method to generate uniform directions</span>
<span class="sd">    Reference: Marsaglia, G. (1972). &quot;Choosing a Point from the Surface of a</span>
<span class="sd">               Sphere&quot;. Annals of Mathematical Statistics. 43 (2): 645-646.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">samples_shape</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span>


<span class="n">_dirichlet_mn_doc_default_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">alpha : array_like</span>
<span class="s2">    The concentration parameters. The number of entries along the last axis</span>
<span class="s2">    determines the dimensionality of the distribution. Each entry must be</span>
<span class="s2">    strictly positive.</span>
<span class="s2">n : int or array_like</span>
<span class="s2">    The number of trials. Each element must be a non-negative integer.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_dirichlet_mn_doc_frozen_callparams</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">_dirichlet_mn_doc_frozen_callparams_note</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">dirichlet_mn_docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_dirichlet_mn_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_dirichlet_mn_doc_default_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>

<span class="n">dirichlet_mn_docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_dirichlet_mn_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_dirichlet_mn_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s1">&#39;_doc_random_state&#39;</span><span class="p">:</span> <span class="n">_doc_random_state</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ensure that `x` and `alpha` are arrays. If the shapes are</span>
        <span class="c1"># incompatible, NumPy will raise an appropriate error.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;`x` and `alpha` must be broadcastable.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">x_int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must contain only non-negative integers.&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x_int</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`alpha` must contain only positive values.&quot;</span><span class="p">)</span>

    <span class="n">n_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">n_int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`n` must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_int</span>

    <span class="n">sum_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sum_alpha</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">sum_alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">sum_alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">sum_alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">dirichlet_multinomial_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A Dirichlet multinomial random variable.</span>

<span class="sd">    The Dirichlet multinomial distribution is a compound probability</span>
<span class="sd">    distribution: it is the multinomial distribution with number of trials</span>
<span class="sd">    `n` and class probabilities ``p`` randomly sampled from a Dirichlet</span>
<span class="sd">    distribution with concentration parameters ``alpha``.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    logpmf(x, alpha, n):</span>
<span class="sd">        Log of the probability mass function.</span>
<span class="sd">    pmf(x, alpha, n):</span>
<span class="sd">        Probability mass function.</span>
<span class="sd">    mean(alpha, n):</span>
<span class="sd">        Mean of the Dirichlet multinomial distribution.</span>
<span class="sd">    var(alpha, n):</span>
<span class="sd">        Variance of the Dirichlet multinomial distribution.</span>
<span class="sd">    cov(alpha, n):</span>
<span class="sd">        The covariance of the Dirichlet multinomial distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(_dirichlet_mn_doc_default_callparams)s</span>
<span class="sd">    %(_doc_random_state)s</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.stats.dirichlet : The dirichlet distribution.</span>
<span class="sd">    scipy.stats.multinomial : The multinomial distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dirichlet-multinomial distribution, Wikipedia,</span>
<span class="sd">           https://www.wikipedia.org/wiki/Dirichlet-multinomial_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import dirichlet_multinomial</span>

<span class="sd">    Get the PMF</span>

<span class="sd">    &gt;&gt;&gt; n = 6  # number of trials</span>
<span class="sd">    &gt;&gt;&gt; alpha = [3, 4, 5]  # concentration parameters</span>
<span class="sd">    &gt;&gt;&gt; x = [1, 2, 3]  # counts</span>
<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.pmf(x, alpha, n)</span>
<span class="sd">    0.08484162895927604</span>

<span class="sd">    If the sum of category counts does not equal the number of trials,</span>
<span class="sd">    the probability mass is zero.</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.pmf(x, alpha, n=7)</span>
<span class="sd">    0.0</span>

<span class="sd">    Get the log of the PMF</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.logpmf(x, alpha, n)</span>
<span class="sd">    -2.4669689491013327</span>

<span class="sd">    Get the mean</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.mean(alpha, n)</span>
<span class="sd">    array([1.5, 2. , 2.5])</span>

<span class="sd">    Get the variance</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.var(alpha, n)</span>
<span class="sd">    array([1.55769231, 1.84615385, 2.01923077])</span>

<span class="sd">    Get the covariance</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.cov(alpha, n)</span>
<span class="sd">    array([[ 1.55769231, -0.69230769, -0.86538462],</span>
<span class="sd">           [-0.69230769,  1.84615385, -1.15384615],</span>
<span class="sd">           [-0.86538462, -1.15384615,  2.01923077]])</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the</span>
<span class="sd">    `alpha` and `n` parameters, returning a &quot;frozen&quot; Dirichlet multinomial</span>
<span class="sd">    random variable.</span>

<span class="sd">    &gt;&gt;&gt; dm = dirichlet_multinomial(alpha, n)</span>
<span class="sd">    &gt;&gt;&gt; dm.pmf(x)</span>
<span class="sd">    0.08484162895927579</span>

<span class="sd">    All methods are fully vectorized. Each element of `x` and `alpha` is</span>
<span class="sd">    a vector (along the last axis), each element of `n` is an</span>
<span class="sd">    integer (scalar), and the result is computed element-wise.</span>

<span class="sd">    &gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; alpha = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; n = [6, 15]</span>
<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.pmf(x, alpha, n)</span>
<span class="sd">    array([0.06493506, 0.02626937])</span>

<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.cov(alpha, n).shape  # both covariance matrices</span>
<span class="sd">    (2, 3, 3)</span>

<span class="sd">    Broadcasting according to standard NumPy conventions is supported. Here,</span>
<span class="sd">    we have four sets of concentration parameters (each a two element vector)</span>
<span class="sd">    for each of three numbers of trials (each a scalar).</span>

<span class="sd">    &gt;&gt;&gt; alpha = [[3, 4], [4, 5], [5, 6], [6, 7]]</span>
<span class="sd">    &gt;&gt;&gt; n = [[6], [7], [8]]</span>
<span class="sd">    &gt;&gt;&gt; dirichlet_multinomial.mean(alpha, n).shape</span>
<span class="sd">    (3, 4, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                        <span class="n">dirichlet_mn_docdict_params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dirichlet_multinomial_frozen</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The log of the probability mass function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: ndarray</span>
<span class="sd">            Category counts (non-negative integers). Must be broadcastable</span>
<span class="sd">            with shape parameter ``alpha``. If multidimensional, the last axis</span>
<span class="sd">            must correspond with the categories.</span>
<span class="sd">        %(_dirichlet_mn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: ndarray or scalar</span>
<span class="sd">            Log of the probability mass function.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loggamma</span><span class="p">(</span><span class="n">Sa</span><span class="p">)</span> <span class="o">+</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">Sa</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loggamma</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">loggamma</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Probability mass function for a Dirichlet multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: ndarray</span>
<span class="sd">            Category counts (non-negative integers). Must be broadcastable</span>
<span class="sd">            with shape parameter ``alpha``. If multidimensional, the last axis</span>
<span class="sd">            must correspond with the categories.</span>
<span class="sd">        %(_dirichlet_mn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: ndarray or scalar</span>
<span class="sd">            Probability mass function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of a Dirichlet multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_mn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: ndarray</span>
<span class="sd">            Mean of a Dirichlet multinomial distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">Sa</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">Sa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">a</span> <span class="o">/</span> <span class="n">Sa</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The variance of the Dirichlet multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_mn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: array_like</span>
<span class="sd">            The variances of the components of the distribution. This is</span>
<span class="sd">            the diagonal of the covariance matrix of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">Sa</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">Sa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">a</span> <span class="o">/</span> <span class="n">Sa</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="o">/</span><span class="n">Sa</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">Sa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Sa</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Covariance matrix of a Dirichlet multinomial distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_dirichlet_mn_doc_default_callparams)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : array_like</span>
<span class="sd">            The covariance matrix of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">dirichlet_multinomial</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">Sa</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">Sa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">aiaj</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">aiaj</span> <span class="o">/</span> <span class="n">Sa</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">Sa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Sa</span><span class="p">)</span>

        <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
        <span class="k">return</span> <span class="n">cov</span>


<span class="n">dirichlet_multinomial</span> <span class="o">=</span> <span class="n">dirichlet_multinomial_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">dirichlet_multinomial_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_dirichlet_multinomial_check_parameters</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">dirichlet_multinomial_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># dirichlet_multinomial and fill in default strings in class docstrings.</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpmf&#39;</span><span class="p">,</span> <span class="s1">&#39;pmf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">dirichlet_multinomial_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">dirichlet_multinomial_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span>
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">dirichlet_mn_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                      <span class="n">dirichlet_mn_docdict_params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">vonmises_fisher_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A von Mises-Fisher variable.</span>

<span class="sd">    The `mu` keyword specifies the mean direction vector. The `kappa` keyword</span>
<span class="sd">    specifies the concentration parameter.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, mu=None, kappa=1)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, mu=None, kappa=1)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(mu=None, kappa=1, size=1, random_state=None)</span>
<span class="sd">        Draw random samples from a von Mises-Fisher distribution.</span>
<span class="sd">    entropy(mu=None, kappa=1)</span>
<span class="sd">        Compute the differential entropy of the von Mises-Fisher distribution.</span>
<span class="sd">    fit(data)</span>
<span class="sd">        Fit a von Mises-Fisher distribution to data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu : array_like</span>
<span class="sd">        Mean direction of the distribution. Must be a one-dimensional unit</span>
<span class="sd">        vector of norm 1.</span>
<span class="sd">    kappa : float</span>
<span class="sd">        Concentration parameter. Must be positive.</span>
<span class="sd">    seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.stats.vonmises : Von-Mises Fisher distribution in 2D on a circle</span>
<span class="sd">    uniform_direction : uniform distribution on the surface of a hypersphere</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The von Mises-Fisher distribution is a directional distribution on the</span>
<span class="sd">    surface of the unit hypersphere. The probability density</span>
<span class="sd">    function of a unit vector :math:`\mathbf{x}` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(\mathbf{x}) = \frac{\kappa^{d/2-1}}{(2\pi)^{d/2}I_{d/2-1}(\kappa)}</span>
<span class="sd">               \exp\left(\kappa \mathbf{\mu}^T\mathbf{x}\right),</span>

<span class="sd">    where :math:`\mathbf{\mu}` is the mean direction, :math:`\kappa` the</span>
<span class="sd">    concentration parameter, :math:`d` the dimension and :math:`I` the</span>
<span class="sd">    modified Bessel function of the first kind. As :math:`\mu` represents</span>
<span class="sd">    a direction, it must be a unit vector or in other words, a point</span>
<span class="sd">    on the hypersphere: :math:`\mathbf{\mu}\in S^{d-1}`. :math:`\kappa` is a</span>
<span class="sd">    concentration parameter, which means that it must be positive</span>
<span class="sd">    (:math:`\kappa&gt;0`) and that the distribution becomes more narrow with</span>
<span class="sd">    increasing :math:`\kappa`. In that sense, the reciprocal value</span>
<span class="sd">    :math:`1/\kappa` resembles the variance parameter of the normal</span>
<span class="sd">    distribution.</span>

<span class="sd">    The von Mises-Fisher distribution often serves as an analogue of the</span>
<span class="sd">    normal distribution on the sphere. Intuitively, for unit vectors, a</span>
<span class="sd">    useful distance measure is given by the angle :math:`\alpha` between</span>
<span class="sd">    them. This is exactly what the scalar product</span>
<span class="sd">    :math:`\mathbf{\mu}^T\mathbf{x}=\cos(\alpha)` in the</span>
<span class="sd">    von Mises-Fisher probability density function describes: the angle</span>
<span class="sd">    between the mean direction :math:`\mathbf{\mu}` and the vector</span>
<span class="sd">    :math:`\mathbf{x}`. The larger the angle between them, the smaller the</span>
<span class="sd">    probability to observe :math:`\mathbf{x}` for this particular mean</span>
<span class="sd">    direction :math:`\mathbf{\mu}`.</span>

<span class="sd">    In dimensions 2 and 3, specialized algorithms are used for fast sampling</span>
<span class="sd">    [2]_, [3]_. For dimensions of 4 or higher the rejection sampling algorithm</span>
<span class="sd">    described in [4]_ is utilized. This implementation is partially based on</span>
<span class="sd">    the geomstats package [5]_, [6]_.</span>

<span class="sd">    .. versionadded:: 1.11</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Von Mises-Fisher distribution, Wikipedia,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution</span>
<span class="sd">    .. [2] Mardia, K., and Jupp, P. Directional statistics. Wiley, 2000.</span>
<span class="sd">    .. [3] J. Wenzel. Numerically stable sampling of the von Mises Fisher</span>
<span class="sd">           distribution on S2.</span>
<span class="sd">           https://www.mitsuba-renderer.org/~wenzel/files/vmf.pdf</span>
<span class="sd">    .. [4] Wood, A. Simulation of the von mises fisher distribution.</span>
<span class="sd">           Communications in statistics-simulation and computation 23,</span>
<span class="sd">           1 (1994), 157-164. https://doi.org/10.1080/03610919408813161</span>
<span class="sd">    .. [5] geomstats, Github. MIT License. Accessed: 06.01.2023.</span>
<span class="sd">           https://github.com/geomstats/geomstats</span>
<span class="sd">    .. [6] Miolane, N. et al. Geomstats:  A Python Package for Riemannian</span>
<span class="sd">           Geometry in Machine Learning. Journal of Machine Learning Research</span>
<span class="sd">           21 (2020). http://jmlr.org/papers/v21/19-027.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Visualization of the probability density**</span>

<span class="sd">    Plot the probability density in three dimensions for increasing</span>
<span class="sd">    concentration parameter. The density is calculated by the ``pdf``</span>
<span class="sd">    method.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import vonmises_fisher</span>
<span class="sd">    &gt;&gt;&gt; from matplotlib.colors import Normalize</span>
<span class="sd">    &gt;&gt;&gt; n_grid = 100</span>
<span class="sd">    &gt;&gt;&gt; u = np.linspace(0, np.pi, n_grid)</span>
<span class="sd">    &gt;&gt;&gt; v = np.linspace(0, 2 * np.pi, n_grid)</span>
<span class="sd">    &gt;&gt;&gt; u_grid, v_grid = np.meshgrid(u, v)</span>
<span class="sd">    &gt;&gt;&gt; vertices = np.stack([np.cos(v_grid) * np.sin(u_grid),</span>
<span class="sd">    ...                      np.sin(v_grid) * np.sin(u_grid),</span>
<span class="sd">    ...                      np.cos(u_grid)],</span>
<span class="sd">    ...                     axis=2)</span>
<span class="sd">    &gt;&gt;&gt; x = np.outer(np.cos(v), np.sin(u))</span>
<span class="sd">    &gt;&gt;&gt; y = np.outer(np.sin(v), np.sin(u))</span>
<span class="sd">    &gt;&gt;&gt; z = np.outer(np.ones_like(u), np.cos(u))</span>
<span class="sd">    &gt;&gt;&gt; def plot_vmf_density(ax, x, y, z, vertices, mu, kappa):</span>
<span class="sd">    ...     vmf = vonmises_fisher(mu, kappa)</span>
<span class="sd">    ...     pdf_values = vmf.pdf(vertices)</span>
<span class="sd">    ...     pdfnorm = Normalize(vmin=pdf_values.min(), vmax=pdf_values.max())</span>
<span class="sd">    ...     ax.plot_surface(x, y, z, rstride=1, cstride=1,</span>
<span class="sd">    ...                     facecolors=plt.cm.viridis(pdfnorm(pdf_values)),</span>
<span class="sd">    ...                     linewidth=0)</span>
<span class="sd">    ...     ax.set_aspect(&#39;equal&#39;)</span>
<span class="sd">    ...     ax.view_init(azim=-130, elev=0)</span>
<span class="sd">    ...     ax.axis(&#39;off&#39;)</span>
<span class="sd">    ...     ax.set_title(rf&quot;$\kappa={kappa}$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(9, 4),</span>
<span class="sd">    ...                          subplot_kw={&quot;projection&quot;: &quot;3d&quot;})</span>
<span class="sd">    &gt;&gt;&gt; left, middle, right = axes</span>
<span class="sd">    &gt;&gt;&gt; mu = np.array([-np.sqrt(0.5), -np.sqrt(0.5), 0])</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_density(left, x, y, z, vertices, mu, 5)</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_density(middle, x, y, z, vertices, mu, 20)</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_density(right, x, y, z, vertices, mu, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplots_adjust(top=1, bottom=0.0, left=0.0, right=1.0, wspace=0.)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    As we increase the concentration parameter, the points are getting more</span>
<span class="sd">    clustered together around the mean direction.</span>

<span class="sd">    **Sampling**</span>

<span class="sd">    Draw 5 samples from the distribution using the ``rvs`` method resulting</span>
<span class="sd">    in a 5x3 array.</span>

<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; mu = np.array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; samples = vonmises_fisher(mu, 20).rvs(5, random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; samples</span>
<span class="sd">    array([[ 0.3884594 , -0.32482588,  0.86231516],</span>
<span class="sd">           [ 0.00611366, -0.09878289,  0.99509023],</span>
<span class="sd">           [-0.04154772, -0.01637135,  0.99900239],</span>
<span class="sd">           [-0.14613735,  0.12553507,  0.98126695],</span>
<span class="sd">           [-0.04429884, -0.23474054,  0.97104814]])</span>

<span class="sd">    These samples are unit vectors on the sphere :math:`S^2`. To verify,</span>
<span class="sd">    let us calculate their euclidean norms:</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.norm(samples, axis=1)</span>
<span class="sd">    array([1., 1., 1., 1., 1.])</span>

<span class="sd">    Plot 20 observations drawn from the von Mises-Fisher distribution for</span>
<span class="sd">    increasing concentration parameter :math:`\kappa`. The red dot highlights</span>
<span class="sd">    the mean direction :math:`\mu`.</span>

<span class="sd">    &gt;&gt;&gt; def plot_vmf_samples(ax, x, y, z, mu, kappa):</span>
<span class="sd">    ...     vmf = vonmises_fisher(mu, kappa)</span>
<span class="sd">    ...     samples = vmf.rvs(20)</span>
<span class="sd">    ...     ax.plot_surface(x, y, z, rstride=1, cstride=1, linewidth=0,</span>
<span class="sd">    ...                     alpha=0.2)</span>
<span class="sd">    ...     ax.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c=&#39;k&#39;, s=5)</span>
<span class="sd">    ...     ax.scatter(mu[0], mu[1], mu[2], c=&#39;r&#39;, s=30)</span>
<span class="sd">    ...     ax.set_aspect(&#39;equal&#39;)</span>
<span class="sd">    ...     ax.view_init(azim=-130, elev=0)</span>
<span class="sd">    ...     ax.axis(&#39;off&#39;)</span>
<span class="sd">    ...     ax.set_title(rf&quot;$\kappa={kappa}$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; mu = np.array([-np.sqrt(0.5), -np.sqrt(0.5), 0])</span>
<span class="sd">    &gt;&gt;&gt; fig, axes = plt.subplots(nrows=1, ncols=3,</span>
<span class="sd">    ...                          subplot_kw={&quot;projection&quot;: &quot;3d&quot;},</span>
<span class="sd">    ...                          figsize=(9, 4))</span>
<span class="sd">    &gt;&gt;&gt; left, middle, right = axes</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_samples(left, x, y, z, mu, 5)</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_samples(middle, x, y, z, mu, 20)</span>
<span class="sd">    &gt;&gt;&gt; plot_vmf_samples(right, x, y, z, mu, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplots_adjust(top=1, bottom=0.0, left=0.0,</span>
<span class="sd">    ...                     right=1.0, wspace=0.)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The plots show that with increasing concentration :math:`\kappa` the</span>
<span class="sd">    resulting samples are centered more closely around the mean direction.</span>

<span class="sd">    **Fitting the distribution parameters**</span>

<span class="sd">    The distribution can be fitted to data using the ``fit`` method returning</span>
<span class="sd">    the estimated parameters. As a toy example let&#39;s fit the distribution to</span>
<span class="sd">    samples drawn from a known von Mises-Fisher distribution.</span>

<span class="sd">    &gt;&gt;&gt; mu, kappa = np.array([0, 0, 1]), 20</span>
<span class="sd">    &gt;&gt;&gt; samples = vonmises_fisher(mu, kappa).rvs(1000, random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; mu_fit, kappa_fit = vonmises_fisher.fit(samples)</span>
<span class="sd">    &gt;&gt;&gt; mu_fit, kappa_fit</span>
<span class="sd">    (array([0.01126519, 0.01044501, 0.99988199]), 19.306398751730995)</span>

<span class="sd">    We see that the estimated parameters `mu_fit` and `kappa_fit` are</span>
<span class="sd">    very close to the ground truth parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen von Mises-Fisher distribution.</span>

<span class="sd">        See `vonmises_fisher_frozen` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vonmises_fisher_frozen</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer dimensionality from mu and ensure that mu is a one-dimensional</span>
<span class="sd">        unit vector and kappa positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;mu&#39; must have one-dimensional shape.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mu</span><span class="p">),</span> <span class="mf">1.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;mu&#39; must be a unit vector of norm 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;mu&#39; must have at least two entries.&quot;</span><span class="p">)</span>
        <span class="n">kappa_error_msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;kappa&#39; must be a positive scalar.&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="ow">or</span> <span class="n">kappa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">kappa_error_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For &#39;kappa=0&#39; the von Mises-Fisher distribution &quot;</span>
                             <span class="s2">&quot;becomes the uniform distribution on the sphere &quot;</span>
                             <span class="s2">&quot;surface. Consider using &quot;</span>
                             <span class="s2">&quot;&#39;scipy.stats.uniform_direction&#39; instead.&quot;</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">size</span>

        <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_data_vs_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dimensionality of the last axis of &#39;x&#39; must &quot;</span>
                             <span class="s2">&quot;match the dimensionality of the &quot;</span>
                             <span class="s2">&quot;von Mises Fisher distribution.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;x&#39; must be unit vectors of norm 1 along last dimension.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_norm_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
        <span class="c1"># normalization factor is given by</span>
        <span class="c1"># c = kappa**(dim/2-1)/((2*pi)**(dim/2)*I[dim/2-1](kappa))</span>
        <span class="c1">#   = kappa**(dim/2-1)*exp(-kappa) /</span>
        <span class="c1">#     ((2*pi)**(dim/2)*I[dim/2-1](kappa)*exp(-kappa)</span>
        <span class="c1">#   = kappa**(dim/2-1)*exp(-kappa) /</span>
        <span class="c1">#     ((2*pi)**(dim/2)*ive[dim/2-1](kappa)</span>
        <span class="c1"># Then the log is given by</span>
        <span class="c1"># log c = 1/2*(dim -1)*log(kappa) - kappa - -1/2*dim*ln(2*pi) -</span>
        <span class="c1">#         ive[dim/2-1](kappa)</span>
        <span class="n">halfdim</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfdim</span> <span class="o">*</span> <span class="n">_LOG_2PI</span> <span class="o">-</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ive</span><span class="p">(</span><span class="n">halfdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kappa</span><span class="p">))</span> <span class="o">-</span> <span class="n">kappa</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the von Mises-Fisher probability density function.</span>

<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_vs_dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">dotproducts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_norm_factor</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">dotproducts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the von Mises-Fisher probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function. The last axis of `x` must correspond</span>
<span class="sd">            to unit vectors of the same dimensionality as the distribution.</span>
<span class="sd">        mu : array_like, default: None</span>
<span class="sd">            Mean direction of the distribution. Must be a one-dimensional unit</span>
<span class="sd">            vector of norm 1.</span>
<span class="sd">        kappa : float, default: 1</span>
<span class="sd">            Concentration parameter. Must be positive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : ndarray or scalar</span>
<span class="sd">            Log of the probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Von Mises-Fisher probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the probability</span>
<span class="sd">            density function. The last axis of `x` must correspond</span>
<span class="sd">            to unit vectors of the same dimensionality as the distribution.</span>
<span class="sd">        mu : array_like</span>
<span class="sd">            Mean direction of the distribution. Must be a one-dimensional unit</span>
<span class="sd">            vector of norm 1.</span>
<span class="sd">        kappa : float</span>
<span class="sd">            Concentration parameter. Must be positive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            Probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In 2D, the von Mises-Fisher distribution reduces to the</span>
<span class="sd">        von Mises distribution which can be efficiently sampled by numpy.</span>
<span class="sd">        This method is much faster than the general rejection</span>
<span class="sd">        sampling based algorithm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">angle_samples</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">vonmises</span><span class="p">(</span><span class="n">mean_angle</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_samples</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_samples</span><span class="p">)],</span>
                           <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate samples from a von Mises-Fisher distribution</span>
<span class="sd">        with mu = [1, 0, 0] and kappa. Samples then have to be</span>
<span class="sd">        rotated towards the desired mean direction mu.</span>
<span class="sd">        This method is much faster than the general rejection</span>
<span class="sd">        sampling based algorithm.</span>
<span class="sd">        Reference: https://www.mitsuba-renderer.org/~wenzel/files/vmf.pdf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">size</span>

        <span class="c1"># compute x coordinate acc. to equation from section 3.1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kappa</span><span class="p">))</span><span class="o">/</span><span class="n">kappa</span>

        <span class="c1"># (y, z) are random 2D vectors that only have to be</span>
        <span class="c1"># normalized accordingly. Then (x, y z) follow a VMF distribution</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">uniformcircle</span> <span class="o">=</span> <span class="n">_sample_uniform_direction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">uniformcircle</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="n">temp</span> <span class="o">*</span> <span class="n">uniformcircle</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                           <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rejection_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate samples from a n-dimensional von Mises-Fisher distribution</span>
<span class="sd">        with mu = [1, 0, ..., 0] and kappa via rejection sampling.</span>
<span class="sd">        Samples then have to be rotated towards the desired mean direction mu.</span>
<span class="sd">        Reference: https://doi.org/10.1080/03610919408813161</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_minus_one</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># calculate number of requested samples</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># calculate envelope for rejection sampler (eq. 4)</span>
        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">kappa</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">+</span> <span class="n">dim_minus_one</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">envelop_param</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kappa</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">)</span> <span class="o">/</span> <span class="n">dim_minus_one</span>
        <span class="k">if</span> <span class="n">envelop_param</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># the regular formula suffers from loss of precision for high</span>
            <span class="c1"># kappa. This can only be detected by checking for 0 here.</span>
            <span class="c1"># Workaround: expansion for sqrt variable</span>
            <span class="c1"># https://www.wolframalpha.com/input?i=sqrt%284*x%5E2%2Bd%5E2%29</span>
            <span class="c1"># e = (-2 * k + sqrt(k**2 + d**2)) / d</span>
            <span class="c1">#   ~ (-2 * k + 2 * k + d**2/(4 * k) - d**4/(64 * k**3)) / d</span>
            <span class="c1">#   = d/(4 * k) - d**3/(64 * k**3)</span>
            <span class="n">envelop_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim_minus_one</span><span class="o">/</span><span class="mi">4</span> <span class="o">*</span> <span class="n">kappa</span><span class="o">**-</span><span class="mf">1.</span>
                             <span class="o">-</span> <span class="n">dim_minus_one</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">64</span> <span class="o">*</span> <span class="n">kappa</span><span class="o">**-</span><span class="mf">3.</span><span class="p">)</span>
        <span class="c1"># reference step 0</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">envelop_param</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">envelop_param</span><span class="p">)</span>
        <span class="c1"># t = ln(1 - ((1-x)/(1+x))**2)</span>
        <span class="c1">#   = ln(4 * x / (1+x)**2)</span>
        <span class="c1">#   = ln(4) + ln(x) - 2*log1p(x)</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">node</span> <span class="o">+</span> <span class="n">dim_minus_one</span>
                      <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">envelop_param</span><span class="p">)</span>
                      <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">envelop_param</span><span class="p">)))</span>
        <span class="n">n_accepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">halfdim</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim_minus_one</span>
        <span class="c1"># main loop</span>
        <span class="k">while</span> <span class="n">n_accepted</span> <span class="o">&lt;</span> <span class="n">n_samples</span><span class="p">:</span>
            <span class="c1"># generate candidates acc. to reference step 1</span>
            <span class="n">sym_beta</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">halfdim</span><span class="p">,</span> <span class="n">halfdim</span><span class="p">,</span>
                                         <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span> <span class="o">-</span> <span class="n">n_accepted</span><span class="p">)</span>
            <span class="n">coord_x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">envelop_param</span><span class="p">)</span> <span class="o">*</span> <span class="n">sym_beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">envelop_param</span><span class="p">)</span> <span class="o">*</span> <span class="n">sym_beta</span><span class="p">)</span>
            <span class="c1"># accept or reject: reference step 2</span>
            <span class="c1"># reformulation for numerical stability:</span>
            <span class="c1"># t = ln(1 - (1-x)/(1+x) * y)</span>
            <span class="c1">#   = ln((1 + x - y +x*y)/(1 +x))</span>
            <span class="n">accept_tol</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="n">n_accepted</span><span class="p">)</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kappa</span> <span class="o">*</span> <span class="n">coord_x</span>
                <span class="o">+</span> <span class="n">dim_minus_one</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">envelop_param</span> <span class="o">-</span> <span class="n">coord_x</span>
                <span class="o">+</span> <span class="n">coord_x</span> <span class="o">*</span> <span class="n">envelop_param</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">envelop_param</span><span class="p">)))</span>
                <span class="o">-</span> <span class="n">correction</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">accept_tol</span><span class="p">)</span>
            <span class="n">accepted_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">n_accepted</span><span class="p">:</span><span class="n">n_accepted</span> <span class="o">+</span> <span class="n">accepted_iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_x</span><span class="p">[</span><span class="n">criterion</span><span class="p">]</span>
            <span class="n">n_accepted</span> <span class="o">+=</span> <span class="n">accepted_iter</span>
        <span class="c1"># concatenate x and remaining coordinates: step 3</span>
        <span class="n">coord_rest</span> <span class="o">=</span> <span class="n">_sample_uniform_direction</span><span class="p">(</span><span class="n">dim_minus_one</span><span class="p">,</span> <span class="n">n_accepted</span><span class="p">,</span>
                                               <span class="n">random_state</span><span class="p">)</span>
        <span class="n">coord_rest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s1">&#39;...,...i-&gt;...i&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">coord_rest</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">coord_rest</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># reshape output to (size, dim)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rotate_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A QR decomposition is used to find the rotation that maps the</span>
<span class="sd">        north pole (1, 0,...,0) to the vector mu. This rotation is then</span>
<span class="sd">        applied to all samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples: array_like, shape = [..., n]</span>
<span class="sd">        mu : array-like, shape=[n, ]</span>
<span class="sd">            Point to parametrise the rotation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        samples : rotated samples</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">base_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">embedded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))])</span>
        <span class="n">rotmatrix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">embedded</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotmatrix</span><span class="p">,</span> <span class="n">base_point</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mu</span><span class="p">):</span>
            <span class="n">rotsign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotsign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># apply rotation</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,...j-&gt;...i&#39;</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">rotsign</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs_2d</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs_3d</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rejection_sampling</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
                                               <span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from a von Mises-Fisher distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : array_like</span>
<span class="sd">            Mean direction of the distribution. Must be a one-dimensional unit</span>
<span class="sd">            vector of norm 1.</span>
<span class="sd">        kappa : float</span>
<span class="sd">            Concentration parameter. Must be positive.</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Given a shape of, for example, (m,n,k), m*n*k samples are</span>
<span class="sd">            generated, and packed in an m-by-n-by-k arrangement.</span>
<span class="sd">            Because each sample is N-dimensional, the output shape</span>
<span class="sd">            is (m,n,k,N). If no shape is specified, a single (N-D)</span>
<span class="sd">            sample is returned.</span>
<span class="sd">        random_state : {None, int, np.random.RandomState, np.random.Generator},</span>
<span class="sd">                        optional</span>
<span class="sd">            Used for drawing random variates.</span>
<span class="sd">            If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">            with seed.</span>
<span class="sd">            If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">            then that object is used.</span>
<span class="sd">            Default is `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray</span>
<span class="sd">            Random variates of shape (`size`, `N`), where `N` is the</span>
<span class="sd">            dimension of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
        <span class="n">halfdim</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_norm_factor</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span> <span class="o">-</span> <span class="n">kappa</span> <span class="o">*</span>
                <span class="n">ive</span><span class="p">(</span><span class="n">halfdim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span> <span class="o">/</span> <span class="n">ive</span><span class="p">(</span><span class="n">halfdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kappa</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the differential entropy of the von Mises-Fisher</span>
<span class="sd">        distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : array_like, default: None</span>
<span class="sd">            Mean direction of the distribution. Must be a one-dimensional unit</span>
<span class="sd">            vector of norm 1.</span>
<span class="sd">        kappa : float, default: 1</span>
<span class="sd">            Concentration parameter. Must be positive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the von Mises-Fisher distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the von Mises-Fisher distribution to data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Data the distribution is fitted to. Must be two dimensional.</span>
<span class="sd">            The second axis of `x` must be unit vectors of norm 1 and</span>
<span class="sd">            determine the dimensionality of the fitted</span>
<span class="sd">            von Mises-Fisher distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu : ndarray</span>
<span class="sd">            Estimated mean direction.</span>
<span class="sd">        kappa : float</span>
<span class="sd">            Estimated concentration parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># validate input data</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;x&#39; must be two dimensional.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;x&#39; must be unit vectors of norm 1 along last dimension.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># mu is simply the directional mean</span>
        <span class="n">dirstats</span> <span class="o">=</span> <span class="n">directional_stats</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">dirstats</span><span class="o">.</span><span class="n">mean_direction</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">dirstats</span><span class="o">.</span><span class="n">mean_resultant_length</span>

        <span class="c1"># kappa is the solution to the equation:</span>
        <span class="c1"># r = I[dim/2](kappa) / I[dim/2 -1](kappa)</span>
        <span class="c1">#   = I[dim/2](kappa) * exp(-kappa) / I[dim/2 -1](kappa) * exp(-kappa)</span>
        <span class="c1">#   = ive(dim/2, kappa) / ive(dim/2 -1, kappa)</span>

        <span class="n">halfdim</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dim</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">solve_for_kappa</span><span class="p">(</span><span class="n">kappa</span><span class="p">):</span>
            <span class="n">bessel_vals</span> <span class="o">=</span> <span class="n">ive</span><span class="p">([</span><span class="n">halfdim</span><span class="p">,</span> <span class="n">halfdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">kappa</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">bessel_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">bessel_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>

        <span class="n">root_res</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">solve_for_kappa</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;brentq&quot;</span><span class="p">,</span>
                               <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">))</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">root_res</span><span class="o">.</span><span class="n">root</span>
        <span class="k">return</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span>


<span class="n">vonmises_fisher</span> <span class="o">=</span> <span class="n">vonmises_fisher_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">vonmises_fisher_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a frozen von Mises-Fisher distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : array_like, default: None</span>
<span class="sd">            Mean direction of the distribution.</span>
<span class="sd">        kappa : float, default: 1</span>
<span class="sd">            Concentration parameter. Must be positive.</span>
<span class="sd">        seed : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">vonmises_fisher_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_process_parameters</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function. The last axis of `x` must correspond</span>
<span class="sd">            to unit vectors of the same dimensionality as the distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : ndarray or scalar</span>
<span class="sd">            Log of probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function. The last axis of `x` must correspond</span>
<span class="sd">            to unit vectors of the same dimensionality as the distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray or scalar</span>
<span class="sd">            Probability density function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random variates from the Von Mises-Fisher distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Given a shape of, for example, (m,n,k), m*n*k samples are</span>
<span class="sd">            generated, and packed in an m-by-n-by-k arrangement.</span>
<span class="sd">            Because each sample is N-dimensional, the output shape</span>
<span class="sd">            is (m,n,k,N). If no shape is specified, a single (N-D)</span>
<span class="sd">            sample is returned.</span>
<span class="sd">        random_state : {None, int, `numpy.random.Generator`,</span>
<span class="sd">                        `numpy.random.RandomState`}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `N`), where `N` is the</span>
<span class="sd">            dimension of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
                               <span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the differential entropy of the von Mises-Fisher</span>
<span class="sd">        distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h: float</span>
<span class="sd">            Entropy of the Von Mises-Fisher distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">normal_inverse_gamma_gen</span><span class="p">(</span><span class="n">multi_rv_generic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normal-inverse-gamma distribution.</span>

<span class="sd">    The normal-inverse-gamma distribution is the conjugate prior of a normal</span>
<span class="sd">    distribution with unknown mean and variance.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, s2, mu=0, lmbda=1, a=1, b=1)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, s2, mu=0, lmbda=1, a=1, b=1)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    mean(mu=0, lmbda=1, a=1, b=1)</span>
<span class="sd">        Distribution mean.</span>
<span class="sd">    var(mu=0, lmbda=1, a=1, b=1)</span>
<span class="sd">        Distribution variance.</span>
<span class="sd">    rvs(mu=0, lmbda=1, a=1, b=1, size=None, random_state=None)</span>
<span class="sd">        Draw random samples.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu, lmbda, a, b  : array_like</span>
<span class="sd">        Shape parameters of the distribution. See notes.</span>
<span class="sd">    seed : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">        Used for drawing random variates.</span>
<span class="sd">        If `seed` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">        If `seed` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">        with seed.</span>
<span class="sd">        If `seed` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">        then that object is used.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    norm</span>
<span class="sd">    invgamma</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The probability density function of `normal_inverse_gamma` is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x, \sigma^2; \mu, \lambda, \alpha, \beta) =</span>
<span class="sd">            \frac{\sqrt{\lambda}}{\sqrt{2 \pi \sigma^2}}</span>
<span class="sd">            \frac{\beta^\alpha}{\Gamma(\alpha)}</span>
<span class="sd">            \left( \frac{1}{\sigma^2} \right)^{\alpha + 1}</span>
<span class="sd">            \exp \left(- \frac{2 \beta + \lambda (x - \mu)^2} {2 \sigma^2} \right)</span>

<span class="sd">    where all parameters are real and finite, and :math:`\sigma^2 &gt; 0`,</span>
<span class="sd">    :math:`\lambda &gt; 0`, :math:`\alpha &gt; 0`, and :math:`\beta &gt; 0`.</span>

<span class="sd">    Methods ``normal_inverse_gamma.pdf`` and ``normal_inverse_gamma.logpdf``</span>
<span class="sd">    accept `x` and `s2` for arguments :math:`x` and :math:`\sigma^2`.</span>
<span class="sd">    All methods accept `mu`, `lmbda`, `a`, and `b` for shape parameters</span>
<span class="sd">    :math:`\mu`, :math:`\lambda`, :math:`\alpha`, and :math:`\beta`,</span>
<span class="sd">    respectively.</span>

<span class="sd">    .. versionadded:: 1.15</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Normal-inverse-gamma distribution, Wikipedia,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Normal-inverse-gamma_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we wish to investigate the relationship between the</span>
<span class="sd">    normal-inverse-gamma distribution and the inverse gamma distribution.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import stats</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng(527484872345)</span>
<span class="sd">    &gt;&gt;&gt; mu, lmbda, a, b = 0, 1, 20, 20</span>
<span class="sd">    &gt;&gt;&gt; norm_inv_gamma = stats.normal_inverse_gamma(mu, lmbda, a, b)</span>
<span class="sd">    &gt;&gt;&gt; inv_gamma = stats.invgamma(a, scale=b)</span>

<span class="sd">    One approach is to compare the distribution of the `s2` elements of</span>
<span class="sd">    random variates against the PDF of an inverse gamma distribution.</span>

<span class="sd">    &gt;&gt;&gt; _, s2 = norm_inv_gamma.rvs(size=10000, random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; bins = np.linspace(s2.min(), s2.max(), 50)</span>
<span class="sd">    &gt;&gt;&gt; plt.hist(s2, bins=bins, density=True, label=&#39;Frequency density&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = np.linspace(s2.min(), s2.max(), 300)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(s2, inv_gamma.pdf(s2), label=&#39;PDF&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(r&#39;$\sigma^2$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency density / PMF&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Similarly, we can compare the marginal distribution of `s2` against</span>
<span class="sd">    an inverse gamma distribution.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.integrate import quad_vec</span>
<span class="sd">    &gt;&gt;&gt; from scipy import integrate</span>
<span class="sd">    &gt;&gt;&gt; s2 = np.linspace(0.5, 3, 6)</span>
<span class="sd">    &gt;&gt;&gt; res = quad_vec(lambda x: norm_inv_gamma.pdf(x, s2), -np.inf, np.inf)[0]</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(res, inv_gamma.pdf(s2))</span>
<span class="sd">    True</span>

<span class="sd">    The sample mean is comparable to the mean of the distribution.</span>

<span class="sd">    &gt;&gt;&gt; x, s2 = norm_inv_gamma.rvs(size=10000, random_state=rng)</span>
<span class="sd">    &gt;&gt;&gt; x.mean(), s2.mean()</span>
<span class="sd">    (np.float64(-0.005254750127304425), np.float64(1.050438111436508))</span>
<span class="sd">    &gt;&gt;&gt; norm_inv_gamma.mean()</span>
<span class="sd">    (np.float64(0.0), np.float64(1.0526315789473684))</span>

<span class="sd">    Similarly, for the variance:</span>

<span class="sd">    &gt;&gt;&gt; x.var(ddof=1), s2.var(ddof=1)</span>
<span class="sd">    (np.float64(1.0546150578185023), np.float64(0.061829865266330754))</span>
<span class="sd">    &gt;&gt;&gt; norm_inv_gamma.var()</span>
<span class="sd">    (np.float64(1.0526315789473684), np.float64(0.061557402277623886))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw random samples from the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu, lmbda, a, b : array_like, optional</span>
<span class="sd">            Shape parameters. `lmbda`, `a`, and `b` must be greater</span>
<span class="sd">            than zero.</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Shape of samples to draw.</span>
<span class="sd">        random_state : {None, int, np.random.RandomState, np.random.Generator}, optional</span>
<span class="sd">            Used for drawing random variates.</span>
<span class="sd">            If `random_state` is `None`, the `~np.random.RandomState` singleton is used.</span>
<span class="sd">            If `random_state` is an int, a new ``RandomState`` instance is used, seeded</span>
<span class="sd">            with `random_state`.</span>
<span class="sd">            If `random_state` is already a ``RandomState`` or ``Generator`` instance,</span>
<span class="sd">            then that object is used.</span>
<span class="sd">            Default is `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, s2 : ndarray</span>
<span class="sd">            Random variates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">invgamma</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">s2</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">s2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lmbda</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">s2</span><span class="p">))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="n">t4</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">lmbda</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log of the probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, s2 : array_like</span>
<span class="sd">            Arguments. `s2` must be greater than zero.</span>
<span class="sd">        mu, lmbda, a, b : array_like, optional</span>
<span class="sd">            Shape parameters. `lmbda`, `a`, and `b` must be greater</span>
<span class="sd">            than zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : ndarray or scalar</span>
<span class="sd">            Log of the probability density function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Keep it simple for now; lazyselect later, perhaps.</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">logpdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">logpdf</span><span class="p">[</span><span class="n">s2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">logpdf</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">logpdf</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lmbda</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">s2</span><span class="p">))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="n">a</span> <span class="o">/</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">t4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">lmbda</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="o">*</span> <span class="n">t3</span> <span class="o">*</span> <span class="n">t4</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, s2 : array_like</span>
<span class="sd">            Arguments. `s2` must be greater than zero.</span>
<span class="sd">        mu, lmbda, a, b : array_like, optional</span>
<span class="sd">            Shape parameters. `lmbda`, `a`, and `b` must be greater</span>
<span class="sd">            than zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : ndarray or scalar</span>
<span class="sd">            The probability density function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_parameters_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Keep it simple for now; lazyselect later, perhaps.</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">pdf</span><span class="p">[</span><span class="n">s2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pdf</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">pdf</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The mean of the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu, lmbda, a, b : array_like, optional</span>
<span class="sd">            Shape parameters. `lmbda` and `b` must be greater</span>
<span class="sd">            than zero, and `a` must be greater than one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, s2 : ndarray</span>
<span class="sd">            The mean of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_shapes</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">invalid</span> <span class="o">|=</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mean_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mean_s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mean_x</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">mean_s2</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">mean_x</span><span class="p">[()],</span> <span class="n">mean_s2</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The variance of the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu, lmbda, a, b : array_like, optional</span>
<span class="sd">            Shape parameters. `lmbda` and `b` must be greater</span>
<span class="sd">            than zero, and `a` must be greater than two.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, s2 : ndarray</span>
<span class="sd">            The variance of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_shapes</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">invalid_x</span> <span class="o">=</span> <span class="n">invalid</span> <span class="o">|</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">invalid_s2</span> <span class="o">=</span> <span class="n">invalid</span> <span class="o">|</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">var_x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lmbda</span><span class="p">)</span>
        <span class="n">var_s2</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">var_x</span><span class="p">,</span> <span class="n">var_s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">var_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">var_s2</span><span class="p">)</span>
        <span class="n">var_x</span><span class="p">[</span><span class="n">invalid_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">var_s2</span><span class="p">[</span><span class="n">invalid_s2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">var_x</span><span class="p">[()],</span> <span class="n">var_s2</span><span class="p">[()]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_parameters_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">lmbda</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">lmbda</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">args</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">normal_inverse_gamma_frozen</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>


<span class="n">normal_inverse_gamma</span> <span class="o">=</span> <span class="n">normal_inverse_gamma_gen</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">normal_inverse_gamma_frozen</span><span class="p">(</span><span class="n">multi_rv_frozen</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmbda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">normal_inverse_gamma_gen</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>


<span class="c1"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c1"># normal_inverse_gamma_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">normal_inverse_gamma_gen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">normal_inverse_gamma_frozen</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                                             <span class="n">mvn_docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">mvn_docdict_params</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">SciStanPy API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Microsoft Corporation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>