<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scistanpy.model.model &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scistanpy.model.model</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation.</span>
<span class="c1"># Licensed under the MIT license.</span>


<span class="sd">&quot;&quot;&quot;Core Model class for SciStanPy Bayesian modeling framework.</span>

<span class="sd">This module contains the fundamental Model class that serves as the primary</span>
<span class="sd">interface for building, compiling, and executing Bayesian models in SciStanPy.</span>
<span class="sd">The Model class orchestrates the composition of model components (parameters,</span>
<span class="sd">constants, transformations) and provides methods for sampling, compilation,</span>
<span class="sd">and analysis.</span>

<span class="sd">The Model class uses a metaclass pattern to automatically register model</span>
<span class="sd">components defined as instance attributes, enabling intuitive model construction</span>
<span class="sd">through simple attribute assignment. It supports multiple backends including</span>
<span class="sd">Stan for MCMC sampling and PyTorch for maximum likelihood estimation.</span>

<span class="sd">Key Features:</span>
<span class="sd">    - Automatic component registration and validation</span>
<span class="sd">    - Multiple sampling backends (Stan MCMC, PyTorch MLE)</span>
<span class="sd">    - Prior and posterior predictive checking</span>
<span class="sd">    - Efficient compilation with caching</span>
<span class="sd">    - Comprehensive model introspection and diagnostics</span>
<span class="sd">    - xarray integration for structured data handling</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=too-many-lines</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">panel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.defaults</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_CPP_OPTIONS</span><span class="p">,</span>
    <span class="n">DEFAULT_DIM_NAMES</span><span class="p">,</span>
    <span class="n">DEFAULT_EARLY_STOP</span><span class="p">,</span>
    <span class="n">DEFAULT_FORCE_COMPILE</span><span class="p">,</span>
    <span class="n">DEFAULT_LR</span><span class="p">,</span>
    <span class="n">DEFAULT_MODEL_NAME</span><span class="p">,</span>
    <span class="n">DEFAULT_N_EPOCHS</span><span class="p">,</span>
    <span class="n">DEFAULT_STANC_OPTIONS</span><span class="p">,</span>
    <span class="n">DEFAULT_USER_HEADER</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstract_model_component</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">constants</span> <span class="k">as</span> <span class="n">constants_module</span><span class="p">,</span>
    <span class="n">parameters</span> <span class="k">as</span> <span class="n">parameters_module</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.transformations</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">transformed_data</span><span class="p">,</span>
    <span class="n">transformed_parameters</span> <span class="k">as</span> <span class="n">transformed_parameters_module</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">custom_types</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.results</span><span class="w"> </span><span class="kn">import</span> <span class="n">hmc</span> <span class="k">as</span> <span class="n">hmc_results</span>

<span class="n">mle_module</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.results.mle&quot;</span><span class="p">)</span>
<span class="n">nn_module</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.nn_module&quot;</span><span class="p">)</span>
<span class="n">prior_predictive_module</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.plotting.prior_predictive&quot;</span><span class="p">)</span>
<span class="n">stan_model</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.stan.stan_model&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="model_comps_to_dict">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.model_comps_to_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">model_comps_to_dict</span><span class="p">(</span>
    <span class="n">model_comps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an iterable of model components to a dictionary keyed by variable names.</span>

<span class="sd">    This utility function creates a dictionary mapping from model variable names</span>
<span class="sd">    to their corresponding component objects, facilitating easy lookup and</span>
<span class="sd">    access to model components by name.</span>

<span class="sd">    :param model_comps: Iterable of model components to convert</span>
<span class="sd">    :type model_comps: Iterable[abstract_model_component.AbstractModelComponent]</span>

<span class="sd">    :returns: Dictionary mapping variable names to components</span>
<span class="sd">    :rtype: dict[str, abstract_model_component.AbstractModelComponent]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; components = [param1, param2, observable1]</span>
<span class="sd">        &gt;&gt;&gt; comp_dict = model_comps_to_dict(components)</span>
<span class="sd">        &gt;&gt;&gt; # Access by name: comp_dict[&#39;param1&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">comp</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">model_comps</span><span class="p">}</span></div>



<div class="viewcode-block" id="run_delayed_mcmc">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.run_delayed_mcmc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_delayed_mcmc</span><span class="p">(</span><span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;hmc_results.SampleResults&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Execute a delayed MCMC run from a pickled configuration file.</span>

<span class="sd">    This function loads and executes MCMC sampling that was previously</span>
<span class="sd">    configured with `Model.mcmc(delay_run=True)`. It&#39;s useful for</span>
<span class="sd">    running computationally intensive sampling jobs in batch systems</span>
<span class="sd">    or separate processes.</span>

<span class="sd">    :param filepath: Path to the pickled MCMC configuration file</span>
<span class="sd">    :type filepath: str</span>

<span class="sd">    :returns: MCMC sampling results with posterior draws and diagnostics</span>
<span class="sd">    :rtype: hmc_results.SampleResults</span>

<span class="sd">    The function automatically enables console output to provide progress</span>
<span class="sd">    feedback during the potentially long-running sampling process.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # First, create delayed run</span>
<span class="sd">        &gt;&gt;&gt; model.mcmc(output_dir = &quot;.&quot;, delay_run=True, chains=4, iter_sampling=2000)</span>
<span class="sd">        &gt;&gt;&gt; # Later, execute the run</span>
<span class="sd">        &gt;&gt;&gt; results = run_delayed_mcmc(f&quot;{model.stan_executable_path}-delay.pkl&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load the pickled object</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># We will be printing to the console</span>
    <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;sample_kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;show_console&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Run sampling and return the results</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;stan_model&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="n">inits</span><span class="o">=</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;inits&quot;</span><span class="p">],</span>
        <span class="n">data</span><span class="o">=</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span>
        <span class="o">**</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;sample_kwargs&quot;</span><span class="p">],</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="Model">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Primary interface for Bayesian model construction and analysis in SciStanPy.</span>

<span class="sd">    The Model class provides a declarative interface for building Bayesian models</span>
<span class="sd">    by composing parameters, constants, and transformations. It automatically</span>
<span class="sd">    handles component registration, validation, and provides methods for sampling,</span>
<span class="sd">    compilation, and analysis across multiple backends.</span>

<span class="sd">    :param args: Positional arguments (unused, for subclass compatibility)</span>
<span class="sd">    :param default_data: Default observed data for model observables. When provided,</span>
<span class="sd">        any instance method requiring data will use these if not otherwise provided.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :type default_data: Optional[dict[str, npt.NDArray]]</span>
<span class="sd">    :param kwargs: Additional keyword arguments (unused, for subclass compatibility)</span>

<span class="sd">    :ivar _default_data: Stored default data for observables</span>
<span class="sd">    :ivar _named_model_components: Tuple of components that have explicit names</span>
<span class="sd">    :ivar _model_varname_to_object: Mapping from variable names to components</span>
<span class="sd">    :ivar _init_complete: Flag indicating initialization completion</span>

<span class="sd">    The class uses a metaclass pattern that automatically registers model</span>
<span class="sd">    components defined as instance attributes. Components are validated</span>
<span class="sd">    for naming conventions and automatically assigned model variable names.</span>

<span class="sd">    Model Construction:</span>
<span class="sd">        Models are built by subclassing Model and defining components as</span>
<span class="sd">        instance attributes in the __init__ method. The metaclass automatically</span>
<span class="sd">        discovers and registers these components.</span>

<span class="sd">    Supported Operations:</span>
<span class="sd">        - Prior and posterior sampling</span>
<span class="sd">        - Maximum likelihood estimation using PyTorch</span>
<span class="sd">        - MCMC sampling using Stan</span>
<span class="sd">        - Model compilation and caching</span>
<span class="sd">        - Prior predictive checking with interactive visualization</span>
<span class="sd">        - Model simulation and validation</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; class MyModel(Model):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super().__init__()</span>
<span class="sd">        ...         self.mu = ssp.parameters.Normal(0, 1)</span>
<span class="sd">        ...         self.sigma = ssp.parameters.HalfNormal(1)</span>
<span class="sd">        ...         self.y = ssp.parameters.Normal(self.mu, self.sigma, observable=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; model = MyModel()</span>
<span class="sd">        &gt;&gt;&gt; prior_samples = model.draw(n=1000)</span>
<span class="sd">        &gt;&gt;&gt; mle_result = model.mle()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>  <span class="c1"># pylint: disable=unused-argument</span>
        <span class="n">default_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>  <span class="c1"># pylint: disable=unused-argument</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This should be overridden by the subclass.&quot;&quot;&quot;</span>
        <span class="c1"># Set the default values for the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">default_data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_named_model_components</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="o">...</span>
        <span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_named_model_components&quot;</span><span class="p">,</span> <span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
        <span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_model_varname_to_object&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_complete</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_init_complete&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configure automatic component registration for Model subclasses.</span>

<span class="sd">        This method is called when a class inherits from Model and sets up</span>
<span class="sd">        the metaclass behavior that automatically discovers and registers</span>
<span class="sd">        model components defined as instance attributes.</span>

<span class="sd">        :param kwargs: Keyword arguments passed to the subclass</span>

<span class="sd">        :raises ValueError: If forbidden attribute names are used or naming</span>
<span class="sd">                           conventions are violated</span>

<span class="sd">        The method wraps the subclass __init__ to add component discovery</span>
<span class="sd">        and registration logic while preserving the original initialization</span>
<span class="sd">        behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The old __init__ method of the class is renamed to &#39;_wrapped_init&#39;</span>
        <span class="k">if</span> <span class="s2">&quot;_wrapped_init&quot;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The attribute `_wrapped_init` cannot be defined in `Model` subclasses&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Redefine the __init__ method of the class</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;Model&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="n">init_args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">init_kwargs</span><span class="p">,</span>
        <span class="p">):</span>

            <span class="c1"># Initialization is incomplete at this stage</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_complete</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Run the init method that was defined in the class.</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_wrapped_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">init_args</span><span class="p">,</span> <span class="o">**</span><span class="n">init_kwargs</span><span class="p">)</span>

            <span class="c1"># That&#39;s it if we are not the last subclass to be initialized</span>
            <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># If we already have model components, defined in the class, update</span>
            <span class="c1"># them with the new model components. This situation occurs when a child</span>
            <span class="c1"># class is defined that inherits from a parent class that is also a</span>
            <span class="c1"># model.</span>
            <span class="n">named_model_components</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Now we need to find all the model components that are defined in the</span>
            <span class="c1"># class.</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">retrieved</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span>
                    <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Double-underscore attributes are forbidden, as this will clash</span>
                <span class="c1"># with how we handle unnamed parameters in Stan code.</span>
                <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Model component names cannot include double underscores: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> is invalid.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Check if the variable name starts with an underscore. This is</span>
                <span class="c1"># forbidden in Stan code.</span>
                <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Model variable names cannot start with an underscore: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> is invalid.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Set the model variable name and record the model component</span>
                <span class="n">retrieved</span><span class="o">.</span><span class="n">model_varname</span> <span class="o">=</span> <span class="n">attr</span>
                <span class="n">named_model_components</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">retrieved</span>

            <span class="c1"># Set the named parameters attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_named_model_components</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">named_model_components</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="c1"># Build the mapping between model variable names and parameter objects</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_model_varname_to_object</span><span class="p">()</span>

            <span class="c1"># Initialization is complete</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_complete</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Set default data as itself. This will trigger the setter method</span>
            <span class="c1"># and will check that the data is valid.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_default_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">default_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_data</span>

        <span class="c1"># Add the new __init__ method</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_wrapped_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="fm">__init__</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_model_varname_to_object</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build comprehensive mapping from variable names to model components.</span>

<span class="sd">        This method constructs a complete dictionary mapping model variable</span>
<span class="sd">        names to their corresponding component objects. It walks the component</span>
<span class="sd">        dependency tree starting from observables to ensure all referenced</span>
<span class="sd">        components are included.</span>

<span class="sd">        :returns: Dictionary mapping variable names to components</span>
<span class="sd">        :rtype: dict[str, abstract_model_component.AbstractModelComponent]</span>

<span class="sd">        The mapping includes:</span>
<span class="sd">        - All observable parameters and their dependencies</span>
<span class="sd">        - Transformed data components</span>
<span class="sd">        - Constants and hyperparameters</span>
<span class="sd">        - Transformed parameters used in the model</span>

<span class="sd">        The method ensures no duplicate variable names exist and validates</span>
<span class="sd">        the integrity of the component dependency graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_initial_mapping</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span>
            <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Builds an initial mapping of model varnames to objects.&quot;&quot;&quot;</span>

            <span class="c1"># Start from each observable and walk up the tree to the root</span>
            <span class="n">model_varname_to_object</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">observable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>

                <span class="c1"># Add the observable to the mapping</span>
                <span class="k">assert</span> <span class="n">observable</span><span class="o">.</span><span class="n">model_varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_varname_to_object</span>
                <span class="n">model_varname_to_object</span><span class="p">[</span><span class="n">observable</span><span class="o">.</span><span class="n">model_varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable</span>

                <span class="c1"># Add all parents to the mapping and make sure</span>
                <span class="c1"># `parameters_module.Parameter` instances are explicitly defined.</span>
                <span class="k">for</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">observable</span><span class="o">.</span><span class="n">walk_tree</span><span class="p">(</span><span class="n">walk_down</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

                    <span class="c1"># If the parent is already in the mapping, make sure it is the</span>
                    <span class="c1"># same</span>
                    <span class="k">if</span> <span class="n">parent</span><span class="o">.</span><span class="n">model_varname</span> <span class="ow">in</span> <span class="n">model_varname_to_object</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">model_varname_to_object</span><span class="p">[</span><span class="n">parent</span><span class="o">.</span><span class="n">model_varname</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">model_varname_to_object</span><span class="p">[</span><span class="n">parent</span><span class="o">.</span><span class="n">model_varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>

            <span class="k">return</span> <span class="n">model_varname_to_object</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">record_transformed_data</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Updates the mapping with all transformed data components.&quot;&quot;&quot;</span>

            <span class="c1"># Add all TransformedData instances to the mapping</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">model_varname_to_object</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">_children</span><span class="p">:</span>  <span class="c1"># pylint: disable=protected-access</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">child</span><span class="p">,</span>
                        <span class="n">transformed_data</span><span class="o">.</span><span class="n">TransformedData</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="k">assert</span> <span class="n">child</span><span class="o">.</span><span class="n">model_varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_varname_to_object</span>
                        <span class="n">model_varname_to_object</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">model_varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span>

        <span class="c1"># Run the steps</span>
        <span class="n">model_varname_to_object</span> <span class="o">=</span> <span class="n">build_initial_mapping</span><span class="p">()</span>
        <span class="n">record_transformed_data</span><span class="p">()</span>

        <span class="c1"># There can be no duplicate values in the mapping</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_varname_to_object</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">model_varname_to_object</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">model_varname_to_object</span>

<div class="viewcode-block" id="Model.get_dimname_map">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.get_dimname_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimname_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate mapping from dimension specifications to dimension names.</span>

<span class="sd">        This method creates a dictionary that maps dimension level and size</span>
<span class="sd">        tuples to appropriate dimension names for xarray dataset construction.</span>
<span class="sd">        It ensures dimension names don&#39;t conflict with model variable names.</span>

<span class="sd">        :returns: Dictionary mapping (level, size) tuples to dimension names</span>
<span class="sd">        :rtype: dict[tuple[custom_types.Integer, custom_types.Integer], str]</span>

<span class="sd">        The mapping is used to create consistent dimension naming across</span>
<span class="sd">        all xarray datasets generated from model samples, ensuring proper</span>
<span class="sd">        coordinate alignment and data structure.</span>

<span class="sd">        Only dimensions with size &gt; 1 are assigned names, as singleton</span>
<span class="sd">        dimensions are typically squeezed during xarray construction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up variables</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># The list of dimension options cannot overlap with variable names</span>
        <span class="n">allowed_dim_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">DEFAULT_DIM_NAMES</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_model_components_dict</span>
        <span class="p">]</span>

        <span class="c1"># Check sizes of all observables and record the dimension names. Dimensions</span>
        <span class="c1"># of size &#39;1&#39; are not named as we do not need to distinguish them in an xarray</span>
        <span class="k">for</span> <span class="n">observable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_model_components</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dimkey</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observable</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">dimkey</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="n">dimkey</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dims</span><span class="p">[</span><span class="n">dimkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">allowed_dim_names</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">dims</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compress_for_xarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">include_sample_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process arrays for xarray dataset construction with proper dimension naming.</span>

<span class="sd">        This method transforms numpy arrays into the format required for xarray</span>
<span class="sd">        dataset construction, including appropriate dimension naming and</span>
<span class="sd">        singleton dimension handling.</span>

<span class="sd">        :param arrays: Arrays to process for xarray construction</span>
<span class="sd">        :type arrays: npt.NDArray</span>
<span class="sd">        :param include_sample_dim: Whether to include sample dimension in naming.</span>
<span class="sd">                                  Defaults to False.</span>
<span class="sd">        :type include_sample_dim: bool</span>

<span class="sd">        :returns: List of (dimension_names, processed_array) tuples</span>
<span class="sd">        :rtype: list[tuple[tuple[str, ...], npt.NDArray]]</span>

<span class="sd">        :raises ValueError: If array dimensions don&#39;t match expected model structure</span>

<span class="sd">        The method:</span>
<span class="sd">        - Identifies and removes singleton dimensions</span>
<span class="sd">        - Assigns appropriate dimension names based on model structure</span>
<span class="sd">        - Handles sample dimensions for drawn data (e.g., from prior predictive checks)</span>
<span class="sd">        - Ensures dimensional consistency across all processed arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get a mapping from dimension keys to dimension names</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimname_map</span><span class="p">()</span>

        <span class="c1"># Set our start and end indices for the shape</span>
        <span class="n">start_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">include_sample_dim</span><span class="p">)</span>

        <span class="c1"># Process each input array</span>
        <span class="n">processed</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">array_ind</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>

            <span class="c1"># Identify singleton dimensions and named dimensions</span>
            <span class="n">singleton_axes</span><span class="p">,</span> <span class="n">dimnames</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">effective_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">dimind</span><span class="p">,</span> <span class="n">dimsize</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">effective_shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">forward_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">effective_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dimind</span> <span class="o">+</span> <span class="n">start_ind</span>
                <span class="k">if</span> <span class="n">dimsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">singleton_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">forward_ind</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dimnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dims</span><span class="p">[(</span><span class="n">dimind</span><span class="p">,</span> <span class="n">dimsize</span><span class="p">)])</span>
                    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;There is no dimension index of </span><span class="si">{</span><span class="n">forward_ind</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_ind</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;with size </span><span class="si">{</span><span class="n">dimsize</span><span class="si">}</span><span class="s2"> in this model. Error triggered &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;by array </span><span class="si">{</span><span class="n">array_ind</span><span class="si">}</span><span class="s2">. Options are: </span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">error</span>

            <span class="c1"># Append &quot;n&quot; to the dimension names if we are including the sample dimension</span>
            <span class="k">if</span> <span class="n">include_sample_dim</span><span class="p">:</span>
                <span class="n">dimnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>

            <span class="c1"># Squeeze the array</span>
            <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dimnames</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">singleton_axes</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">processed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dict_to_xarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">draws</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert model component draws dictionary to structured xarray Dataset.</span>

<span class="sd">        This method transforms a dictionary of model component draws into a</span>
<span class="sd">        properly structured xarray Dataset with appropriate coordinates</span>
<span class="sd">        and dimension names for analysis and visualization.</span>

<span class="sd">        :param draws: Dictionary mapping components to their sampled values</span>
<span class="sd">        :type draws: dict[abstract_model_component.AbstractModelComponent, npt.NDArray]</span>

<span class="sd">        :returns: Structured dataset with draws and coordinates</span>
<span class="sd">        :rtype: xr.Dataset</span>

<span class="sd">        The resulting dataset includes:</span>
<span class="sd">        - Data variables for all non-constant components</span>
<span class="sd">        - Coordinates for multi-dimensional constants</span>
<span class="sd">        - Proper dimension naming and alignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Split into components and draws and components and values</span>
        <span class="n">model_comps</span><span class="p">,</span> <span class="n">unpacked_draws</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="p">[</span><span class="n">comp</span><span class="p">,</span> <span class="n">draw</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="n">draws</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_model_components</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">parents</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parents</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parents</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">coordinates</span>

        <span class="c1"># Process the draws and values for xarray. Note that because constants</span>
        <span class="c1"># have no sample prefix, we do not add the sampling dimension to them</span>
        <span class="c1"># when calling `compress_for_xarray` (i.e., we do not use `_n`).</span>
        <span class="n">compressed_draws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress_for_xarray</span><span class="p">(</span>
            <span class="o">*</span><span class="n">unpacked_draws</span><span class="p">,</span> <span class="n">include_sample_dim</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">compressed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress_for_xarray</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Build kwargs</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="n">data_vars</span><span class="o">=</span><span class="p">{</span>
                <span class="n">component</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">compressed_draw</span>
                <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">compressed_draw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_comps</span><span class="p">,</span> <span class="n">compressed_draws</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">compressed_value</span>
                <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">compressed_value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">compressed_values</span><span class="p">)</span>
            <span class="p">},</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">named_only</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">as_xarray</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">named_only</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">as_xarray</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">named_only</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">as_xarray</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">named_only</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">as_xarray</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="Model.draw">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.draw">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">named_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">as_xarray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw samples from the model&#39;s prior distribution.</span>

<span class="sd">        This method generates samples from all observable parameters in the</span>
<span class="sd">        model by traversing the dependency graph and sampling from each</span>
<span class="sd">        component&#39;s distribution in topological order.</span>

<span class="sd">        :param n: Number of samples to draw from each observable</span>
<span class="sd">        :type n: custom_types.Integer</span>
<span class="sd">        :param named_only: Whether to return only named components. Defaults to True.</span>
<span class="sd">        :type named_only: bool</span>
<span class="sd">        :param as_xarray: Whether to return results as xarray Dataset. Defaults to False.</span>
<span class="sd">        :type as_xarray: bool</span>
<span class="sd">        :param seed: Random seed for reproducible sampling. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Sampled values in requested format</span>
<span class="sd">        :rtype: Union[dict[str, npt.NDArray], dict[AbstractModelComponent, npt.NDArray], xr.Dataset]</span>

<span class="sd">        The method automatically handles:</span>
<span class="sd">        - Dependency resolution between model components</span>
<span class="sd">        - Consistent random number generation with optional seeding</span>
<span class="sd">        - Efficient sampling by reusing intermediate results</span>
<span class="sd">        - Format conversion based on return type preferences</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Draw 1000 samples as dictionary</span>
<span class="sd">            &gt;&gt;&gt; samples = model.draw(1000)</span>
<span class="sd">            &gt;&gt;&gt; # Draw 1000 samples as an xarray Dataset</span>
<span class="sd">            &gt;&gt;&gt; dataset = model.draw(1000, as_xarray=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Draw from all observables</span>
        <span class="n">draws</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">observable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">draws</span> <span class="o">=</span> <span class="n">observable</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">_drawn</span><span class="o">=</span><span class="n">draws</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Filter down to just named parameters if requested</span>
        <span class="k">if</span> <span class="n">named_only</span><span class="p">:</span>
            <span class="n">draws</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">draws</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_named</span><span class="p">}</span>

        <span class="c1"># Convert to an xarray dataset if requested</span>
        <span class="k">if</span> <span class="n">as_xarray</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_to_xarray</span><span class="p">(</span><span class="n">draws</span><span class="p">)</span>

        <span class="c1"># If we are returning only named parameters, then we need to update the</span>
        <span class="c1"># dictionary keys to be the model variable names.</span>
        <span class="k">if</span> <span class="n">named_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">draws</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">draws</span></div>


<div class="viewcode-block" id="Model.to_pytorch">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.to_pytorch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_pytorch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;nn_module.PyTorchModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile the model to a trainable PyTorch module.</span>

<span class="sd">        This method converts the SciStanPy model into a PyTorch module that</span>
<span class="sd">        can be optimized using standard PyTorch training procedures for</span>
<span class="sd">        maximum likelihood estimation or variational inference. The inputs to this</span>
<span class="sd">        module (i.e., the inputs to its `forward` method) are all observed data;</span>
<span class="sd">        the output is the likelihood of that data given the current model parameters.</span>

<span class="sd">        :param seed: Random seed for reproducible compilation. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Compiled PyTorch model ready for training</span>
<span class="sd">        :rtype: nn_module.PyTorchModel</span>

<span class="sd">        The compiled model preserves the probabilistic structure while</span>
<span class="sd">        enabling gradient-based optimization of model parameters. It&#39;s</span>
<span class="sd">        particularly useful for maximum likelihood estimation and can</span>
<span class="sd">        leverage GPU acceleration for large models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nn_module</span><span class="o">.</span><span class="n">PyTorchModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model.to_stan">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.to_stan">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_stan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;stan_model.StanModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile the model to Stan code for MCMC sampling.</span>

<span class="sd">        This method automatically generates Stan probabilistic programming</span>
<span class="sd">        language code from the SciStanPy model specification and compiles</span>
<span class="sd">        it for Hamilitonian Monte-Carlo sampling.</span>

<span class="sd">        :param kwargs: Additional compilation options passed to StanModel</span>

<span class="sd">        :returns: Compiled Stan model ready for MCMC sampling</span>
<span class="sd">        :rtype: stan_model.StanModel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">stan_model</span><span class="o">.</span><span class="n">StanModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model.mle">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.mle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span> <span class="o">=</span> <span class="n">DEFAULT_N_EPOCHS</span><span class="p">,</span>
        <span class="n">early_stop</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span> <span class="o">=</span> <span class="n">DEFAULT_EARLY_STOP</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">:</span> <span class="s2">&quot;custom_types.Float&quot;</span> <span class="o">=</span> <span class="n">DEFAULT_LR</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="s2">&quot;custom_types.Integer&quot;</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mixed_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;mle_module.MLE&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute maximum likelihood estimates of model parameters.</span>

<span class="sd">        This method fits a PyTorch model to observed data by minimizing</span>
<span class="sd">        the negative log-likelihood, providing point estimates of all</span>
<span class="sd">        model parameters along with optimization diagnostics.</span>

<span class="sd">        :param epochs: Maximum number of training epochs. Note that one step is one</span>
<span class="sd">            epoch as the model must be evaluated over all observable data to calculate</span>
<span class="sd">            loss. Defaults to 100000.</span>
<span class="sd">        :type epochs: custom_types.Integer</span>
<span class="sd">        :param early_stop: Epochs without improvement before stopping. Defaults to 10.</span>
<span class="sd">        :type early_stop: custom_types.Integer</span>
<span class="sd">        :param lr: Learning rate for optimization. Defaults to 0.001.</span>
<span class="sd">        :type lr: custom_types.Float</span>
<span class="sd">        :param data: Observed data for observables. Uses default_data provided at</span>
<span class="sd">            initialization if not provided.</span>
<span class="sd">        :type data: Optional[dict[str, Union[torch.Tensor, npt.NDArray]]]</span>
<span class="sd">        :param device: Computation device (&#39;cpu&#39;, &#39;cuda&#39;, or device index). Defaults to &#39;cpu&#39;.</span>
<span class="sd">        :type device: Union[custom_types.Integer, str]</span>
<span class="sd">        :param seed: Random seed for reproducible optimization. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>
<span class="sd">        :param mixed_precision: Whether to use mixed precision training. Defaults to False.</span>
<span class="sd">        :type mixed_precision: bool</span>

<span class="sd">        :returns: MLE results with parameter estimates and diagnostics</span>
<span class="sd">        :rtype: mle_module.MLE</span>

<span class="sd">        The optimization process:</span>

<span class="sd">        - Converts model to PyTorch and moves to specified device</span>
<span class="sd">        - Trains for `epochs` number of epochs or until there has been no improvement</span>
<span class="sd">          for `early_stop` number epochs.</span>
<span class="sd">        - Tracks loss trajectory for convergence assessment</span>
<span class="sd">        - Returns parameter estimates and fitted distributions</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Basic MLE with default settings</span>
<span class="sd">            &gt;&gt;&gt; mle_result = model.mle(data=observed_data)</span>
<span class="sd">            &gt;&gt;&gt; # GPU-accelerated with custom settings</span>
<span class="sd">            &gt;&gt;&gt; mle_result = model.mle(data=obs, device=&#39;cuda&#39;, epochs=50000, lr=0.01)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the default value for observed data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span>

        <span class="c1"># Observed data to tensors and the appropriate device</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Check observed data</span>
        <span class="n">nn_module</span><span class="o">.</span><span class="n">check_observable_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Fit the model</span>
        <span class="n">pytorch_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pytorch</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">loss_trajectory</span> <span class="o">=</span> <span class="n">pytorch_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stop</span><span class="o">=</span><span class="n">early_stop</span><span class="p">,</span>
            <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">mixed_precision</span><span class="o">=</span><span class="n">mixed_precision</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get the MLE estimate for all model parameters</span>
        <span class="n">max_likelihood</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytorch_model</span><span class="o">.</span><span class="n">export_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Get the distributions of the parameters</span>
        <span class="n">distributions</span> <span class="o">=</span> <span class="n">pytorch_model</span><span class="o">.</span><span class="n">export_distributions</span><span class="p">()</span>

        <span class="c1"># Return the MLE estimate, the distributions, and the loss trajectory</span>
        <span class="k">return</span> <span class="n">mle_module</span><span class="o">.</span><span class="n">MLE</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">mle_estimate</span><span class="o">=</span><span class="n">max_likelihood</span><span class="p">,</span>
            <span class="n">distributions</span><span class="o">=</span><span class="n">distributions</span><span class="p">,</span>
            <span class="n">losses</span><span class="o">=</span><span class="n">loss_trajectory</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_simulation_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate simulated observable data from model prior.</span>

<span class="sd">        This internal method draws a single realization from each observable</span>
<span class="sd">        parameter in the model using the current prior specification. It is</span>
<span class="sd">        used by simulation methods to generate synthetic datasets.</span>

<span class="sd">        :param seed: Random seed for reproducible simulation</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Dictionary mapping observable names to simulated values</span>
<span class="sd">        :rtype: dict[str, npt.NDArray]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">named_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">as_xarray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">observable</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">observable</span><span class="o">.</span><span class="n">model_varname</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">observable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span>
        <span class="p">}</span>

<div class="viewcode-block" id="Model.simulate_mle">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.simulate_mle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_mle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span> <span class="s2">&quot;mle_module.MLE&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate data from model prior and fit via maximum likelihood.</span>

<span class="sd">        This method performs a complete simulation study by first generating</span>
<span class="sd">        synthetic data from the model&#39;s prior distribution, then fitting</span>
<span class="sd">        the model to this simulated data using maximum likelihood estimation.</span>

<span class="sd">        :param kwargs: Keyword arguments passed to mle() method (except &#39;data&#39;)</span>

<span class="sd">        :returns: Tuple of (simulated_data, mle_results)</span>
<span class="sd">        :rtype: tuple[dict[str, npt.NDArray], mle_module.MLE]</span>

<span class="sd">        This is particularly useful for:</span>
<span class="sd">        - Model validation and debugging</span>
<span class="sd">        - Assessing parameter identifiability (e.g. by running multiple simulations)</span>
<span class="sd">        - Verifying implementation correctness</span>

<span class="sd">        The simulated data is automatically passed to the MLE fitting</span>
<span class="sd">        procedure, overriding any data specification in kwargs.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Simulate and fit with custom settings</span>
<span class="sd">            &gt;&gt;&gt; sim_data, mle_fit = model.simulate_mle(epochs=10000, lr=0.01)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This and the other simulate method should include non-observables</span>
        <span class="c1"># in the returned MLE as well.</span>
        <span class="c1"># Get the data</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_simulation_data</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">))</span>

        <span class="c1"># Fit the model</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mle</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mcmc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">force_compile</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">stanc_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">cpp_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">user_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">inits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]],</span>
        <span class="n">delay_run</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="o">**</span><span class="n">sample_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;hmc_results.SampleResults&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mcmc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">force_compile</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">stanc_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">cpp_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">user_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">inits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]],</span>
        <span class="n">delay_run</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">**</span><span class="n">sample_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="Model.mcmc">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.mcmc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mcmc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_compile</span><span class="o">=</span><span class="n">DEFAULT_FORCE_COMPILE</span><span class="p">,</span>
        <span class="n">stanc_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cpp_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">user_header</span><span class="o">=</span><span class="n">DEFAULT_USER_HEADER</span><span class="p">,</span>
        <span class="n">model_name</span><span class="o">=</span><span class="n">DEFAULT_MODEL_NAME</span><span class="p">,</span>
        <span class="n">inits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delay_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">sample_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform Hamiltonia Monte Carlo sampling using Stan backend.</span>

<span class="sd">        This method compiles the model to Stan and executes Hamiltonian</span>
<span class="sd">        Monte Carlo sampling to generate posterior samples. It supports</span>
<span class="sd">        both immediate execution and delayed runs for batch processing.</span>

<span class="sd">        :param output_dir: Directory for compilation and output files. Defaults to None,</span>
<span class="sd">            in which case all raw outputs will be saved to a temporary directory and</span>
<span class="sd">            be accessible only for the lifetime of this Python process.</span>
<span class="sd">        :type output_dir: Optional[str]</span>
<span class="sd">        :param force_compile: Whether to force recompilation of Stan model. Defaults</span>
<span class="sd">            to False.</span>
<span class="sd">        :type force_compile: bool</span>
<span class="sd">        :param stanc_options: Options for Stan compiler. Defaults to None (uses</span>
<span class="sd">            DEFAULT_STANC_OPTIONS).</span>
<span class="sd">        :type stanc_options: Optional[dict[str, Any]]</span>
<span class="sd">        :param cpp_options: Options for C++ compilation. Defaults to None (uses</span>
<span class="sd">            DEFAULT_CPP_OPTIONS).</span>
<span class="sd">        :type cpp_options: Optional[dict[str, Any]]</span>
<span class="sd">        :param user_header: Custom C++ header code. Defaults to None.</span>
<span class="sd">        :type user_header: Optional[str]</span>
<span class="sd">        :param model_name: Name for compiled model. Defaults to &#39;model&#39;.</span>
<span class="sd">        :type model_name: Optional[str]</span>
<span class="sd">        :param inits: Initialization strategy. See `stan_model.StanModel`</span>
<span class="sd">            for options. Defaults to None.</span>
<span class="sd">        :type inits: Optional[str]</span>
<span class="sd">        :param data: Observed data for observables. Uses default_data defined during</span>
<span class="sd">            initialization if not provided.</span>
<span class="sd">        :type data: Optional[dict[str, npt.NDArray]]</span>
<span class="sd">        :param delay_run: Whether to delay execution. If `True`, a pickle file that</span>
<span class="sd">            can be used for delayed execution will be saved to `output_dir`. A string</span>
<span class="sd">            can also be provided to save the pickle file to an alternate location.</span>
<span class="sd">            Defaults to False (meaning immediate execution).</span>
<span class="sd">        :type delay_run: Union[bool, str]</span>
<span class="sd">        :param sample_kwargs: Additional arguments passed to Stan sampling. See</span>
<span class="sd">            the `cmdstanpy.CmdStanModel.sample` for options.</span>


<span class="sd">        :returns: MCMC results if delay_run=False, None if delayed</span>
<span class="sd">        :rtype: Union[hmc_results.SampleResults, None]</span>

<span class="sd">        :raises ValueError: If delay_run is True but output_dir is None</span>

<span class="sd">        Delayed Execution:</span>
<span class="sd">        When delay_run=True, the method saves sampling configuration to a</span>
<span class="sd">        pickle file instead of executing immediately. This enables batch</span>
<span class="sd">        processing and distributed computing workflows.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Immediate MCMC sampling</span>
<span class="sd">            &gt;&gt;&gt; results = model.mcmc(chains=4, iter_sampling=2000)</span>
<span class="sd">            &gt;&gt;&gt; # Delayed execution for batch processing</span>
<span class="sd">            &gt;&gt;&gt; model.mcmc(delay_run=&#39;batch_job.pkl&#39;, chains=8, iter_sampling=5000)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the default observed data and cpp options</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span>
        <span class="n">stanc_options</span> <span class="o">=</span> <span class="n">stanc_options</span> <span class="ow">or</span> <span class="n">DEFAULT_STANC_OPTIONS</span>
        <span class="n">cpp_options</span> <span class="o">=</span> <span class="n">cpp_options</span> <span class="ow">or</span> <span class="n">DEFAULT_CPP_OPTIONS</span>

        <span class="c1"># An output directory must be provided if we are delaying the run</span>
        <span class="k">if</span> <span class="n">delay_run</span> <span class="ow">and</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;An output directory must be provided if `delay_run` is True.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Build the Stan model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_stan</span><span class="p">(</span>
            <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span>
            <span class="n">force_compile</span><span class="o">=</span><span class="n">force_compile</span><span class="p">,</span>
            <span class="n">stanc_options</span><span class="o">=</span><span class="n">stanc_options</span><span class="p">,</span>
            <span class="n">cpp_options</span><span class="o">=</span><span class="n">cpp_options</span><span class="p">,</span>
            <span class="n">user_header</span><span class="o">=</span><span class="n">user_header</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update the output directory in the sample kwargs</span>
        <span class="n">sample_kwargs</span><span class="p">[</span><span class="s2">&quot;output_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># If delaying, then we save the data needed for sampling and return</span>
        <span class="k">if</span> <span class="n">delay_run</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">delay_run</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delay_run</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">stan_executable_path</span><span class="si">}</span><span class="s2">-delay.pkl&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;wb&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;stan_model&quot;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
                        <span class="s2">&quot;sample_kwargs&quot;</span><span class="p">:</span> <span class="n">sample_kwargs</span><span class="p">,</span>
                        <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span>
                        <span class="s2">&quot;inits&quot;</span><span class="p">:</span> <span class="n">inits</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">f</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Sample from the model</span>
        <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">inits</span><span class="o">=</span><span class="n">inits</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">sample_kwargs</span><span class="p">)</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_mcmc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">delay_run</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span> <span class="s2">&quot;hmc_results.SampleResults&quot;</span><span class="p">]:</span> <span class="o">...</span>
    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay_run</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="Model.simulate_mcmc">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.simulate_mcmc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate data from model prior and perform Hamiltonian Monte Carlo sampling.</span>

<span class="sd">        This method generates synthetic data from the model&#39;s prior</span>
<span class="sd">        distribution and then performs full Bayesian inference via MCMC.</span>
<span class="sd">        It&#39;s extremely helpful for model validation and posterior recovery testing.</span>

<span class="sd">        :param delay_run: Whether to delay MCMC execution. Defaults to False.</span>
<span class="sd">        :type delay_run: bool</span>
<span class="sd">        :param kwargs: Additional keyword arguments passed to mcmc() method</span>

<span class="sd">        :returns: Tuple of (simulated_data, mcmc_results) if delay_run=False,</span>
<span class="sd">                 None if delay_run=True</span>
<span class="sd">        :rtype: Union[tuple[dict[str, npt.NDArray], hmc_results.SampleResults], None]</span>

<span class="sd">        The method automatically updates the model name to indicate</span>
<span class="sd">        simulation when using the default name, helping distinguish</span>
<span class="sd">        simulated from real data analyses.</span>

<span class="sd">        This is crucial for:</span>
<span class="sd">        - Validating MCMC implementation correctness</span>
<span class="sd">        - Testing posterior recovery in known-truth scenarios</span>
<span class="sd">        - Assessing sampler efficiency and convergence</span>
<span class="sd">        - Debugging model specification issues</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Simulate and sample with immediate execution</span>
<span class="sd">            &gt;&gt;&gt; sim_data, mcmc_results = model.simulate_mcmc(chains=4, iter_sampling=1000)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the model name</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model_name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">DEFAULT_MODEL_NAME</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;model_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DEFAULT_MODEL_NAME</span><span class="si">}</span><span class="s2">-simulated&quot;</span>

        <span class="c1"># Get the data</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_simulation_data</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">))</span>

        <span class="c1"># Run MCMC</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span><span class="n">delay_run</span><span class="o">=</span><span class="n">delay_run</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model.prior_predictive">
<a class="viewcode-back" href="../../../api/model/model.html#scistanpy.model.model.Model.prior_predictive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prior_predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pn</span><span class="o">.</span><span class="n">Row</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create interactive prior predictive check visualization.</span>

<span class="sd">        This method generates an interactive dashboard for exploring the</span>
<span class="sd">        model&#39;s prior predictive distribution. Users can adjust model</span>
<span class="sd">        hyperparameters via sliders and immediately see how changes</span>
<span class="sd">        affect prior predictions.</span>

<span class="sd">        :param copy_model: Whether to copy model to avoid modifying original. Defaults</span>
<span class="sd">            to False, meaning the calling model is updated in place by changing</span>
<span class="sd">            slider values and clicking &quot;update model&quot;.</span>
<span class="sd">        :type copy_model: bool</span>

<span class="sd">        :returns: Panel dashboard with interactive prior predictive visualization</span>
<span class="sd">        :rtype: pn.Row</span>

<span class="sd">        The dashboard includes:</span>
<span class="sd">        - Sliders for all adjustable model hyperparameters</span>
<span class="sd">        - Multiple visualization modes (ECDF, KDE, violin, relationship plots)</span>
<span class="sd">        - Real-time updates as parameters are modified</span>
<span class="sd">        - Options for different grouping and display configurations</span>

<span class="sd">        This is useful for:</span>
<span class="sd">        - Prior specification and calibration</span>
<span class="sd">        - Understanding model behavior before data fitting</span>
<span class="sd">        - Identifying unrealistic prior assumptions</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Create interactive dashboard</span>
<span class="sd">            &gt;&gt;&gt; dashboard = model.prior_predictive()</span>
<span class="sd">            &gt;&gt;&gt; dashboard.servable()  # For web deployment</span>
<span class="sd">            &gt;&gt;&gt; # Or display in Jupyter notebook</span>
<span class="sd">            &gt;&gt;&gt; dashboard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the prior predictive object</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">prior_predictive_module</span><span class="o">.</span><span class="n">PriorPredictiveCheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_model</span><span class="o">=</span><span class="n">copy_model</span><span class="p">)</span>

        <span class="c1"># Return the plot</span>
        <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">display</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return comprehensive string representation of the model.</span>

<span class="sd">        :returns: Formatted string showing all model components organized by type</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The representation includes organized sections for:</span>
<span class="sd">        - Constants and hyperparameters</span>
<span class="sd">        - Transformed parameters</span>
<span class="sd">        - Regular parameters</span>
<span class="sd">        - Observable parameters</span>

<span class="sd">        Each section lists components with their specifications and</span>
<span class="sd">        current values, providing a complete overview of model structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all model components</span>
        <span class="n">model_comps</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Constants&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">el</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_model_components</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="s2">&quot;Transformed Parameters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_parameters</span><span class="p">,</span>
            <span class="s2">&quot;Parameters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
            <span class="s2">&quot;Observables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Combine representations from all model components</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">complist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">complist</span> <span class="ow">in</span> <span class="n">model_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">complist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paramname</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if model contains a component with the given name.</span>

<span class="sd">        :param paramname: Name of the model component to check</span>
<span class="sd">        :type paramname: str</span>

<span class="sd">        :returns: True if component exists, False otherwise</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; &#39;mu&#39; in model  # Check if parameter &#39;mu&#39; exists</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">paramname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">paramname</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve model component by name.</span>

<span class="sd">        :param paramname: Name of the model component to retrieve</span>
<span class="sd">        :type paramname: str</span>

<span class="sd">        :returns: The requested model component</span>
<span class="sd">        :rtype: abstract_model_component.AbstractModelComponent</span>

<span class="sd">        :raises KeyError: If component name doesn&#39;t exist</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; mu_param = model[&#39;mu&#39;]  # Get parameter named &#39;mu&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(mu_param.distribution)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span><span class="p">[</span><span class="n">paramname</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set model attribute with protection for model components.</span>

<span class="sd">        :param name: Attribute name to set</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: Value to assign to the attribute</span>
<span class="sd">        :type value: Any</span>

<span class="sd">        :raises AttributeError: If attempting to modify existing model component</span>
<span class="sd">            or add a new model component after initialization.</span>

<span class="sd">        This method prevents modification of model components after</span>
<span class="sd">        initialization to maintain model integrity and prevent</span>
<span class="sd">        accidental corruption of the dependency graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We cannot set attributes that are model components</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_model_varname_to_object&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Model components can only be set during initialization.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Otherwise, set the attribute</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the default observed data for model observables.</span>

<span class="sd">        :returns: Dictionary mapping observable names to their default data</span>
<span class="sd">        :rtype: dict[str, npt.NDArray] | None</span>

<span class="sd">        :raises ValueError: If default data has not been set</span>

<span class="sd">        Default data is used automatically by methods like mle() and mcmc()</span>
<span class="sd">        when no explicit data is provided, streamlining common workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_default_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Default data is not set. Please set the default data using &quot;</span>
                <span class="s2">&quot;`model.default_data = data`.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_data</span>

    <span class="nd">@default_data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set default observed data for model observables.</span>

<span class="sd">        :param data: Dictionary mapping observable names to their data, or None to clear</span>
<span class="sd">        :type data: dict[str, npt.NDArray] | None</span>

<span class="sd">        :raises ValueError: If data is missing required observable keys or contains extra keys</span>

<span class="sd">        The data dictionary must contain entries for all observable parameters</span>
<span class="sd">        in the model. Setting to None clears the default data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the default data if `None` is passed</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="c1"># If initialization is complete, the data must be a dictionary and we must</span>
        <span class="c1"># have all the appropriate keys. We skip this check if the model is not</span>
        <span class="c1"># initialized yet, as we do not know the model variable names yet.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_complete</span><span class="p">:</span>
            <span class="n">expected_keys</span> <span class="o">=</span> <span class="p">{</span><span class="n">comp</span><span class="o">.</span><span class="n">model_varname</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">missing_keys</span> <span class="o">:=</span> <span class="n">expected_keys</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The following keys are missing from the default data: </span><span class="si">{</span><span class="n">missing_keys</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">extra_keys</span> <span class="o">:=</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">expected_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The following keys are not expected in the data: </span><span class="si">{</span><span class="n">extra_keys</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Set the default data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_default_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the model has default data configured.</span>

<span class="sd">        :returns: True if default data is set, False otherwise</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        This property is useful for conditional logic that depends on</span>
<span class="sd">        whether default data is available for automatic use in methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_default_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">named_model_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all named model components.</span>

<span class="sd">        :returns: Tuple of named components</span>
<span class="sd">        :rtype: tuple[abstract_model_component.AbstractModelComponent, ...]</span>

<span class="sd">        Named components are those explicitly assigned as instance attributes</span>
<span class="sd">        during model construction, as opposed to intermediate components</span>
<span class="sd">        created automatically during dependency resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_named_model_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">named_model_components_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get named model components as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping variable names to named components</span>
<span class="sd">        :rtype: dict[str, abstract_model_component.AbstractModelComponent]</span>

<span class="sd">        This provides convenient access to named components by their</span>
<span class="sd">        string names for programmatic model inspection and manipulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_model_components</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_model_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all model components including unnamed intermediate components.</span>

<span class="sd">        :returns: Tuple of all components sorted by variable name</span>
<span class="sd">        :rtype: tuple[abstract_model_component.AbstractModelComponent, ...]</span>

<span class="sd">        This includes both explicitly named components and any intermediate</span>
<span class="sd">        components created during dependency resolution, providing complete</span>
<span class="sd">        visibility into the model&#39;s computational graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">model_varname</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_model_components_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all model components as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping variable names to all components</span>
<span class="sd">        :rtype: dict[str, abstract_model_component.AbstractModelComponent]</span>

<span class="sd">        This comprehensive mapping includes both named and intermediate</span>
<span class="sd">        components, enabling full programmatic access to the model structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_varname_to_object</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all non-observable parameters in the model.</span>

<span class="sd">        :returns: Tuple of parameter components that are not observables</span>
<span class="sd">        :rtype: tuple[parameters_module.Parameter, ...]</span>

<span class="sd">        These are the latent variables and hyperparameters that will be</span>
<span class="sd">        inferred during MCMC sampling or optimized during MLE fitting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">observable</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_model_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameter_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get non-observable parameters as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping names to non-observable parameters</span>
<span class="sd">        :rtype: dict[str, parameters_module.Parameter]</span>

<span class="sd">        Provides convenient named access to the model&#39;s latent parameters</span>
<span class="sd">        for inspection and programmatic manipulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get hyperparameters (parameters with only constant parents).</span>

<span class="sd">        :returns: Tuple of parameters that depend only on constants</span>
<span class="sd">        :rtype: tuple[parameters_module.Parameter, ...]</span>

<span class="sd">        Hyperparameters are the highest-level parameters in the model</span>
<span class="sd">        hierarchy, typically representing prior distribution parameters</span>
<span class="sd">        that are not derived from other random variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_hyperparameter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hyperparameter_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get hyperparameters as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping names to hyperparameters</span>
<span class="sd">        :rtype: dict[str, parameters_module.Parameter]</span>

<span class="sd">        Provides convenient access to the model&#39;s hyperparameters by name</span>
<span class="sd">        for prior specification and sensitivity analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hyperparameters</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_parameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">transformed_parameters_module</span><span class="o">.</span><span class="n">TransformedParameter</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all named transformed parameters in the model.</span>

<span class="sd">        :returns: Tuple of transformed parameter components</span>
<span class="sd">        :rtype: tuple[transformed_parameters_module.TransformedParameter, ...]</span>

<span class="sd">        Transformed parameters are deterministic functions of other model</span>
<span class="sd">        components, representing computed quantities like sums, products,</span>
<span class="sd">        or other mathematical transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">transformed_parameters_module</span><span class="o">.</span><span class="n">TransformedParameter</span>
                <span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">named_model_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_parameter_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">transformed_parameters_module</span><span class="o">.</span><span class="n">TransformedParameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get named transformed parameters as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping names to transformed parameters</span>
<span class="sd">        :rtype: dict[str, transformed_parameters_module.TransformedParameter]</span>

<span class="sd">        Enables convenient access to transformed parameters for model</span>
<span class="sd">        inspection and derived quantity analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_parameters</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all named constants in the model.</span>

<span class="sd">        :returns: Tuple of constant components</span>
<span class="sd">        :rtype: tuple[constants_module.Constant, ...]</span>

<span class="sd">        Constants represent fixed values and hyperparameter specifications</span>
<span class="sd">        that do not change during inference or optimization procedures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">named_model_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constant_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">constants_module</span><span class="o">.</span><span class="n">Constant</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get named constants as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping names to constant components</span>
<span class="sd">        :rtype: dict[str, constants_module.Constant]</span>

<span class="sd">        Provides convenient access to model constants for hyperparameter</span>
<span class="sd">        inspection and sensitivity analysis workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all observable parameters in the model (observables are always named).</span>

<span class="sd">        :returns: Tuple of parameters marked as observable</span>
<span class="sd">        :rtype: tuple[parameters_module.Parameter, ...]</span>

<span class="sd">        Observable parameters represent the data-generating components</span>
<span class="sd">        of the model - the variables for which observed data will be</span>
<span class="sd">        provided during inference procedures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">observable</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">named_model_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observable_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">parameters_module</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get observable parameters as a dictionary.</span>

<span class="sd">        :returns: Dictionary mapping names to observable parameters</span>
<span class="sd">        :rtype: dict[str, parameters_module.Parameter]</span>

<span class="sd">        Enables convenient access to observable parameters for data</span>
<span class="sd">        specification and model validation workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_comps_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">SciStanPy API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../scistanpy.html">scistanpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Microsoft Corporation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>