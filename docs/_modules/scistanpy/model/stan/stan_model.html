<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scistanpy.model.stan.stan_model &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scistanpy.model.stan.stan_model</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation.</span>
<span class="c1"># Licensed under the MIT license.</span>


<span class="sd">&quot;&quot;&quot;Stan probabilistic programming language integration and code generation.</span>

<span class="sd">This module provides the core functionality for translating SciStanPy models into</span>
<span class="sd">Stan probabilistic programming language code and managing the complete Stan</span>
<span class="sd">compilation and execution workflow. It handles automatic code generation,</span>
<span class="sd">compilation management, and provides enhanced interfaces to Stan&#39;s sampling</span>
<span class="sd">algorithms.</span>

<span class="sd">The module implements a code generation system that organizes SciStanPy model components</span>
<span class="sd">into proper Stan program structure, including automatic handling of dependency</span>
<span class="sd">relationships, loop optimization, and efficient Stan code patterns.</span>

<span class="sd">Users will not normally interact with this module directly. Instead, they will either</span>
<span class="sd">(1) use the :py:meth:`Model.to_stan() &lt;scistanpy.model.model.Model.to_stan&gt;` method</span>
<span class="sd">to convert a SciStanPy model to a :py:class:`~scistanpy.model.stan.stan_model.StanModel`</span>
<span class="sd">instance or (2) use this module implicitly when fitting a SciStanPy model via the</span>
<span class="sd">:py:meth:`Model.mcmc() &lt;scistanpy.model.model.Model.mcmc&gt;` method.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tempfile</span><span class="w"> </span><span class="kn">import</span> <span class="n">TemporaryDirectory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">ParamSpec</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">cmdstanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">CmdStanModel</span><span class="p">,</span> <span class="n">format_stan_file</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">scistanpy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.defaults</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_CPP_OPTIONS</span><span class="p">,</span>
    <span class="n">DEFAULT_FORCE_COMPILE</span><span class="p">,</span>
    <span class="n">DEFAULT_MODEL_NAME</span><span class="p">,</span>
    <span class="n">DEFAULT_INDEX_ORDER</span><span class="p">,</span>
    <span class="n">DEFAULT_STANC_OPTIONS</span><span class="p">,</span>
    <span class="n">DEFAULT_USER_HEADER</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model</span><span class="w"> </span><span class="kn">import</span> <span class="n">stan</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstract_model_component</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">parameters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.transformations</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">transformed_data</span><span class="p">,</span>
    <span class="n">transformed_parameters</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">custom_types</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.results&quot;</span><span class="p">)</span>

<span class="c1"># pylint: disable=too-many-lines</span>

<span class="c1"># Function for combining a list of Stan code lines</span>
<span class="n">DEFAULT_INDENTATION</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1"># Parameter and return types for decorated functions</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="StanCodeBase">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StanCodeBase</span><span class="p">(</span><span class="n">ABC</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for Stan code organization and generation.</span>

<span class="sd">    This class provides the foundational infrastructure for organizing and</span>
<span class="sd">    generating Stan code from SciStanPy model components. It implements a</span>
<span class="sd">    hierarchical structure that mirrors the nested scope organization</span>
<span class="sd">    required by Stan programs.</span>

<span class="sd">    :param parent_loop: Parent code block in the hierarchy, or `None` for root</span>
<span class="sd">    :type parent_loop: Optional[StanCodeBase]</span>

<span class="sd">    :ivar parent_loop: Reference to parent code block for hierarchical organization</span>

<span class="sd">    The class serves as both a container for model components and for-loop</span>
<span class="sd">    constructs, and as a code generator that can produce appropriate Stan</span>
<span class="sd">    syntax for different program blocks (model, transformed parameters, etc.).</span>

<span class="sd">    Key Features:</span>

<span class="sd">    - Hierarchical organization of code blocks and loops</span>
<span class="sd">    - Automatic Stan syntax generation for different program sections</span>
<span class="sd">    - Component filtering and organization based on block requirements</span>
<span class="sd">    - Proper indentation and formatting management</span>
<span class="sd">    - Loop optimization and combination capabilities</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_loop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;StanCodeBase&quot;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the Stan code base.&quot;&quot;&quot;</span>
        <span class="c1"># Initialize the list</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Record the parent loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span> <span class="o">=</span> <span class="n">parent_loop</span>

<div class="viewcode-block" id="StanCodeBase.recurse_for_loops">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.recurse_for_loops">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">recurse_for_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;StanForLoop&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate all for-loops in the program hierarchy.</span>

<span class="sd">        This method recursively traverses the code structure to yield all</span>
<span class="sd">        for-loop constructs, enabling comprehensive analysis and optimization</span>
<span class="sd">        of the loop structure.</span>

<span class="sd">        :yields: All StanForLoop instances in the hierarchy</span>
<span class="sd">        :rtype: Generator[StanForLoop, None, None]</span>

<span class="sd">        The traversal follows a depth-first pattern, yielding the current</span>
<span class="sd">        level before recursing into nested loops, ensuring proper processing</span>
<span class="sd">        order for loop optimization procedures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Yield this loop</span>
        <span class="k">yield</span> <span class="bp">self</span>

        <span class="c1"># Loop over all nested loops and yield from them as well</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested_loops</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">loop</span><span class="o">.</span><span class="n">recurse_for_loops</span><span class="p">()</span></div>


<div class="viewcode-block" id="StanCodeBase.recurse_model_components">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.recurse_model_components">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">recurse_model_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively generate all model components in the program.</span>

<span class="sd">        This method traverses the code structure to yield all SciStanPy</span>
<span class="sd">        model components.</span>

<span class="sd">        :yields: All model components in the code hierarchy</span>
<span class="sd">        :rtype: Generator[AbstractModelComponent, None, None]</span>

<span class="sd">        This is essential for global analysis of model structure, dependency</span>
<span class="sd">        validation, and code generation across all program blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="n">component</span><span class="o">.</span><span class="n">recurse_model_components</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">component</span><span class="p">,</span>
                    <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">component</span></div>


<div class="viewcode-block" id="StanCodeBase.get_parent_loop">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.get_parent_loop">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;StanCodeBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get ancestor loop at specified level in the hierarchy.</span>

<span class="sd">        This method navigates the loop hierarchy to retrieve a specific</span>
<span class="sd">        ancestor loop.</span>

<span class="sd">        :param n: Level in ancestry (0=root, -1=current)</span>
<span class="sd">        :type n: custom_types.Integer</span>

<span class="sd">        :returns: Ancestor loop at the specified level</span>
<span class="sd">        :rtype: StanCodeBase</span>

<span class="sd">        The method supports both positive indices (from root) and negative</span>
<span class="sd">        indices (from current level) for flexible hierarchy navigation.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_write_block</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">block_name</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;model&quot;</span><span class="p">,</span>
            <span class="s2">&quot;transformed_parameters&quot;</span><span class="p">,</span>
            <span class="s2">&quot;generated_quantities&quot;</span><span class="p">,</span>
            <span class="s2">&quot;transformed_data&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">declarations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for a specific program block.</span>

<span class="sd">        This method orchestrates the generation of complete Stan program</span>
<span class="sd">        blocks by filtering appropriate components, combining for-loops,</span>
<span class="sd">        and applying proper formatting and structure.</span>

<span class="sd">        :param block_name: Name of the Stan block to generate</span>
<span class="sd">        :type block_name: Literal[&quot;model&quot;, &quot;transformed_parameters&quot;, &quot;generated_quantities&quot;,</span>
<span class="sd">            &quot;transformed_data&quot;]</span>
<span class="sd">        :param declarations: Variable declarations for the block header. Defaults to empty.</span>
<span class="sd">        :type declarations: Union[str, tuple[str, ...]]</span>

<span class="sd">        :returns: Complete Stan code for the specified block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The method handles:</span>

<span class="sd">        - Component filtering based on block requirements</span>
<span class="sd">        - For-loop combination and optimization</span>
<span class="sd">        - Proper Stan syntax generation and formatting</span>
<span class="sd">        - Empty block handling and omission</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filter_generated_quantities</span><span class="p">(</span>
            <span class="n">nested_component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
                <span class="n">StanCodeBase</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
            <span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Filters hierarchy of loops for the generated quantities block. We take</span>
<span class="sd">            observables.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">nested_component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">nested_component</span><span class="o">.</span><span class="n">observable</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nested_component</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">)</span>

        <span class="c1"># Functions for filtering the tree</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">filter_model_transformed_params</span><span class="p">(</span>
            <span class="n">nested_component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
                <span class="n">StanCodeBase</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
            <span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Filters hierarchy of loops for the model and transformed parameters</span>
<span class="sd">            blocks. We take Parameters and named TransformedParameters.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">nested_component</span><span class="p">,</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">nested_component</span><span class="p">,</span> <span class="n">transformed_parameters</span><span class="o">.</span><span class="n">TransformedParameter</span>
                <span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">nested_component</span><span class="o">.</span><span class="n">is_named</span> <span class="ow">or</span> <span class="n">nested_component</span><span class="o">.</span><span class="n">force_name</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filter_transformed_data</span><span class="p">(</span>
            <span class="n">nested_component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
                <span class="n">StanCodeBase</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
            <span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Filters hierarchy of loops for the transformed data block. We take</span>
<span class="sd">            TransformedData only.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">nested_component</span><span class="p">,</span>
                <span class="p">(</span><span class="n">transformed_data</span><span class="o">.</span><span class="n">TransformedData</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filter_components</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">StanCodeBase</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]]</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Filters components to those we want and combines for-loops.&quot;&quot;&quot;</span>
            <span class="c1"># First combine for-loops at this level that are identical. First we filter.</span>
            <span class="c1"># Then, we iterate over and check for for loops with the same start and end</span>
            <span class="c1"># values that are next to one another and share the same parent loop. If</span>
            <span class="c1"># they do, we combine them.</span>
            <span class="n">filtered_components</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prev_loop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StanForLoop</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">current_component</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">filter_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>

                <span class="c1"># If the current component has no assignments, skip it. It has</span>
                <span class="c1"># no impact on this block.</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_component</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_index_names</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># If this is a for loop, perform a series of checks to see if we can</span>
                <span class="c1"># combine it with the previous loop (if there was one).</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_component</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">):</span>

                    <span class="c1"># Combine with the previous for-loop if it is compatible</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">prev_loop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="n">current_component</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">prev_loop</span><span class="o">.</span><span class="n">end</span>
                        <span class="ow">and</span> <span class="n">current_component</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="n">prev_loop</span><span class="o">.</span><span class="n">depth</span>
                    <span class="p">):</span>

                        <span class="c1"># Extend a copy of the previous loop with the current component</span>
                        <span class="n">combined_loop</span> <span class="o">=</span> <span class="n">prev_loop</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">combined_loop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>

                        <span class="c1"># Set the previous loop to the combined loop</span>
                        <span class="n">filtered_components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_loop</span>
                        <span class="n">prev_loop</span> <span class="o">=</span> <span class="n">combined_loop</span>
                        <span class="k">continue</span>

                    <span class="c1"># If not compatible, just set the previous loop to this one</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">prev_loop</span> <span class="o">=</span> <span class="n">current_component</span>

                <span class="c1"># If not a for-loop, there is no previous loop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_loop</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Record the current component</span>
                <span class="n">filtered_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">filtered_components</span>

        <span class="c1"># We need a dictionary that will map from block name to the prefix for the</span>
        <span class="c1"># block we are writing,</span>
        <span class="n">dispatcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="s2">&quot;get_target_incrementation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_inc_prefix</span><span class="p">,</span>
                <span class="s2">&quot;filter&quot;</span><span class="p">:</span> <span class="n">filter_model_transformed_params</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;transformed_parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="s2">&quot;get_transformation_assignment&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation_assi_prefix</span><span class="p">,</span>
                <span class="s2">&quot;filter&quot;</span><span class="p">:</span> <span class="n">filter_model_transformed_params</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;generated_quantities&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="s2">&quot;get_generated_quantities&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_quantities_prefix</span><span class="p">,</span>
                <span class="s2">&quot;filter&quot;</span><span class="p">:</span> <span class="n">filter_generated_quantities</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;transformed_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="s2">&quot;get_transformed_data_assignment&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data_prefix</span><span class="p">,</span>
                <span class="s2">&quot;filter&quot;</span><span class="p">:</span> <span class="n">filter_transformed_data</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="c1"># Get the function, prefix, and filter for the block</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">dispatcher</span><span class="p">[</span><span class="n">block_name</span><span class="p">][</span><span class="s2">&quot;func&quot;</span><span class="p">]</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">dispatcher</span><span class="p">[</span><span class="n">block_name</span><span class="p">][</span><span class="s2">&quot;prefix&quot;</span><span class="p">]</span>
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">dispatcher</span><span class="p">[</span><span class="n">block_name</span><span class="p">][</span><span class="s2">&quot;filter&quot;</span><span class="p">]</span>

        <span class="c1"># Get assignments and incrementations</span>
        <span class="n">assignments</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">assignment</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">filter_components</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">assignment</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_index_names</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># Null string if no assignments</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Get the number of non-for-loops in the program.</span>
        <span class="n">n_model_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_components</span><span class="p">)</span>

        <span class="c1"># Otherwise, combine lines, add a prefix, and finalize the line</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="n">prefix</span>
            <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">declarations</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">n_model_components</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalize_line</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="StanCodeBase.get_target_incrementation">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.get_target_incrementation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">_dummy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for model block `target` variable incrementation.</span>

<span class="sd">        :param _dummy: Unused parameter for interface compatibility. Defaults to None.</span>
<span class="sd">        :type _dummy: Optional[tuple[str, ...]]</span>

<span class="sd">        :returns: Stan code for model block.</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method generates the model block containing all log-probability (target)</span>
<span class="sd">        increment statements for parameters and observables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_block</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="StanCodeBase.get_transformation_assignment">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.get_transformation_assignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformation_assignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">declarations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for transformed parameters block.</span>

<span class="sd">        :param declarations: Variable declarations for the block</span>
<span class="sd">        :type declarations: Union[str, tuple[str, ...]]</span>

<span class="sd">        :returns: Stan code for transformed parameters block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the transformed parameters block containing all deterministic</span>
<span class="sd">        transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_block</span><span class="p">(</span><span class="s2">&quot;transformed_parameters&quot;</span><span class="p">,</span> <span class="n">declarations</span><span class="o">=</span><span class="n">declarations</span><span class="p">)</span></div>


<div class="viewcode-block" id="StanCodeBase.get_generated_quantities">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.get_generated_quantities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_generated_quantities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">declarations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for generated quantities block.</span>

<span class="sd">        :param declarations: Variable declarations for the block</span>
<span class="sd">        :type declarations: Union[str, tuple[str, ...]]</span>

<span class="sd">        :returns: Stan code for generated quantities block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the generated quantities block for posterior predictive</span>
<span class="sd">        sampling and derived quantity computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_block</span><span class="p">(</span><span class="s2">&quot;generated_quantities&quot;</span><span class="p">,</span> <span class="n">declarations</span><span class="o">=</span><span class="n">declarations</span><span class="p">)</span></div>


<div class="viewcode-block" id="StanCodeBase.get_transformed_data_assignment">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.get_transformed_data_assignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformed_data_assignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">declarations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for transformed data block.</span>

<span class="sd">        :param declarations: Variable declarations for the block</span>
<span class="sd">        :type declarations: Union[str, tuple[str, ...]]</span>

<span class="sd">        :returns: Stan code for transformed data block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the transformed data block for preprocessing and</span>
<span class="sd">        deterministic data transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_block</span><span class="p">(</span><span class="s2">&quot;transformed_data&quot;</span><span class="p">,</span> <span class="n">declarations</span><span class="o">=</span><span class="n">declarations</span><span class="p">)</span></div>


<div class="viewcode-block" id="StanCodeBase.finalize_line">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.finalize_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalize_line</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">indendation_level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply proper indentation and Stan syntax formatting to code lines.</span>

<span class="sd">        :param text: Raw code text to format</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :param indendation_level: Indentation level (uses current depth if None).</span>
<span class="sd">                                 Defaults to None.</span>
<span class="sd">        :type indendation_level: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Properly formatted Stan code line</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method handles:</span>

<span class="sd">        - Consistent indentation based on scope depth</span>
<span class="sd">        - Automatic semicolon insertion for statements</span>
<span class="sd">        - Proper formatting for control structures and comments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the indentation level</span>
        <span class="n">indendation_level</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="k">if</span> <span class="n">indendation_level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">indendation_level</span>
        <span class="p">)</span>

        <span class="c1"># Pad the input text with spaces</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DEFAULT_INDENTATION</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">indendation_level</span><span class="si">}{</span><span class="n">text</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Add a semicolon to the end if not a bracket or blank</span>
        <span class="k">if</span> <span class="n">text</span> <span class="ow">and</span> <span class="n">text</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
            <span class="n">formatted</span> <span class="o">+=</span> <span class="s2">&quot;;&quot;</span>

        <span class="k">return</span> <span class="n">formatted</span></div>


<div class="viewcode-block" id="StanCodeBase.combine_lines">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanCodeBase.combine_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">indentation_level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine multiple Stan code lines with proper formatting.</span>

<span class="sd">        :param lines: List of code lines to combine</span>
<span class="sd">        :type lines: list[str]</span>
<span class="sd">        :param indentation_level: Indentation level for all lines. Defaults to None.</span>
<span class="sd">        :type indentation_level: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Combined and formatted Stan code block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Applies consistent formatting and indentation to all provided lines,</span>
<span class="sd">        creating a properly structured Stan code block.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Nothing if no lines</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Combine the lines</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_line</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">indendation_level</span><span class="o">=</span><span class="n">indentation_level</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">lines</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nested_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all nested for-loops at this level.</span>

<span class="sd">        :returns: List of direct child for-loops</span>
<span class="sd">        :rtype: list[StanForLoop]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">component</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all model components at this level.</span>

<span class="sd">        :returns: List of direct child model components</span>
<span class="sd">        :rtype: list[AbstractModelComponent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">component</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the nesting depth of this code block.</span>

<span class="sd">        :returns: Depth level in the code hierarchy</span>
<span class="sd">        :rtype: custom_types.Integer</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allowed_index_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get allowed index variable names for this scope.</span>

<span class="sd">        :returns: Tuple of allowed index variable names</span>
<span class="sd">        :rtype: tuple[str, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">target_inc_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the prefix for model block target incrementation.</span>

<span class="sd">        :returns: Stan code prefix for model block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformation_assi_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the prefix for transformed parameters block.</span>

<span class="sd">        :returns: Stan code prefix for transformed parameters block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_quantities_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the prefix for generated quantities block.</span>

<span class="sd">        :returns: Stan code prefix for generated quantities block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_data_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the prefix for transformed data block.</span>

<span class="sd">        :returns: Stan code prefix for transformed data block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="StanForLoop">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanForLoop">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StanForLoop</span><span class="p">(</span><span class="n">StanCodeBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a Stan for-loop construct with optimization capabilities.</span>

<span class="sd">    This class manages individual for-loop constructs in Stan code, including</span>
<span class="sd">    automatic loop range determination, optimization through combination with</span>
<span class="sd">    compatible loops, and proper nesting within the code hierarchy.</span>

<span class="sd">    :param parent_loop: Parent code block containing this loop</span>
<span class="sd">    :type parent_loop: StanCodeBase</span>
<span class="sd">    :param record_in_parent: Whether to automatically add this loop to parent. Defaults to True.</span>
<span class="sd">    :type record_in_parent: bool</span>

<span class="sd">    :ivar parent_loop: Reference to parent code block</span>

<span class="sd">    Key Features:</span>

<span class="sd">    - Automatic loop range calculation based on component dimensions</span>
<span class="sd">    - Loop combination optimization for compatible adjacent loops</span>
<span class="sd">    - Singleton loop detection and elimination</span>
<span class="sd">    - Proper index variable management and scope resolution</span>
<span class="sd">    - Hierarchical ancestry tracking for scope navigation</span>

<span class="sd">    The class automatically determines loop ranges by analyzing the dimensions</span>
<span class="sd">    of nested model components and provides optimization features like loop</span>
<span class="sd">    combination to generate efficient Stan code.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_loop</span><span class="p">:</span> <span class="n">StanCodeBase</span><span class="p">,</span> <span class="n">record_in_parent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the for-loop.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: The index variable for the loop</span>
<span class="sd">            start: The starting value of the loop</span>
<span class="sd">            end: The ending value of the loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the list</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent_loop</span><span class="p">)</span>

        <span class="c1"># Append this loop to the parent loop if requested</span>
        <span class="k">if</span> <span class="n">record_in_parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_ancestry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">StanCodeBase</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the complete ancestry chain of this loop.</span>

<span class="sd">        :returns: List of ancestor code blocks from root to immediate parent</span>
<span class="sd">        :rtype: list[StanCodeBase]</span>

<span class="sd">        This method traces the hierarchy from the current loop back to the</span>
<span class="sd">        root program, enabling proper scope resolution and code organization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the parent is the program, we are at the top level and have only the</span>
        <span class="c1"># program as our ancestor</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="p">,</span> <span class="n">StanProgram</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="p">]</span>

        <span class="c1"># Otherwise, we have the parent loop and all of its ancestors</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="o">.</span><span class="n">ancestry</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="p">]</span>

<div class="viewcode-block" id="StanForLoop.get_parent_loop">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanForLoop.get_parent_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StanCodeBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get ancestor loop at specified level in the hierarchy.</span>

<span class="sd">        :param n: Ancestry level to retrieve (clipped to available range). For example,</span>
<span class="sd">            `0` returns the root loop; `-1` returns this loop.</span>
<span class="sd">        :type n: custom_types.Integer</span>

<span class="sd">        :returns: Ancestor loop at the specified level</span>
<span class="sd">        :rtype: StanCodeBase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clip n to the number of ancestors</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestry</span><span class="p">))</span>

        <span class="c1"># Get the appropriate loop</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestry</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">])[</span><span class="n">n</span><span class="p">]</span></div>


<div class="viewcode-block" id="StanForLoop.append">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanForLoop.append">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="s2">&quot;StanForLoop&quot;</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a component to this loop with depth validation.</span>

<span class="sd">        :param component: Component to add to the loop</span>
<span class="sd">        :type component: Union[StanForLoop, AbstractModelComponent]</span>

<span class="sd">        :raises AssertionError: If component depth doesn&#39;t match loop depth</span>

<span class="sd">        Ensures that only components with appropriate nesting depth are</span>
<span class="sd">        added to maintain proper Stan code structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a model component, make sure we are at the appropriate code level</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>

        <span class="c1"># Append the component</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span></div>


<div class="viewcode-block" id="StanForLoop.copy">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanForLoop.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_in_parent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;StanForLoop&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a shallow copy of this loop.</span>

<span class="sd">        :param record_in_parent: Whether to register copy with parent. Defaults to False.</span>
<span class="sd">        :type record_in_parent: bool</span>

<span class="sd">        :returns: New loop instance with same contents</span>
<span class="sd">        :rtype: StanForLoop</span>

<span class="sd">        Creates a copy with the same parent loop and components, useful for</span>
<span class="sd">        loop combination and optimization operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a new loop with the same parent loop</span>
        <span class="n">new_loop</span> <span class="o">=</span> <span class="n">StanForLoop</span><span class="p">(</span>
            <span class="n">parent_loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="p">,</span> <span class="n">record_in_parent</span><span class="o">=</span><span class="n">record_in_parent</span>
        <span class="p">)</span>

        <span class="c1"># Populate the new loop with the same components</span>
        <span class="n">new_loop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_loop</span></div>


<div class="viewcode-block" id="StanForLoop.squash">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanForLoop.squash">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">squash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove singleton loops by moving contents to parent.</span>

<span class="sd">        This optimization method detects when a loop has only one iteration</span>
<span class="sd">        (singleton) and eliminates the unnecessary loop construct by moving</span>
<span class="sd">        its contents directly to the parent scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the end is 1, we are a singleton loop. Move the contents of this loop</span>
        <span class="c1"># to the parent loop and then remove this loop from the parent loop.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the complete ancestry chain of this loop.</span>

<span class="sd">        :returns: List of ancestor code blocks from root to immediate parent</span>
<span class="sd">        :rtype: list[StanCodeBase]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ancestry</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the end value (iteration count) for this loop.</span>

<span class="sd">        :returns: Number of iterations for this loop</span>
<span class="sd">        :rtype: custom_types.Integer</span>

<span class="sd">        :raises ValueError: If components have incompatible dimension sizes</span>

<span class="sd">        Automatically determines loop range by analyzing the dimensions of</span>
<span class="sd">        all nested model components at the appropriate depth level. Handles</span>
<span class="sd">        dimension compatibility checking and singleton dimension filtering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the size of the dimension at the index level for all model components</span>
        <span class="c1"># nested in the loop</span>
        <span class="n">all_ends</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">component</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurse_model_components</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># If there are multiple options, remove 1s</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_ends</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_ends</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If there are still multiple options, raise an error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_ends</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid end values: </span><span class="si">{</span><span class="n">all_ends</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># The value must be 1 or greater</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">all_ends</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;StanProgram&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the root Stan program containing this loop.</span>

<span class="sd">        :returns: Root StanProgram instance</span>
<span class="sd">        :rtype: StanProgram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allowed_index_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get allowed index variable names from the root program.</span>

<span class="sd">        :returns: Tuple of allowed index variable names</span>
<span class="sd">        :rtype: tuple[str, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">allowed_index_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the nesting depth of this loop. This is equivalent to the number</span>
<span class="sd">        of ancestor loops.</span>

<span class="sd">        :returns: Depth level based on number of ancestors</span>
<span class="sd">        :rtype: custom_types.Integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_ancestors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestry</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_ancestors</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">n_ancestors</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loop_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the index variable name for this loop (e.g., &#39;i&#39; if loop construct</span>
<span class="sd">        is written as `for (i in 1:10) {`).</span>

<span class="sd">        :returns: Index variable name based on depth</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">allowed_index_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">target_inc_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Stan code prefix for model block loops.</span>

<span class="sd">        :returns: Stan for-loop syntax for model block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalize_line</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;for (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span><span class="si">}</span><span class="s2"> in 1:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">) </span><span class="se">{{</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformation_assi_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Stan code prefix for transformed parameters block loops.</span>

<span class="sd">        :returns: Stan for-loop syntax for transformed parameters block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_inc_prefix</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_quantities_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Stan code prefix for generated quantities block loops.</span>

<span class="sd">        :returns: Stan for-loop syntax for generated quantities block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_inc_prefix</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_data_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Stan code prefix for transformed data block loops.</span>

<span class="sd">        :returns: Stan for-loop syntax for transformed data block</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_inc_prefix</span></div>



<div class="viewcode-block" id="StanProgram">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StanProgram</span><span class="p">(</span><span class="n">StanCodeBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete Stan program generation and management.</span>

<span class="sd">    This class orchestrates the generation of complete Stan programs from</span>
<span class="sd">    SciStanPy models, handling dependency analysis, component organization,</span>
<span class="sd">    and the generation of all required Stan program blocks.</span>

<span class="sd">    :param model: SciStanPy model to convert to Stan</span>
<span class="sd">    :type model: scistanpy.Model</span>

<span class="sd">    :ivar model: Reference to the source SciStanPy model</span>
<span class="sd">    :ivar node_to_depth: Mapping from components to their hierarchy depth</span>
<span class="sd">    :ivar all_varnames: Set of all variable names in the program</span>
<span class="sd">    :ivar all_paramnames: Set of all parameter names</span>
<span class="sd">    :ivar autogathered_varnames: Set of variables whose data will be automatically</span>
<span class="sd">        gathered from the SciStanPy model.</span>
<span class="sd">    :ivar user_provided_varnames: Set of variables whose data the user must provide</span>
<span class="sd">        (i.e., the names of observable parameters).</span>

<span class="sd">    The class performs comprehensive analysis of the SciStanPy model to:</span>

<span class="sd">    - Build dependency graphs and determine component ordering</span>
<span class="sd">    - Generate appropriate variable names avoiding conflicts</span>
<span class="sd">    - Organize components into proper Stan program structure</span>
<span class="sd">    - Create optimized loop constructs for multi-dimensional components</span>
<span class="sd">    - Generate all required Stan program blocks with proper syntax</span>

<span class="sd">    The code is generated following the below procedure:</span>

<span class="sd">    1. Dependency Analysis: Build component dependency graph</span>
<span class="sd">    2. Depth Assignment: Determine nesting levels for components</span>
<span class="sd">    3. Loop Organization: Create optimized for-loop structures</span>
<span class="sd">    4. Block Generation: Generate all Stan program blocks</span>
<span class="sd">    5. Code Formatting: Apply Stan canonical formatting</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;scistanpy.Model&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes and compiles the Stan program.&quot;&quot;&quot;</span>
        <span class="c1"># Initialize the list</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Note the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># Build the map from model node to depth in the tree of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="nb">int</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_node_to_depth</span><span class="p">()</span>

        <span class="c1"># Get the names of all variables, parameters, and data inputs for the model</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_varnames</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_paramnames</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autogathered_varnames</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_provided_varnames</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_varnames</span><span class="p">()</span>

        <span class="c1"># Get allowed index variable names for each level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_index_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">char</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">DEFAULT_INDEX_ORDER</span>
            <span class="k">if</span> <span class="p">{</span><span class="n">char</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">upper</span><span class="p">()}</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_varnames</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Compile the program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>

<div class="viewcode-block" id="StanProgram.build_node_to_depth">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.build_node_to_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_node_to_depth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build mapping from model components to their maximum hierarchy depth.</span>

<span class="sd">        :returns: Dictionary mapping components to their depth levels</span>
<span class="sd">        :rtype: dict[AbstractModelComponent, int]</span>

<span class="sd">        This method analyzes the SciStanPy model&#39;s dependency graph to determine</span>
<span class="sd">        the maximum depth of each component relative to the root constants.</span>
<span class="sd">        This information is crucial for proper code ordering and loop organization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need a mapping from each node to its maximum depth in the tree.</span>
        <span class="n">node_to_depth</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Get all constants, named or otherwise</span>
        <span class="n">model_constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">all_model_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Starting from constants (which are all root nodes), walk down the tree</span>
        <span class="c1"># and record the depth of each node</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">model_constants</span><span class="p">:</span>

            <span class="c1"># Root nodes are at depth 0</span>
            <span class="n">node_to_depth</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Walk the tree rooted at this root and record the depth of each node</span>
            <span class="c1"># if it is higher than the current maximum depth</span>
            <span class="k">for</span> <span class="n">depth</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">walk_tree</span><span class="p">():</span>

                <span class="c1"># Record the maximum depth of this node</span>
                <span class="n">node_to_depth</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">node_to_depth</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">node_to_depth</span></div>


<div class="viewcode-block" id="StanProgram.get_varnames">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.get_varnames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_varnames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract and categorize all variable names from the model.</span>

<span class="sd">        :returns: Tuple of (all_varnames, all_paramnames, autogathered_varnames,</span>
<span class="sd">            user_provided_varnames)</span>
<span class="sd">        :rtype: tuple[set[str], set[str], set[str], set[str]]</span>

<span class="sd">        :raises ValueError: If variable name collisions are detected</span>

<span class="sd">        Analyzes the model to categorize variables into:</span>
<span class="sd">        - All variable names (for conflict detection)</span>
<span class="sd">        - Parameter names (for Stan parameters block)</span>
<span class="sd">        - Auto-gathered names (constants from model)</span>
<span class="sd">        - User-provided names (observables requiring external data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the names of all the variables in the model</span>
        <span class="n">name_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">model_varname</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collisions</span> <span class="o">:=</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">name_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name collisions for variables: </span><span class="si">{</span><span class="n">collisions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get all variable names and all parameter names</span>
        <span class="n">all_varnames</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">model_varname</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span><span class="p">}</span>
        <span class="n">all_paramnames</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">model_varname</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">observable</span>
        <span class="p">}</span>

        <span class="c1"># Get all data inputs</span>
        <span class="n">auto_gathered_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">model_varname</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">user_provided_varnames</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">model_varname</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">observable</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">all_varnames</span><span class="p">,</span> <span class="n">all_paramnames</span><span class="p">,</span> <span class="n">auto_gathered_data</span><span class="p">,</span> <span class="n">user_provided_varnames</span></div>


<div class="viewcode-block" id="StanProgram.get_parent_loop">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.get_parent_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StanCodeBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get parent loop (only self is available for root program).</span>

<span class="sd">        :param n: Must be -1 or 0 for root program</span>
<span class="sd">        :type n: custom_types.Integer</span>

<span class="sd">        :returns: Self (root program)</span>
<span class="sd">        :rtype: StanCodeBase</span>

<span class="sd">        :raises AssertionError: If n is not -1 or 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Can only get self</span>
        <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="StanProgram.compile">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Organize model components into proper Stan program structure.</span>

<span class="sd">        This method performs the core compilation process:</span>
<span class="sd">        1. Determines topological ordering of components based on dependencies</span>
<span class="sd">        2. Organizes components into appropriate loop structures</span>
<span class="sd">        3. Creates and optimizes for-loop constructs</span>
<span class="sd">        4. Eliminates singleton loops for efficiency</span>

<span class="sd">        The compilation process ensures that all dependencies are satisfied</span>
<span class="sd">        and that the resulting Stan code is properly structured and efficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the order of operations. This is a list of nodes sorted by their maximum</span>
        <span class="c1"># depth in the tree</span>
        <span class="n">order_of_operations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_depth</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">assign_depth</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># The first component in the order of operations must be at definition depth 0</span>
        <span class="k">assert</span> <span class="n">order_of_operations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Set up for compilation. We define the `target_loop`, which is the loop</span>
        <span class="c1"># to which components will be actively added. We also defined the `previous_component`,</span>
        <span class="c1"># which is the component one operation back.</span>
        <span class="n">target_loop</span><span class="p">:</span> <span class="n">StanCodeBase</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">previous_component</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Item one operation back</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">order_of_operations</span><span class="p">:</span>

            <span class="c1"># If the current or previous component is defined a depth 0, then the</span>
            <span class="c1"># program is the target loop. We will need to add as many for-loops</span>
            <span class="c1"># as we have levels of indentation in the current component.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">component</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">previous_component</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">component</span><span class="o">.</span><span class="n">FORCE_LOOP_RESET</span>
            <span class="p">):</span>
                <span class="n">target_loop</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">n_loops</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">assign_depth</span>

            <span class="c1"># In any other case, we need to determine which dimensions of the current</span>
            <span class="c1"># component are compatible with the previous component and find the</span>
            <span class="c1"># appropriate parent loop.</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># We need to determine the extent to which the shapes of the current</span>
                <span class="c1"># and previous components are compatible. This is the number of</span>
                <span class="c1"># shared leading dimensions between the two components&#39; shapes.</span>
                <span class="n">compat_level</span> <span class="o">=</span> <span class="n">previous_component</span><span class="o">.</span><span class="n">get_shared_leading</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">compat_level</span> <span class="o">&gt;=</span> <span class="mi">0</span>

                <span class="c1"># Get the parent loop of the current component that is compatible</span>
                <span class="c1"># with the the current component. Note that we also update our referenced</span>
                <span class="c1"># loop in this step. Note that the target loop must be a for-loop</span>
                <span class="c1"># at this point as the previous `if` block handles all cases where</span>
                <span class="c1"># the target loop is the program.</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_loop</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">)</span>
                <span class="n">target_loop</span> <span class="o">=</span> <span class="n">target_loop</span><span class="o">.</span><span class="n">get_parent_loop</span><span class="p">(</span><span class="n">compat_level</span><span class="p">)</span>

                <span class="c1"># How many for-loops do we need to add? The definition depth of</span>
                <span class="c1"># the current component must be greater than or equal to the depth</span>
                <span class="c1"># of the current loop</span>
                <span class="n">n_loops</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">-</span> <span class="n">target_loop</span><span class="o">.</span><span class="n">depth</span>
                <span class="k">assert</span> <span class="n">n_loops</span> <span class="o">&gt;=</span> <span class="mi">0</span>

            <span class="c1"># Add for-loops if necessary</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_loops</span><span class="p">):</span>
                <span class="n">target_loop</span> <span class="o">=</span> <span class="n">StanForLoop</span><span class="p">(</span><span class="n">parent_loop</span><span class="o">=</span><span class="n">target_loop</span><span class="p">)</span>

            <span class="c1"># Add the component to the target loop and update the previous component</span>
            <span class="n">target_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="n">previous_component</span> <span class="o">=</span> <span class="n">component</span>

        <span class="c1"># Squash any singletons</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurse_for_loops</span><span class="p">():</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">squash</span><span class="p">()</span>

        <span class="c1"># Remove all squashed loops</span>
        <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">component</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">StanForLoop</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">component</span><span class="o">.</span><span class="n">parent_loop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="StanProgram.recurse_for_loops">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.recurse_for_loops">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">recurse_for_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">StanForLoop</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate all for-loops in the program (excluding self).</span>

<span class="sd">        :yields: All StanForLoop instances in the program</span>
<span class="sd">        :rtype: Generator[StanForLoop, None, None]</span>

<span class="sd">        This method yields only the nested for-loops, not the program itself, which</span>
<span class="sd">        is different from the `StanForLoop` sibling class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested_loops</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">loop</span><span class="o">.</span><span class="n">recurse_for_loops</span><span class="p">()</span></div>


<div class="viewcode-block" id="StanProgram.append">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanProgram.append">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="s2">&quot;StanForLoop&quot;</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add component to program with depth validation.</span>

<span class="sd">        :param component: Component to add to the program</span>
<span class="sd">        :type component: Union[StanForLoop, AbstractModelComponent]</span>

<span class="sd">        :raises AssertionError: If component depth is not 0 (root level)</span>

<span class="sd">        Ensures only root-level components are added directly to the program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a model component, make sure we are at the appropriate depth</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">assign_depth</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Append the component</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the depth of the program (always 0 for root).</span>

<span class="sd">        :returns: Depth level (always 0)</span>
<span class="sd">        :rtype: custom_types.Integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">functions_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan functions block with custom function includes.</span>

<span class="sd">        :returns: Stan functions block code or empty string if no functions needed</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Automatically determines required supporting functions from model</span>
<span class="sd">        components and generates appropriate include statements and function</span>
<span class="sd">        definitions for the Stan functions block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all model components.</span>
        <span class="n">model_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">all_model_components</span><span class="p">)</span>

        <span class="c1"># If there is a MultinomialLogit component, remove all Multinomial components.</span>
        <span class="c1"># This is because the MultinomialLogit component will include the Multinomial</span>
        <span class="c1"># functions, so we don&#39;t need to include them again.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">MultinomialLogit</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">model_components</span>
        <span class="p">):</span>
            <span class="n">model_components</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">component</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">model_components</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Multinomial</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># Get all supporting functions</span>
        <span class="n">supporting_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">model_components</span><span class="p">:</span>
            <span class="n">supporting_functions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">())</span>

        <span class="c1"># There is no need to include a functions block if there are no functions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">supporting_functions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># No duplicates. Include statements first. Alphabetical after that.</span>
        <span class="n">supporting_functions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">supporting_functions</span><span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#include&quot;</span><span class="p">)),</span>
        <span class="p">)</span>

        <span class="c1"># Otherwise, we need to combine the lines and add a functions block</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;functions {</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">supporting_functions</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">}&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan data block with observable and constant declarations.</span>

<span class="sd">        :returns: Stan data block code</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the data block containing declarations for all observables</span>
<span class="sd">        (user-provided data) and constants (auto-gathered from model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the declarations for the data block. This is all observables and all</span>
        <span class="c1"># constants.</span>
        <span class="n">declarations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">component</span><span class="o">.</span><span class="n">get_stan_parameter_declaration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">all_model_components</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">component</span><span class="o">.</span><span class="n">observable</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Combine declarations and wrap in the data block</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;data {</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">}&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_data_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan transformed data block.</span>

<span class="sd">        :returns: Stan transformed data block code or empty string if not needed</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the transformed data block for any deterministic data</span>
<span class="sd">        transformations required by the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check parameters for any transformed data.</span>
        <span class="n">declarations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">component</span><span class="o">.</span><span class="n">get_stan_parameter_declaration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">all_model_components</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">TransformedData</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># No transformed data if no declarations</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declarations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Combine declarations</span>
        <span class="n">declaration_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Combine declarations and transformations</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transformed_data_assignment</span><span class="p">(</span><span class="n">declarations</span><span class="o">=</span><span class="n">declaration_block</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan parameters block with parameter declarations.</span>

<span class="sd">        :returns: Stan parameters block code</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the parameters block containing all model parameters that</span>
<span class="sd">        will be sampled during MCMC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Loop over all components recursively and define the parameters</span>
        <span class="n">declarations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>

            <span class="c1"># If the component is defined in raw form, we declare the raw variable.</span>
            <span class="c1"># The true variable will be defined in the transformed parameters block.</span>
            <span class="k">if</span> <span class="n">component</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span><span class="p">:</span>
                <span class="n">declarations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">get_raw_stan_parameter_declaration</span><span class="p">())</span>

            <span class="c1"># Otherwise, add regular declarations for parameters.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">declarations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">get_stan_parameter_declaration</span><span class="p">())</span>

        <span class="c1"># Combine the lines and enclose in the parameters block</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;parameters {</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">}&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan model block with log-probability statements.</span>

<span class="sd">        :returns: Stan model block code</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the model block containing all target increment statements</span>
<span class="sd">        for priors and likelihoods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_incrementation</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_parameters_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan transformed parameters block.</span>

<span class="sd">        :returns: Stan transformed parameters block code</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the transformed parameters block for deterministic parameter</span>
<span class="sd">        transformations and derived quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the declarations for transformed parameters. We take any named transformed</span>
        <span class="c1"># that are named or indexed. We also take any Parameter that transforms</span>
        <span class="c1"># a raw to a real parameter</span>
        <span class="n">declarations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">component</span><span class="o">.</span><span class="n">get_stan_parameter_declaration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurse_model_components</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">transformed_parameters</span><span class="o">.</span><span class="n">TransformedParameter</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">is_named</span> <span class="ow">or</span> <span class="n">component</span><span class="o">.</span><span class="n">force_name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">component</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Combine declarations</span>
        <span class="n">declaration_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Combine declarations and transformations</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transformation_assignment</span><span class="p">(</span><span class="n">declarations</span><span class="o">=</span><span class="n">declaration_block</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_quantities_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan generated quantities block.</span>

<span class="sd">        :returns: Stan generated quantities block code</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates the generated quantities block for posterior predictive</span>
<span class="sd">        sampling and derived quantity computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get declarations for the generated quantities block. This is all observables</span>
        <span class="c1"># in the program.</span>
        <span class="n">declarations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">component</span><span class="o">.</span><span class="n">get_generated_quantity_declaration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurse_model_components</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">component</span><span class="o">.</span><span class="n">observable</span>
        <span class="p">]</span>

        <span class="c1"># Combine declarations</span>
        <span class="n">declaration_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_lines</span><span class="p">(</span><span class="n">declarations</span><span class="p">,</span> <span class="n">indentation_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Combine declarations and transformations</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_quantities</span><span class="p">(</span><span class="n">declarations</span><span class="o">=</span><span class="n">declaration_block</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allowed_index_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get allowed index variable names avoiding conflicts.</span>

<span class="sd">        :returns: Tuple of allowed index variable names</span>
<span class="sd">        :rtype: tuple[str, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_index_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">target_inc_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get prefix for model block.</span>

<span class="sd">        :returns: Stan model block opening syntax</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;model {&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformation_assi_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get prefix for transformed parameters block.</span>

<span class="sd">        :returns: Stan transformed parameters block opening syntax</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;transformed parameters {&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_quantities_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get prefix for generated quantities block.</span>

<span class="sd">        :returns: Stan generated quantities block opening syntax</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;generated quantities {&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed_data_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get prefix for transformed data block.</span>

<span class="sd">        :returns: Stan transformed data block opening syntax</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;transformed data {&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">code</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate complete Stan program code.</span>

<span class="sd">        :returns: Complete Stan program as formatted string</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Assembles all program blocks into a complete Stan program with</span>
<span class="sd">        proper formatting and structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Join steps that have contents</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">val</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functions_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformed_parameters_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_block</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generated_quantities_block</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">],</span> <span class="n">warn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to enhance CmdStanModel functions with automatic data gathering.</span>

<span class="sd">    This decorator modifies CmdStanModel functions to automatically gather</span>
<span class="sd">    required data from the SciStanPy model while requiring users to provide</span>
<span class="sd">    values only for observable parameters.</span>

<span class="sd">    :param func: CmdStanModel function to enhance</span>
<span class="sd">    :type func: Callable[P, R]</span>
<span class="sd">    :param warn: Whether to warn about experimental status. Defaults to False.</span>
<span class="sd">    :type warn: bool</span>

<span class="sd">    :returns: Enhanced function with automatic data gathering</span>
<span class="sd">    :rtype: Callable[P, R]</span>

<span class="sd">    The inner function handles:</span>
<span class="sd">    - Automatic seed generation from global RNG if not provided</span>
<span class="sd">    - Data gathering and validation from SciStanPy model</span>
<span class="sd">    - Warning messages for experimental functions</span>
<span class="sd">    - Proper argument handling and forwarding</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper function for gathering inputs.&quot;&quot;&quot;</span>
        <span class="c1"># If warning the user about lack of testing, do so</span>
        <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is experimental and has not been thoroughly tested&quot;</span>
                <span class="s2">&quot; in the context of SciStanPy models. Use with caution.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get the Stan model from the first argument</span>
        <span class="n">stan_model</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stan_model</span><span class="p">,</span> <span class="n">StanModel</span><span class="p">)</span>

        <span class="c1"># Combine args and kwargs into a single dictionary</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>

        <span class="c1"># If a seed is not provided, use the global random number generator to get</span>
        <span class="c1"># one</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scistanpy</span><span class="o">.</span><span class="n">RNG</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># `data` must be a key in the kwargs</span>
        <span class="k">if</span> <span class="s2">&quot;data&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The &#39;data&#39; keyword argument must be provided to </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Gather the inputs for the Stan model. The user should have provided</span>
        <span class="c1"># values for the observables. We will get the rest of the inputs from the</span>
        <span class="c1"># SciStanPy model.</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stan_model</span><span class="o">.</span><span class="n">gather_inputs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>

        <span class="c1"># Run the wrapped function</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">stan_model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inner</span>


<div class="viewcode-block" id="StanModel">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StanModel</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced CmdStanModel with SciStanPy integration.</span>

<span class="sd">    This class extends CmdStanPy&#39;s CmdStanModel to provide integration</span>
<span class="sd">    with SciStanPy models, including automatic Stan code generation, enhanced</span>
<span class="sd">    sampling interfaces, and comprehensive result processing.</span>

<span class="sd">    :param model: SciStanPy model to compile to Stan</span>
<span class="sd">    :type model: scistanpy.Model</span>
<span class="sd">    :param output_dir: Directory for Stan files and compilation. Defaults to None (temporary).</span>
<span class="sd">    :type output_dir: Optional[str]</span>
<span class="sd">    :param force_compile: Whether to force recompilation. Defaults to False.</span>
<span class="sd">    :type force_compile: bool</span>
<span class="sd">    :param stanc_options: Options for Stan compiler. Defaults to None (uses defaults).</span>
<span class="sd">    :type stanc_options: Optional[dict[str, Any]]</span>
<span class="sd">    :param cpp_options: Options for C++ compilation. Defaults to None (uses defaults).</span>
<span class="sd">    :type cpp_options: Optional[dict[str, Any]]</span>
<span class="sd">    :param user_header: Custom C++ header code. Defaults to None.</span>
<span class="sd">    :type user_header: Optional[str]</span>
<span class="sd">    :param model_name: Name for compiled model. Defaults to &#39;model&#39;.</span>
<span class="sd">    :type model_name: str</span>

<span class="sd">    :ivar model: Reference to source SciStanPy model</span>
<span class="sd">    :ivar program: Generated StanProgram instance</span>
<span class="sd">    :ivar output_dir: Directory containing Stan files</span>
<span class="sd">    :ivar stan_executable_path: Path to compiled Stan executable</span>

<span class="sd">    Key Features:</span>
<span class="sd">    - Automatic Stan code generation from SciStanPy models</span>
<span class="sd">    - Enhanced sampling with prior initialization and validation</span>
<span class="sd">    - Automatic data gathering for observables and constants</span>
<span class="sd">    - Comprehensive result processing and structuring</span>
<span class="sd">    - Integration with ArviZ for Bayesian workflow support</span>

<span class="sd">    The class handles the complete workflow from SciStanPy model to Stan</span>
<span class="sd">    execution, providing an interface that abstracts away the complexities of Stan</span>
<span class="sd">    code generation and compilation management.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We initialize with a SciStanPy model instance</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;scistanpy.Model&quot;</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force_compile</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">DEFAULT_FORCE_COMPILE</span><span class="p">,</span>
        <span class="n">stanc_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cpp_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_USER_HEADER</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_MODEL_NAME</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Set default options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stanc_options</span> <span class="o">=</span> <span class="n">stanc_options</span> <span class="ow">or</span> <span class="n">DEFAULT_STANC_OPTIONS</span>
        <span class="n">cpp_options</span> <span class="o">=</span> <span class="n">cpp_options</span> <span class="ow">or</span> <span class="n">DEFAULT_CPP_OPTIONS</span>

        <span class="c1"># Add the &quot;include_paths&quot; kwarg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stanc_options</span><span class="p">[</span><span class="s2">&quot;include-paths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stanc_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;include-paths&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="n">stan</span><span class="o">.</span><span class="n">STAN_INCLUDE_PATHS</span>
        <span class="p">)</span>

        <span class="c1"># Note the underlying SciStanPy model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># Compile the program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program</span> <span class="o">=</span> <span class="n">StanProgram</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Set the output directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_dir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># Get the model name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stan_executable_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>

        <span class="c1"># Write the Stan program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_stan_program</span><span class="p">()</span>

        <span class="c1"># Initialize the CmdStanModel</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">stan_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stan_program_path</span><span class="p">,</span>
            <span class="n">exe_file</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stan_executable_path</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stan_executable_path</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_compile</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
            <span class="n">force_compile</span><span class="o">=</span><span class="n">force_compile</span><span class="p">,</span>
            <span class="n">stanc_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stanc_options</span><span class="p">,</span>
            <span class="n">cpp_options</span><span class="o">=</span><span class="n">cpp_options</span><span class="p">,</span>
            <span class="n">user_header</span><span class="o">=</span><span class="n">user_header</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_output_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configure output directory with automatic cleanup for temporary directories.</span>

<span class="sd">        :param output_dir: Directory path or None for temporary directory</span>
<span class="sd">        :type output_dir: Optional[str]</span>

<span class="sd">        :raises FileNotFoundError: If specified directory doesn&#39;t exist</span>

<span class="sd">        Sets up the output directory for Stan files, creating a temporary</span>
<span class="sd">        directory with automatic cleanup if none is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a temporary directory if none is specified. Set up a weak reference</span>
        <span class="c1"># to clean up the temporary directory when the model is deleted.</span>
        <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tempdir</span> <span class="o">=</span> <span class="n">TemporaryDirectory</span><span class="p">()</span>
            <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tempdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">)</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">tempdir</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Make sure the output directory exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output directory </span><span class="si">{</span><span class="n">output_dir</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="c1"># Set the output directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

<div class="viewcode-block" id="StanModel.write_stan_program">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel.write_stan_program">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_stan_program</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write and format the generated Stan program to disk.</span>

<span class="sd">        This method writes the Stan program code to a .stan file in the</span>
<span class="sd">        output directory and applies Stan&#39;s canonical formatting for</span>
<span class="sd">        consistency and readability.</span>

<span class="sd">        The written file can be inspected, modified, or used independently</span>
<span class="sd">        of SciStanPy for debugging or optimization purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Write the raw code</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stan_program_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">())</span>

        <span class="c1"># Format the code</span>
        <span class="n">format_stan_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stan_program_path</span><span class="p">,</span>
            <span class="n">overwrite_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">stanc_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stanc_options</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="StanModel.gather_inputs">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel.gather_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gather_inputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">observables</span><span class="p">:</span> <span class="s2">&quot;custom_types.SampleType&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;custom_types.SampleType&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gather complete input data for Stan sampling.</span>

<span class="sd">        :param observables: User-provided data for observable parameters</span>
<span class="sd">        :type observables: dict[str, custom_types.SampleType]</span>

<span class="sd">        :returns: Complete data dictionary for Stan sampling</span>
<span class="sd">        :rtype: dict[str, custom_types.SampleType]</span>

<span class="sd">        :raises ValueError: If required observables are missing or extra observables provided</span>
<span class="sd">        :raises ValueError: If observable shapes don&#39;t match model specifications</span>

<span class="sd">        This method combines user-provided observable data with automatically</span>
<span class="sd">        gathered constants and hyperparameters to create the complete data</span>
<span class="sd">        input required for Stan sampling.</span>

<span class="sd">        Data Processing:</span>
<span class="sd">        - Validates all required observables are provided</span>
<span class="sd">        - Checks shape compatibility between data and model specifications</span>
<span class="sd">        - Automatically gathers constants and hyperparameters from model</span>
<span class="sd">        - Handles variable name transformation (dots to double underscores)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure we have all the observables that the user must provide. Report</span>
        <span class="c1"># any missing or extra observables</span>
        <span class="n">provided_observables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">observables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">missing</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">user_provided_varnames</span> <span class="o">-</span> <span class="n">provided_observables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing observables: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">extra</span> <span class="o">:=</span> <span class="n">provided_observables</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">user_provided_varnames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extra observables: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># The shapes of the provided observables must match the shapes of the</span>
        <span class="c1"># observables in the model</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">observables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Shape mismatch for observable </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> != &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Shape mismatch for observable </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: scalar != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Pull the hyperparameters from the model and add them to the inputs</span>
        <span class="n">observables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">autogathered_data</span><span class="p">)</span>

        <span class="c1"># Squeeze all numpy arrays</span>
        <span class="n">observables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">obs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">obs</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">observables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># All dots in the names must be replaced with double underscores</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">):</span> <span class="n">obs</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">observables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="StanModel.code">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel.code">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">code</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the complete Stan program code.</span>

<span class="sd">        :returns: Stan program code as formatted string</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Returns the complete, formatted Stan program generated from the</span>
<span class="sd">        SciStanPy model for inspection or external use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">code</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_sample_init</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">chains</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate prior-based initialization for MCMC chains.</span>

<span class="sd">        :param chains: Number of chains to initialize</span>
<span class="sd">        :type chains: custom_types.Integer</span>
<span class="sd">        :param seed: Random seed for reproducible initialization. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: List of initialization dictionaries, one per chain</span>
<span class="sd">        :rtype: list[dict[str, Union[npt.NDArray[np.floating], np.floating]]]</span>

<span class="sd">        This method draws samples from the model&#39;s prior distribution to</span>
<span class="sd">        provide reasonable starting values for MCMC sampling, which can</span>
<span class="sd">        improve convergence and sampling efficiency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Draw from the prior distribution of the model, keeping only the draws</span>
        <span class="c1"># for the non-observable parameters</span>
        <span class="n">draws</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">component</span><span class="o">.</span><span class="n">model_varname</span><span class="p">:</span> <span class="n">draw</span>
            <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="n">chains</span><span class="p">,</span> <span class="n">named_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span>
            <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">component</span><span class="o">.</span><span class="n">observable</span>
        <span class="p">}</span>

        <span class="c1"># The draws should overlap perfectly with the parameters of the model</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">draws</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">all_paramnames</span>

        <span class="c1"># Separate the draws into one dictionary per chain</span>
        <span class="k">return</span> <span class="p">[{</span><span class="n">name</span><span class="p">:</span> <span class="n">draw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="n">draws</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chains</span><span class="p">)]</span>

<div class="viewcode-block" id="StanModel.get_varnames_to_dimnames">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel.get_varnames_to_dimnames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_varnames_to_dimnames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create mapping from variable names to dimension names for ArviZ.</span>

<span class="sd">        :returns: Dictionary mapping variable names to their dimension names</span>
<span class="sd">        :rtype: dict[str, list[str]]</span>

<span class="sd">        This mapping is essential for creating properly structured ArviZ</span>
<span class="sd">        InferenceData objects with appropriate coordinate information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the mapping from level and size of a dimension to the name of the</span>
        <span class="c1"># dimension</span>
        <span class="n">name_mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_dimname_map</span><span class="p">()</span>

        <span class="c1"># Loop over all variables and create a mapping of dimension names</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">varname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">):</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">reversed</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">name_mapper</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">all_varnames</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="StanModel.sample">
<a class="viewcode-back" href="../../../../api/model/stan/stan_model.html#scistanpy.model.stan.stan_model.StanModel.sample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;half&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
        <span class="n">mib_per_chunk</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_dask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;results.SampleResults&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute MCMC sampling with enhanced SciStanPy integration.</span>

<span class="sd">        :param args: Positional arguments passed to CmdStanModel.sample</span>
<span class="sd">        :param precision: Numerical precision for result arrays. Defaults to &#39;single&#39;.</span>
<span class="sd">        :type precision: Literal[&quot;double&quot;, &quot;single&quot;, &quot;half&quot;]</span>
<span class="sd">        :param mib_per_chunk: When using dask, memory limit per chunk for large arrays.</span>
<span class="sd">            Defaults to None (uses Dask default).</span>
<span class="sd">        :type mib_per_chunk: Optional[custom_types.Integer]</span>
<span class="sd">        :param use_dask: Whether to use Dask for large array processing. Defaults to False.</span>
<span class="sd">        :type use_dask: bool</span>
<span class="sd">        :param kwargs: Keyword arguments passed to CmdStanModel.sample</span>

<span class="sd">        :returns: Comprehensive sampling results with SciStanPy integration</span>
<span class="sd">        :rtype: results.SampleResults</span>

<span class="sd">        Enhanced Features:</span>
<span class="sd">        - Automatic data gathering from SciStanPy model</span>
<span class="sd">        - Prior-based initialization when requested</span>
<span class="sd">        - Result processing and structuring</span>
<span class="sd">        - Memory-efficient handling of large result arrays</span>
<span class="sd">        - Integration with SciStanPy&#39;s result analysis tools</span>

<span class="sd">        The method provides an interface that handles all the complexities of data</span>
<span class="sd">        preparation and result processing while maintaining full compatibility with</span>
<span class="sd">        CmdStanPy&#39;s sampling options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the sample function from CmdStanModel to automatically pull the</span>
        <span class="c1"># data from the StanModel</span>
        <span class="n">updated_parent_sample</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span>

        <span class="c1"># Combine args and kwargs into a single dictionary</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">args</span><span class="p">)))</span>

        <span class="c1"># Set the number of chains if not provided</span>
        <span class="k">if</span> <span class="s2">&quot;chains&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;chains&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;chains&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># If initializing from the prior, we need to draw from the prior</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;inits&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;prior&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;inits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_init</span><span class="p">(</span>  <span class="c1"># pylint: disable=protected-access</span>
                <span class="n">chains</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;chains&quot;</span><span class="p">],</span> <span class="n">seed</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Run the sample function</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">updated_parent_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Build the results object</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">SampleResults</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">mib_per_chunk</span><span class="o">=</span><span class="n">mib_per_chunk</span><span class="p">,</span>
            <span class="n">use_dask</span><span class="o">=</span><span class="n">use_dask</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># Enhanced CmdStanModel methods with automatic data gathering</span>
    <span class="n">generate_quantities</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span>
        <span class="n">CmdStanModel</span><span class="o">.</span><span class="n">generate_quantities</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced generate_quantities with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">laplace_sample</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">laplace_sample</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced laplace_sample with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log_prob</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced log_prob with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">optimize</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced optimize with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pathfinder</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">pathfinder</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced pathfinder with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">variational</span> <span class="o">=</span> <span class="n">_update_cmdstanpy_func</span><span class="p">(</span><span class="n">CmdStanModel</span><span class="o">.</span><span class="n">variational</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced variational with automatic data gathering.</span>

<span class="sd">    Automatically gathers required data from SciStanPy model. Experimental feature.</span>

<span class="sd">    :warning: This method is experimental and not thoroughly tested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stan_program_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get path to the generated Stan program file.</span>

<span class="sd">        :returns: Full path to .stan file</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stan_executable_path</span> <span class="o">+</span> <span class="s2">&quot;.stan&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">autogathered_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get automatically gathered data from model constants.</span>

<span class="sd">        :returns: Dictionary of constant values from SciStanPy model</span>
<span class="sd">        :rtype: dict[str, npt.NDArray]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">autogathered_varnames</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_varnames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all variable names with Stan-compatible formatting.</span>

<span class="sd">        :returns: Set of all variable names (dots replaced with double underscores)</span>
<span class="sd">        :rtype: set[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">all_varnames</span><span class="p">}</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">SciStanPy API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../scistanpy.html">scistanpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Microsoft Corporation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>