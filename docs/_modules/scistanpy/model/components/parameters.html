<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scistanpy.model.components.parameters &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scistanpy.model.components.parameters</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation.</span>
<span class="c1"># Licensed under the MIT license.</span>

<span class="sd">&quot;&quot;&quot;Parameter classes for defining probabilistic model components in SciStanPy.</span>

<span class="sd">This module provides the core parameter classes that serve as building blocks for</span>
<span class="sd">constructing probabilistic models in SciStanPy. These classes represent random</span>
<span class="sd">variables with specific probability distributions and handle the complex task of</span>
<span class="sd">translating between Python model specifications, PyTorch modules, and Stan probabilistic</span>
<span class="sd">programming language code.</span>

<span class="sd">Parameter Type Hierarchy:</span>
<span class="sd">    - **Parameter**: Base class for all probabilistic model components</span>
<span class="sd">    - **ContinuousDistribution**: Parameters with continuous sample spaces</span>
<span class="sd">    - **DiscreteDistribution**: Parameters with discrete sample spaces</span>

<span class="sd">Key Features:</span>
<span class="sd">    - **Multi-Backend Support**: Integration with SciPy, PyTorch, and Stan</span>
<span class="sd">    - **Automatic Parameterization**: Intelligent handling of parameter bounds and constraints</span>
<span class="sd">    - **Non-Centered Parameterization**: Automatic reparameterization for improved sampling</span>
<span class="sd">    - **Custom Distributions**: Extended distribution library beyond standard offerings</span>
<span class="sd">    - **Type Safety**: Comprehensive type checking and validation</span>

<span class="sd">Stan Code Generation:</span>
<span class="sd">    Each parameter class automatically generates appropriate Stan code including:</span>
<span class="sd">    - Variable declarations with proper constraints</span>
<span class="sd">    - Target increment statements for log-probability</span>
<span class="sd">    - Generated quantities for posterior predictive sampling</span>
<span class="sd">    - Support for custom Stan functions when needed</span>

<span class="sd">Distribution Support:</span>
<span class="sd">    **Continuous Distributions:**</span>
<span class="sd">    - Normal, HalfNormal, UnitNormal, LogNormal</span>
<span class="sd">    - Beta, Gamma, InverseGamma, Exponential</span>
<span class="sd">    - Dirichlet, ExpDirichlet (log-simplex)</span>
<span class="sd">    - Custom: ExpExponential, Lomax, ExpLomax</span>

<span class="sd">    **Discrete Distributions:**</span>
<span class="sd">    - Binomial, Poisson</span>
<span class="sd">    - Multinomial variants: standard, logit, log-theta parameterizations</span>

<span class="sd">Advanced Features:</span>
<span class="sd">    - **Automatic Reparameterization**: Non-centered parameterization for hierarchical models</span>
<span class="sd">    - **Constraint Handling**: Automatic bound enforcement and transformations</span>
<span class="sd">    - **Observable Support**: Automatic identification of observed data model components</span>
<span class="sd">    - **PyTorch Integration**: Native support for gradient-based optimization</span>
<span class="sd">    - **Custom Function Integration**: Automatic inclusion of required Stan functions</span>

<span class="sd">The parameter classes are designed to be composable, allowing complex hierarchical</span>
<span class="sd">models to be built through simple parameter relationships while maintaining</span>
<span class="sd">mathematical rigor and computational efficiency.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.distributions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">scistanpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstract_model_component</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.custom_distributions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">custom_scipy_dists</span><span class="p">,</span>
    <span class="n">custom_torch_dists</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.transformations</span><span class="w"> </span><span class="kn">import</span> <span class="n">transformed_parameters</span>

<span class="n">cdfs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.components.transformations.cdfs&quot;</span><span class="p">)</span>
<span class="n">constants</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.components.constants&quot;</span><span class="p">)</span>
<span class="n">transformed_data</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span>
    <span class="s2">&quot;scistanpy.model.components.transformations.transformed_data&quot;</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">custom_types</span>

<span class="c1"># pylint: disable=too-many-lines</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">]:</span> <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply element-wise inverse transformation (1/x).</span>

<span class="sd">    Simple inverse transformation function for parameter transformations.</span>
<span class="sd">    Defined at module level to avoid pickling issues with lambda functions.</span>

<span class="sd">    :param x: Input value(s) to transform</span>
<span class="sd">    :type x: Union[npt.NDArray[np.floating], custom_types.Float]</span>

<span class="sd">    :returns: Element-wise inverse of input</span>
<span class="sd">    :rtype: Union[npt.NDArray[np.floating], custom_types.Float]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">]:</span> <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply element-wise exponential transformation.</span>

<span class="sd">    Simple exponential transformation function for parameter transformations.</span>
<span class="sd">    Defined at module level to avoid pickling issues with lambda functions.</span>

<span class="sd">    :param x: Input array to transform</span>
<span class="sd">    :type x: npt.NDArray[np.floating]</span>

<span class="sd">    :returns: Element-wise exponential of input</span>
<span class="sd">    :rtype: npt.NDArray[np.floating]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># TODO: Make sure samples from torch distributions obey the same bounds as noted</span>
<span class="c1"># in the classes.</span>
<span class="c1"># TODO: Make sure samples from Stan distributions obey the same bounds as noted</span>
<span class="c1"># in the classes.</span>


<div class="viewcode-block" id="ParameterMeta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ParameterMeta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParameterMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Metaclass for automatic CDF transform class generation.</span>

<span class="sd">    This metaclass automatically creates cumulative distribution function (CDF)</span>
<span class="sd">    and related transform classes for each Parameter subclass, enabling automatic</span>
<span class="sd">    generation of probabilistic transforms and survival functions.</span>

<span class="sd">    The metaclass creates four transform classes for each parameter:</span>

<span class="sd">    - CDF: Cumulative distribution function</span>
<span class="sd">    - SF: Survival function (complementary CDF)</span>
<span class="sd">    - LOG_CDF: Logarithmic CDF</span>
<span class="sd">    - LOG_SF: Logarithmic survival function</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create CDF transform classes for the Parameter subclass.</span>

<span class="sd">        :param name: Name of the class being created</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param bases: Base classes for the new class</span>
<span class="sd">        :type bases: tuple</span>
<span class="sd">        :param attrs: Class attributes dictionary</span>
<span class="sd">        :type attrs: dict</span>

<span class="sd">        This method automatically generates transform classes by creating</span>
<span class="sd">        new class types that inherit from the appropriate CDF base classes</span>
<span class="sd">        and reference the current parameter class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the parent class&#39;s __init__ method</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Add CDF, SF, LOG_CDF, and LOG_SF classes to the Parameter subclass</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">CDF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">CDF&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">CDF</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">})</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">SF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">SF&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">SurvivalFunction</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">})</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_CDF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">LOG_CDF&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogCDF</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">})</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_SF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">LOG_SF&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogSurvivalFunction</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">}</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="ClassOrInstanceMethod">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ClassOrInstanceMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassOrInstanceMethod</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Descriptor enabling dual class/instance method behavior.</span>

<span class="sd">    This descriptor allows methods to behave differently when called as class</span>
<span class="sd">    methods versus instance methods, enabling flexible parameter handling for</span>
<span class="sd">    CDF-like functions that can use either explicit parameters or instance</span>
<span class="sd">    parameter values.</span>

<span class="sd">    :param func: Function to wrap with dual behavior</span>
<span class="sd">    :type func: Callable</span>

<span class="sd">    When called as an instance method, the descriptor automatically uses the</span>
<span class="sd">    instance&#39;s parameter values. When called as a class method, it requires</span>
<span class="sd">    explicit parameter specification.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return appropriate method based on call context.</span>

<span class="sd">        :param instance: Instance object if called as instance method, None for class method</span>
<span class="sd">        :param owner: Class that owns the method</span>

<span class="sd">        :returns: Configured method with appropriate parameter handling</span>
<span class="sd">        :rtype: Callable</span>

<span class="sd">        The returned method automatically handles parameter passing based on</span>
<span class="sd">        whether it&#39;s called as a class or instance method, validating required</span>
<span class="sd">        parameters and applying appropriate transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># `x` must always be a kwarg</span>
            <span class="k">if</span> <span class="s2">&quot;x&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected `x` to be a keyword argument for the CDF-like methods.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Check for extra kwargs</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">extra_kwargs</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">owner</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">}</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected arguments passed to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extra_kwargs</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># If the instance is not provided, then kwargs must be provided</span>
            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Check for missing kwargs</span>
                <span class="k">if</span> <span class="n">missing_kwargs</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">owner</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;If calling </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> as a static method, the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;following parameters must be provided: </span><span class="si">{</span><span class="n">missing_kwargs</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Run the wrapped method using provided kwargs</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># If the instance is not provided, we run the wrapped method using the</span>
            <span class="c1"># parent parameter values</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                <span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">instance</span><span class="o">.</span><span class="n">_parents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># pylint: disable=protected-access</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inner</span></div>



<div class="viewcode-block" id="Parameter">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Parameter</span><span class="p">(</span>
    <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ParameterMeta</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all probabilistic parameters in SciStanPy models.</span>

<span class="sd">    This class provides the foundational infrastructure for representing random</span>
<span class="sd">    variables with specific probability distributions. It handles the complex</span>
<span class="sd">    mapping between Python model specifications and Stan code generation while</span>
<span class="sd">    providing integration with SciPy and PyTorch ecosystems.</span>

<span class="sd">    :cvar STAN_DIST: Stan distribution name for code generation</span>
<span class="sd">    :type STAN_DIST: str</span>
<span class="sd">    :cvar HAS_RAW_VARNAME: Whether parameter uses a raw/transformed parameterization</span>
<span class="sd">    :type HAS_RAW_VARNAME: bool</span>
<span class="sd">    :cvar SCIPY_DIST: Corresponding SciPy distribution class</span>
<span class="sd">    :type SCIPY_DIST: Optional[Union[type[stats.rv_continuous], type[stats.rv_discrete]]]</span>
<span class="sd">    :cvar TORCH_DIST: Corresponding PyTorch distribution class</span>
<span class="sd">    :type TORCH_DIST: Optional[Union[type[dist.distribution.Distribution], type[custom_torch_dists.CustomDistribution]]]</span>
<span class="sd">    :cvar STAN_TO_SCIPY_NAMES: Parameter name mapping for SciPy interface</span>
<span class="sd">    :type STAN_TO_SCIPY_NAMES: dict[str, str]</span>
<span class="sd">    :cvar STAN_TO_TORCH_NAMES: Parameter name mapping for PyTorch interface</span>
<span class="sd">    :type STAN_TO_TORCH_NAMES: dict[str, str]</span>
<span class="sd">    :cvar STAN_TO_SCIPY_TRANSFORMS: Parameter transformation functions converting between</span>
<span class="sd">        Stan and SciPy parametrizations</span>
<span class="sd">    :type STAN_TO_SCIPY_TRANSFORMS: dict[str, Callable[[npt.NDArray], npt.NDArray]]</span>
<span class="sd">    :cvar CDF: Automatically generated CDF transform class</span>
<span class="sd">    :type CDF: type[cdfs.CDF]</span>
<span class="sd">    :cvar SF: Automatically generated SF transform class</span>
<span class="sd">    :type SF: type[cdfs.SurvivalFunction]</span>
<span class="sd">    :cvar LOG_CDF: Automatically generated log CDF transform class</span>
<span class="sd">    :type LOG_CDF: type[cdfs.LogCDF]</span>
<span class="sd">    :cvar LOG_SF: Automatically generated log SF transform class</span>
<span class="sd">    :type LOG_SF: type[cdfs.LogSurvivalFunction]</span>

<span class="sd">    The class automatically handles:</span>

<span class="sd">    - Parameter validation and type checking</span>
<span class="sd">    - Stan code generation for all model blocks</span>
<span class="sd">    - PyTorch parameter initialization and management</span>
<span class="sd">    - Observable/latent parameter distinction</span>
<span class="sd">    - Bound enforcement and constraint handling</span>

<span class="sd">    Key Capabilities:</span>

<span class="sd">    - **Multi-Backend Integration**: Works with SciPy, PyTorch, and Stan</span>
<span class="sd">    - **Automatic Code Generation**: Generates appropriate Stan syntax</span>
<span class="sd">    - **Type Safety**: Validates parameter types and constraints</span>
<span class="sd">    - **Flexible Parameterization**: Supports both raw and transformed parameters</span>
<span class="sd">    - **Observable Support**: Can represent both latent variables and observed data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">HAS_RAW_VARNAME</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">CDF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">CDF</span><span class="p">]</span>
    <span class="n">SF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">SurvivalFunction</span><span class="p">]</span>
    <span class="n">LOG_CDF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogCDF</span><span class="p">]</span>
    <span class="n">LOG_SF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogSurvivalFunction</span><span class="p">]</span>
    <span class="n">SCIPY_DIST</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_continuous</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_discrete</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">TORCH_DIST</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">type</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">distribution</span><span class="o">.</span><span class="n">Distribution</span><span class="p">]</span>
        <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">CustomDistribution</span><span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize parameter with distribution-specific arguments.</span>

<span class="sd">        :param kwargs: Distribution parameters (mu, sigma, etc. depending on subclass)</span>

<span class="sd">        :raises NotImplementedError: If required class attributes are missing (i.e.,</span>
<span class="sd">            if subclass was incorrectly defined)</span>
<span class="sd">        :raises TypeError: If required distribution parameters are missing</span>

<span class="sd">        The initialization process:</span>
<span class="sd">        1. Validates all required class attributes are defined</span>
<span class="sd">        2. Checks that all required distribution parameters are provided</span>
<span class="sd">        3. Initializes parent AbstractModelComponent</span>
<span class="sd">        4. Sets up observability tracking and PyTorch parameter placeholders</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Confirm that class attributes are set correctly</span>
        <span class="k">if</span> <span class="n">missing_attributes</span> <span class="o">:=</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">&quot;STAN_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;CDF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LOG_CDF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LOG_SF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SCIPY_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TORCH_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;STAN_TO_SCIPY_NAMES&quot;</span><span class="p">,</span>
                <span class="s2">&quot;STAN_TO_TORCH_NAMES&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The following class attributes must be defined: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure we have the expected parameters</span>
        <span class="k">if</span> <span class="n">missing_params</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Missing parameters </span><span class="si">{</span><span class="n">missing_params</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize the parameters</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Parameters can be manually set as observables, so we need a flag to</span>
        <span class="c1"># track this</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initialize a parametrization using PyTorch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Parameter.init_pytorch">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.init_pytorch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_pytorch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize PyTorch parameter on **unconstrained** space for gradient-based</span>
<span class="sd">        optimization.</span>

<span class="sd">        :param init_val: Initial parameter values. Uniform between -1 and 1 if None.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :type init_val: Optional[Union[npt.NDArray, torch.Tensor]]</span>
<span class="sd">        :param seed: Random seed for initialization. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :raises ValueError: If called on observable parameters</span>
<span class="sd">        :raises ValueError: If init_val shape doesn&#39;t match parameter shape</span>

<span class="sd">        This method sets up the parameter for PyTorch-based optimization by</span>
<span class="sd">        creating a trainable nn.Parameter with appropriate initialization.</span>
<span class="sd">        The initialization strategy uses uniform random values in [-1, 1]</span>
<span class="sd">        if no explicit values are provided. Note that initialization values are</span>
<span class="sd">        on the unconstrained space. An appropriate transform is applied depending</span>
<span class="sd">        on the bounds of the distribution represented by the class to take it to</span>
<span class="sd">        a constrained space.</span>

<span class="sd">        Observable parameters cannot be initialized as they represent fixed</span>
<span class="sd">        data rather than learnable parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This cannot be called if the parameter is an observable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observables do not have a torch parametrization&quot;</span><span class="p">)</span>

        <span class="c1"># If no initialization value is provided, then we create one on the range</span>
        <span class="c1"># of -1 to 1.</span>
        <span class="k">if</span> <span class="n">init_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># If the initialization value is a numpy array, convert it to a tensor</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">init_val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>

        <span class="c1"># The shape of the initialization value must match the shape of the</span>
        <span class="c1"># parameter being initialized</span>
        <span class="k">if</span> <span class="n">init_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the initialization value must match the shape of the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameter. Expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, provided: </span><span class="si">{</span><span class="n">init_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize the parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level_draws</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">]],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">,</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw samples from the parameter&#39;s distribution using SciPy backend.</span>

<span class="sd">        :param level_draws: Parameter values from parent components</span>
<span class="sd">        :type level_draws: dict[str, Union[npt.NDArray, custom_types.Float]]</span>
<span class="sd">        :param seed: Random seed for reproducible sampling</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Sampled values from the distribution</span>
<span class="sd">        :rtype: Union[npt.NDArray, custom_types.Float, custom_types.Integer]</span>

<span class="sd">        This method applies necessary parameter transformations and name mappings</span>
<span class="sd">        to convert from Stan parameter conventions to SciPy conventions, then</span>
<span class="sd">        samples from the corresponding SciPy distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform and rename the draws from the previous level.</span>
        <span class="n">level_draws</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_TRANSFORMS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
            <span class="p">)(</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="n">level_draws</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Draw from the scipy distribution</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">SCIPY_DIST</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="o">**</span><span class="n">level_draws</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Parameter.as_observable">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.as_observable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Parameter&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark parameter as observable (representing observed data).</span>

<span class="sd">        :returns: Self-reference for method chaining</span>
<span class="sd">        :rtype: Parameter</span>

<span class="sd">        Observable parameters represent known data rather than unknown variables</span>
<span class="sd">        to be inferred. This method:</span>
<span class="sd">        - Sets the observable flag to True</span>
<span class="sd">        - Removes PyTorch parameterization (observables aren&#39;t optimized)</span>
<span class="sd">        - Enables generation of appropriate Stan code for data blocks</span>

<span class="sd">        This method will typically not be needed, as SciStanPy automatically assigns</span>
<span class="sd">        parameters with no children in the depenency graph as observables.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; y_obs = Normal(mu=mu_param, sigma=sigma_param).as_observable()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the observable attribute to True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># We do not have a torch parameterization for observables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Parameter.get_target_incrementation">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_target_incrementation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan target increment statement for log-probability.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan code for target increment (e.g., &quot;y ~ normal(mu, sigma)&quot;)</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method generates the Stan code that adds this parameter&#39;s</span>
<span class="sd">        log-probability contribution to the target density. It handles</span>
<span class="sd">        proper indexing for multi-dimensional parameters and constructs</span>
<span class="sd">        the appropriate distribution call with parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the left side and operator</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span><span class="si">}</span><span class="s2"> ~ &quot;</span>

        <span class="c1"># Get the right-hand-side of the incrementation</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Put it all together</span>
        <span class="k">return</span> <span class="n">left_side</span> <span class="o">+</span> <span class="n">right_side</span></div>


<div class="viewcode-block" id="Parameter.get_generated_quantities">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_generated_quantities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_generated_quantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for posterior predictive sampling.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan code for generated quantities block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method creates Stan code for the generated quantities block,</span>
<span class="sd">        enabling posterior predictive sampling by generating new samples</span>
<span class="sd">        from the parameter&#39;s distribution using fitted parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generated_varname</span><span class="p">)</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span><span class="w"> </span><span class="n">dist_suffix</span><span class="o">=</span><span class="s1">&#39;rng&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_torch_logprob">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_torch_logprob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_torch_logprob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">observed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute log-probability using PyTorch backend for gradient computation.</span>

<span class="sd">        :param observed: Observed values for observable parameters. Defaults to None.</span>
<span class="sd">        :type observed: Optional[torch.Tensor]</span>

<span class="sd">        :returns: Log-probability tensor with gradient tracking</span>
<span class="sd">        :rtype: torch.Tensor</span>

<span class="sd">        :raises ValueError: If observable parameter lacks observed values</span>
<span class="sd">        :raises ValueError: If latent parameter has observed values</span>

<span class="sd">        This method computes log-probabilities using PyTorch distributions,</span>
<span class="sd">        enabling gradient-based optimization. For observable parameters,</span>
<span class="sd">        it evaluates the likelihood of observed data. For latent parameters,</span>
<span class="sd">        it evaluates the prior probability of current parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Observed parameters must have an observed value.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="ow">and</span> <span class="n">observed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observed parameters must have an observed value.&quot;</span><span class="p">)</span>

        <span class="c1"># If this is not an observable, then we should not have an observed value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="ow">and</span> <span class="n">observed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Latent parameters should not have an observed value.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch_dist_instance</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span>
            <span class="n">observed</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch_parametrization</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="Parameter.get_rng">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_rng">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rng</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get random number generator for sampling operations.</span>

<span class="sd">        :param seed: Optional seed for reproducible generation. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: NumPy random number generator</span>
<span class="sd">        :rtype: np.random.Generator</span>

<span class="sd">        Returns the global SciStanPy RNG if no seed is provided, otherwise</span>
<span class="sd">        creates a new generator with the specified seed for reproducible</span>
<span class="sd">        sampling operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return the global random number generator if no seed is provided. Otherwise,</span>
        <span class="c1"># return a new random number generator with the provided seed.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scistanpy</span><span class="o">.</span><span class="n">RNG</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">to_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments for Stan code generation.</span>

<span class="sd">        :param to_format: Formatted parameter strings keyed by parameter name</span>
<span class="sd">        :type to_format: str</span>

<span class="sd">        :returns: Comma-separated argument string for Stan distribution calls</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method creates properly formatted argument lists for Stan</span>
<span class="sd">        distribution functions, ordering arguments according to Stan</span>
<span class="sd">        conventions and handling parameter name mappings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate right-hand side of Stan distribution statements.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: Optional[tuple[str, ...]]</span>
<span class="sd">        :param start_dims: First indexable dimension of parent model components.</span>
<span class="sd">            Defaults to None, meaning the first dimension is the first indexable</span>
<span class="sd">            dimension for all parents.</span>
<span class="sd">        :type start_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param end_dims: Last indexable dimension of parent model components. Defaults</span>
<span class="sd">            to None, meaning the last dimension is the last indexable dimension</span>
<span class="sd">            for all parents.</span>
<span class="sd">        :type end_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param offset_adjustment: Index offset adjustment. For example, if `index_opts`</span>
<span class="sd">            are (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) and `offset_adjustment` is 1, the effective allowed</span>
<span class="sd">            indices will be (&#39;b&#39;, &#39;c&#39;). This argument is critical for aligning</span>
<span class="sd">            dimensions between parent and child model components that have different</span>
<span class="sd">            numbers of dimensions. Defaults to 0.</span>
<span class="sd">        :type offset_adjustment: int</span>
<span class="sd">        :param dist_suffix: Distribution function suffix (e.g., &quot;_rng&quot;). Defaults to &quot;&quot;.</span>
<span class="sd">        :type dist_suffix: str</span>

<span class="sd">        :returns: Stan distribution call string</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method constructs the right-hand side of Stan statements,</span>
<span class="sd">        handling parameter indexing, distribution suffixes for different</span>
<span class="sd">        Stan blocks, and proper argument formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="o">=</span><span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Build the distribution argument and format the Stan code</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">dist_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">STAN_DIST</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">write_dist_args</span><span class="p">(</span><span class="o">**</span><span class="n">formattables</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">return</span> <span class="n">code</span></div>


<div class="viewcode-block" id="Parameter.get_transformed_data_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_transformed_data_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformed_data_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan transformed data block declarations.</span>

<span class="sd">        :returns: Stan code for transformed data declarations (empty by default)</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Most parameters don&#39;t require transformed data declarations. This</span>
<span class="sd">        method can be overridden by subclasses that need to declare</span>
<span class="sd">        transformed data variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># None by default</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Parameter.get_generated_quantity_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_generated_quantity_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_generated_quantity_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan variable declaration for generated quantities.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration. For example,</span>
<span class="sd">            if `True` and the parameter is defined as a multidimension float, the</span>
<span class="sd">            returned stan dtype will not be `array[...Ndim - 1...] vector`, but</span>
<span class="sd">            `array[...NDim...] float`. Defaults to True, as this is the format</span>
<span class="sd">            expected by generated quantities blocks.</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan variable declaration for posterior predictive sampling</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates appropriate variable declarations for the generated quantities</span>
<span class="sd">        block, enabling posterior predictive sampling with correct variable</span>
<span class="sd">        types and constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_stan_variable</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generated_varname</span><span class="p">,</span> <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_raw_stan_parameter_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_raw_stan_parameter_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_raw_stan_parameter_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan parameter declaration for raw (untransformed) variables.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration. See</span>
<span class="sd">            `get_generated_quantity_declaration` for more information. Defaults to False.</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan parameter declaration for raw variables</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For parameters using non-centered or other reparameterizations,</span>
<span class="sd">        this generates declarations for the underlying raw variables that</span>
<span class="sd">        are transformed to create the actual parameters. The `get_transformation_assignment`</span>
<span class="sd">        function will return Stan code that converts this raw parameter to the</span>
<span class="sd">        desired parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_stan_variable</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span><span class="p">,</span> <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


    <span class="c1"># pylint: disable=no-self-argument</span>
<div class="viewcode-block" id="Parameter.cdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.cdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.CDF&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create cumulative distribution function transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: CDF transform object</span>
<span class="sd">        :rtype: cdfs.CDF</span>

<span class="sd">        Can be used as either a class method (with explicit parameters) or</span>
<span class="sd">        instance method (using instance parameter values) to create CDF</span>
<span class="sd">        transform objects for probabilistic modeling.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # As class method</span>
<span class="sd">            &gt;&gt;&gt; cdf = Normal.cdf(mu=0, sigma=1, x=data)</span>
<span class="sd">            &gt;&gt;&gt; # As instance method</span>
<span class="sd">            &gt;&gt;&gt; normal_param = Normal(mu=0, sigma=1)</span>
<span class="sd">            &gt;&gt;&gt; cdf = normal_param.cdf(x=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CDF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.ccdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.ccdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ccdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.SurvivalFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create complementary CDF (survival function) transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Survival function transform object</span>
<span class="sd">        :rtype: cdfs.SurvivalFunction</span>

<span class="sd">        Creates survival function (1 - CDF) transforms for survival analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">SF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.log_cdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.log_cdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_cdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.LogCDF&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create logarithmic CDF transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Log-CDF transform object</span>
<span class="sd">        :rtype: cdfs.LogCDF</span>

<span class="sd">        Creates log-CDF transforms for numerical stability in extreme</span>
<span class="sd">        tail probability computations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_CDF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.log_ccdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.log_ccdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_ccdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.LogSurvivalFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create logarithmic survival function transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Log-survival function transform object</span>
<span class="sd">        :rtype: cdfs.LogSurvivalFunction</span>

<span class="sd">        Creates log-survival function transforms for numerical stability</span>
<span class="sd">        in extreme tail probability computations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_SF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


    <span class="c1"># pylint: enable=no-self-argument</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return human-readable string representation of the parameter.</span>

<span class="sd">        :returns: String showing parameter name and distribution</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates a readable representation showing the parameter assignment</span>
<span class="sd">        in mathematical notation, useful for model inspection and debugging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[start:end]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_varname</span><span class="si">}</span><span class="s2"> ~ </span><span class="si">{</span><span class="n">right_side</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">torch_dist_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.SciStanPyDistribution&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get PyTorch distribution instance with current parameter values.</span>

<span class="sd">        :returns: Configured PyTorch distribution object</span>
<span class="sd">        :rtype: custom_types.SciStanPyDistribution</span>

<span class="sd">        Creates a PyTorch distribution instance using the current parameter</span>
<span class="sd">        values, enabling gradient-based computations and optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">TORCH_DIST</span><span class="p">(</span>  <span class="c1"># pylint: disable=not-callable</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_TORCH_NAMES</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span> <span class="n">torch</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">torch_parametrization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_hyperparameter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter is a hyperparameter (has only constant parents).</span>

<span class="sd">        :returns: True if all parent parameters are constants</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Hyperparameters are top-level parameters in the model hierarchy</span>
<span class="sd">        that depend only on fixed constants rather than other random variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">torch_parametrization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get PyTorch parameter tensor with appropriate constraints applied.</span>

<span class="sd">        :returns: Constrained parameter tensor for optimization</span>
<span class="sd">        :rtype: torch.Tensor</span>

<span class="sd">        :raises ValueError: If called on observable parameters</span>

<span class="sd">        Returns the PyTorch parameter tensor with appropriate transformations</span>
<span class="sd">        applied to enforce bounds, simplex constraints, or other restrictions.</span>
<span class="sd">        The returned tensor is suitable for gradient-based optimization and obeys</span>
<span class="sd">        the bounds of the probability distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the parameter is an observable, there is no torch parametrization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observables do not have a torch parametrization&quot;</span><span class="p">)</span>

        <span class="c1"># Just return the parameter if there are no bounds</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_SIMPLEX</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_LOG_SIMPLEX</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span>

        <span class="c1"># Set bounds where we have both upper and lower</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_SIMPLEX</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_LOG_SIMPLEX</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="o">+</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">)</span>

        <span class="c1"># If not both bounds, then we must have one bound. We assume the parameter</span>
        <span class="c1"># is defined in the log space and exponentiate it to get the positive value.</span>
        <span class="n">exp_param</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">)</span>

        <span class="c1"># Now if we only have a lower bound</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="o">+</span> <span class="n">exp_param</span>

        <span class="c1"># If we only have an upper bound</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="o">-</span> <span class="n">exp_param</span>

        <span class="c1"># We should never get here</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Invalid bounds&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get variable name for posterior predictive sampling.</span>

<span class="sd">        :returns: Variable name with &quot;_ppc&quot; suffix for generated quantities</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        :raises ValueError: If called on non-observable parameters</span>

<span class="sd">        Observable parameters generate posterior predictive samples in the</span>
<span class="sd">        generated quantities block using a modified variable name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only available for observables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Generated variables are only available for observables&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_varname</span><span class="si">}</span><span class="s2">_ppc&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter represents observed data.</span>

<span class="sd">        :returns: True if parameter is observable</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Parameters are observable if explicitly marked as such or if they</span>
<span class="sd">        have no children (representing terminal nodes in the model graph).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">TransformedData</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">raw_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get raw variable name for reparameterized parameters.</span>

<span class="sd">        :returns: Raw variable name with &quot;_raw&quot; suffix, or empty string if there</span>
<span class="sd">            is no raw variable name associated with the parameter.</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Some parameters use reparameterization techniques (like non-centered</span>
<span class="sd">        parameterization) that require separate raw variables. This property</span>
<span class="sd">        returns the appropriate raw variable name when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stan_model_varname</span><span class="si">}</span><span class="s2">_raw&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span></div>



<div class="viewcode-block" id="ContinuousDistribution">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ContinuousDistribution">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContinuousDistribution</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">transformed_parameters</span><span class="o">.</span><span class="n">TransformableParameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parameters with continuous sample spaces.</span>

<span class="sd">    This class extends Parameter to provide functionality specific to continuous</span>
<span class="sd">    probability distributions. It inherits transformation capabilities that</span>
<span class="sd">    enable complex hierarchical model construction.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DiscreteDistribution">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.DiscreteDistribution">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DiscreteDistribution</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parameters with discrete sample spaces.</span>

<span class="sd">    This class extends Parameter for discrete probability distributions,</span>
<span class="sd">    handling the specific requirements of integer-valued random variables.</span>

<span class="sd">    :cvar BASE_STAN_DTYPE: Stan data type for discrete variables (&quot;int&quot;)</span>
<span class="sd">    :cvar LOWER_BOUND: Default lower bound for discrete values (0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">=</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="Normal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Normal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normal (Gaussian) distribution parameter.</span>

<span class="sd">    Implements the normal distribution with location (mu) and scale (sigma)</span>
<span class="sd">    parameters. Supports automatic non-centered parameterization for improved</span>
<span class="sd">    sampling in hierarchical models.</span>

<span class="sd">    :param mu: Location parameter (mean)</span>
<span class="sd">    :type mu: custom_types.ContinuousParameterType</span>
<span class="sd">    :param sigma: Scale parameter (standard deviation)</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param noncentered: Whether to use non-centered parameterization. Defaults to True.</span>
<span class="sd">    :type noncentered: bool</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Normal(μ, σ) where f(x) = (1/(σ√(2π))) * exp(-½((x-μ)/σ)²)</span>

<span class="sd">    Non-Centered Parameterization:</span>
<span class="sd">        When enabled for hierarchical models:</span>
<span class="sd">        - Raw variable: z ~ Normal(0, 1)</span>
<span class="sd">        - Transformed: x = μ + σ * z</span>
<span class="sd">        - Can improve MCMC sampling efficiency</span>

<span class="sd">    The non-centered parameterization is automatically applied when:</span>
<span class="sd">    - noncentered=True (default)</span>
<span class="sd">    - Parameter is not a hyperparameter</span>
<span class="sd">    - Parameter is not observable</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Standard normal parameter</span>
<span class="sd">        &gt;&gt;&gt; mu = Normal(mu=0.0, sigma=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Hierarchical parameter with automatic non-centering</span>
<span class="sd">        &gt;&gt;&gt; y = Normal(mu=mu, sigma=0.5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">noncentered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Build the instance</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Are we using non-centered parameterization?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noncentered</span> <span class="o">=</span> <span class="n">noncentered</span>

<div class="viewcode-block" id="Normal.get_transformation_assignment">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_transformation_assignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformation_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for parameter transformation.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan transformation code (non-centered if applicable)</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For non-centered parameterization, generates:</span>
<span class="sd">        x = mu + sigma .* z_raw</span>

<span class="sd">        Otherwise uses the parent class default transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is centered, then we use the parent method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_transformation_assignment</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Get our formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
        <span class="n">mu_declaration</span><span class="p">,</span> <span class="n">sigma_declaration</span> <span class="o">=</span> <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="n">raw_declaration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span>
        <span class="p">)</span>

        <span class="c1"># Otherwise, we redefine this parameter as the transformation of a draw</span>
        <span class="c1"># from a unit normal distribution</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">mu_declaration</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">sigma_declaration</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;.* </span><span class="si">{</span><span class="n">raw_declaration</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Normal.get_target_incrementation">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_target_incrementation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan target increment with appropriate variable names.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan target increment statement</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For non-centered parameterization, uses the raw variable name</span>
<span class="sd">        in the target increment while the transformed variable is computed</span>
<span class="sd">        in the transformed parameters block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the parent method</span>
        <span class="n">parent_incrementation</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_target_incrementation</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># If not noncentered, we are done</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parent_incrementation</span>

        <span class="c1"># Otherwise, replace the default variable name with the non-centered variable</span>
        <span class="c1"># name</span>
        <span class="n">default_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parent_incrementation</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">default_name</span><span class="si">}</span><span class="s2"> ~&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2"> ~&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Normal.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call for Stan code.</span>

<span class="sd">        For non-centered parameterization, returns &quot;std_normal()&quot; for the</span>
<span class="sd">        raw variable. Otherwise uses the parent implementation with full</span>
<span class="sd">        parameter specification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If not noncentered, run the parent method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
                <span class="n">index_opts</span><span class="p">,</span>
                <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
                <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
                <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
                <span class="n">dist_suffix</span><span class="o">=</span><span class="n">dist_suffix</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Otherwise, make sure we do not have the suffix set and return the standard</span>
        <span class="c1"># normal distribution</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;Non-centered parameters should not have a distribution suffix&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;std_normal()&quot;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_noncentered</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter uses non-centered parameterization.</span>

<span class="sd">        :returns: True if using non-centered parameterization</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Non-centered parameterization is used when:</span>
<span class="sd">        - noncentered flag is True</span>
<span class="sd">        - Parameter is not a hyperparameter</span>
<span class="sd">        - Parameter is not observable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noncentered</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperparameter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span>

    <span class="n">HAS_RAW_VARNAME</span> <span class="o">=</span> <span class="n">is_noncentered</span></div>



<div class="viewcode-block" id="HalfNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.HalfNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HalfNormal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Half-normal distribution parameter (normal truncated at zero).</span>

<span class="sd">    Implements the half-normal distribution, which is a normal distribution</span>
<span class="sd">    truncated to positive values. Commonly used for scale parameters.</span>

<span class="sd">    :param sigma: Scale parameter</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ HalfNormal(σ) where f(x) = (2/(σ√(2π))) * exp(-x²/(2σ²)) for x ≥ 0</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Scale parameter for hierarchical model</span>
<span class="sd">        &gt;&gt;&gt; tau = HalfNormal(sigma=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Individual-level scale</span>
<span class="sd">        &gt;&gt;&gt; sigma_i = HalfNormal(sigma=tau)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">halfnorm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">half_normal</span><span class="o">.</span><span class="n">HalfNormal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="HalfNormal.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.HalfNormal.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>  <span class="c1"># pylint: disable=arguments-differ</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments for Stan (location=0, scale=sigma).</span>

<span class="sd">        :param sigma: Formatted sigma parameter string</span>
<span class="sd">        :type sigma: str</span>

<span class="sd">        :returns: &quot;0, sigma&quot; for Stan normal distribution call</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;0, </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">&quot;</span></div>
</div>



<div class="viewcode-block" id="UnitNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.UnitNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnitNormal</span><span class="p">(</span><span class="n">Normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standard normal distribution (mu=0, sigma=1).</span>

<span class="sd">    Implements the standard normal distribution with fixed parameters.</span>
<span class="sd">    This is a convenience class for the commonly used N(0,1) distribution.</span>

<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ N(0, 1) where f(x) = (1/√(2π)) * exp(-x²/2)</span>

<span class="sd">    The standard normal distribution:</span>
<span class="sd">    - Has fixed parameters that cannot be toggled</span>
<span class="sd">    - Uses the &quot;std_normal&quot; distribution in Stan</span>
<span class="sd">    - Is commonly used for prior specifications</span>
<span class="sd">    - Serves as the basis for non-centered parameterizations</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Standard normal prior</span>
<span class="sd">        &gt;&gt;&gt; z = UnitNormal()</span>
<span class="sd">        &gt;&gt;&gt; # Used in non-centered parameterization</span>
<span class="sd">        &gt;&gt;&gt; x = mu + sigma * z  # Conceptually</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;std_normal&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">noncentered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Sigma is not togglable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">is_togglable</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="UnitNormal.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.UnitNormal.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ, unused-argument</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return empty argument string for Stan std_normal distribution.</span>

<span class="sd">        :param mu: Location parameter (unused for std_normal)</span>
<span class="sd">        :type mu: str</span>
<span class="sd">        :param sigma: Scale parameter (unused for std_normal)</span>
<span class="sd">        :type sigma: str</span>

<span class="sd">        :returns: Empty string (std_normal takes no arguments)</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No arguments needed for the unit normal distribution in Stan.</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>
</div>



<div class="viewcode-block" id="LogNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.LogNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogNormal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Log-normal distribution parameter.</span>

<span class="sd">    Implements the log-normal distribution where log(X) follows a normal</span>
<span class="sd">    distribution. Commonly used for modeling positive quantities with</span>
<span class="sd">    multiplicative effects.</span>

<span class="sd">    :param mu: Location parameter for underlying normal</span>
<span class="sd">    :type mu: custom_types.ContinuousParameterType</span>
<span class="sd">    :param sigma: Scale parameter for underlying normal</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        If Y ~ Normal(μ, σ), then X = exp(Y) ~ LogNormal(μ, σ)</span>
<span class="sd">        f(x) = (1/(xσ√(2π))) * exp(-½((ln(x)-μ)/σ)²) for x &gt; 0</span>


<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Scale parameter with log-normal prior</span>
<span class="sd">        &gt;&gt;&gt; sigma = LogNormal(mu=0.0, sigma=1.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;lognormal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">LogNormal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;s&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="n">_exp_transform</span><span class="p">}</span></div>



<div class="viewcode-block" id="Beta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Beta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Beta</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beta distribution parameter.</span>

<span class="sd">    Implements the beta distribution with shape parameters alpha and beta.</span>
<span class="sd">    The distribution has support on (0, 1) and is commonly used for modeling</span>
<span class="sd">    probabilities and proportions.</span>

<span class="sd">    :param alpha: First shape parameter (concentration)</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Second shape parameter (concentration)</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Beta(α, β) where f(x) = (Γ(α+β)/(Γ(α)Γ(β))) * x^(α-1) * (1-x)^(β-1)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: (0, 1)</span>
<span class="sd">    - Mean: α/(α+β)</span>
<span class="sd">    - Mode: (α-1)/(α+β-2) for α,β &gt; 1</span>
<span class="sd">    - Variance: αβ/((α+β)²(α+β+1))</span>

<span class="sd">    Common Applications:</span>
<span class="sd">    - Prior distributions for probabilities</span>
<span class="sd">    - Modeling proportions and percentages</span>
<span class="sd">    - Bayesian A/B testing</span>
<span class="sd">    - Mixture model component weights</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Uniform prior on probability</span>
<span class="sd">        &gt;&gt;&gt; p = Beta(alpha=1.0, beta=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Weakly informative prior favoring smaller probabilities</span>
<span class="sd">        &gt;&gt;&gt; p_rare = Beta(alpha=1.0, beta=3.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">UPPER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">beta</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">Beta</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration1&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration0&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Gamma">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Gamma">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Gamma</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gamma distribution parameter.</span>

<span class="sd">    Implements the gamma distribution with shape (alpha) and rate (beta)</span>
<span class="sd">    parameters. Commonly used for modeling positive continuous quantities</span>
<span class="sd">    with specific shape characteristics.</span>

<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Rate parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Gamma(α, β) where f(x) = (β^α/Γ(α)) * x^(α-1) * exp(-βx)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: (0, ∞)</span>
<span class="sd">    - Mean: α/β</span>
<span class="sd">    - Mode: (α-1)/β for α &gt; 1</span>
<span class="sd">    - Variance: α/β²</span>

<span class="sd">    Note on Parameterization:</span>
<span class="sd">    - Stan uses shape-rate parameterization: Gamma(α, β)</span>
<span class="sd">    - SciPy uses shape-scale parameterization: Gamma(α, 1/β)</span>
<span class="sd">    - Automatic transformation handles this difference</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Precision parameter (inverse variance)</span>
<span class="sd">        &gt;&gt;&gt; tau = Gamma(alpha=2.0, beta=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Positive continuous variable</span>
<span class="sd">        &gt;&gt;&gt; waiting_time = Gamma(alpha=shape_param, beta=rate_param)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;gamma&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">gamma</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">Gamma</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span></div>



<div class="viewcode-block" id="InverseGamma">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.InverseGamma">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InverseGamma</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inverse gamma distribution parameter.</span>

<span class="sd">    Implements the inverse gamma distribution, commonly used as a conjugate</span>
<span class="sd">    prior for variance parameters in Bayesian analysis.</span>

<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Scale parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ InverseGamma(α, β) where f(x) = (β^α/Γ(α)) * x^(-α-1) * exp(-β/x)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: (0, ∞)</span>
<span class="sd">    - Mean: β/(α-1) for α &gt; 1</span>
<span class="sd">    - Mode: β/(α+1)</span>
<span class="sd">    - Variance: β²/((α-1)²(α-2)) for α &gt; 2</span>

<span class="sd">    Common Applications:</span>
<span class="sd">    - Conjugate prior for normal variance</span>
<span class="sd">    - Hierarchical modeling of scale parameters</span>
<span class="sd">    - Bayesian regression variance modeling</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Prior for variance parameter</span>
<span class="sd">        &gt;&gt;&gt; sigma_sq = InverseGamma(alpha=2.0, beta=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Hierarchical variance</span>
<span class="sd">        &gt;&gt;&gt; tau_sq = InverseGamma(alpha=a_tau, beta=b_tau)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;inv_gamma&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgamma</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">inverse_gamma</span><span class="o">.</span><span class="n">InverseGamma</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Exponential">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Exponential">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Exponential</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exponential distribution parameter.</span>

<span class="sd">    Implements the exponential distribution with rate parameter beta.</span>
<span class="sd">    Commonly used for modeling waiting times and survival analysis.</span>

<span class="sd">    :param beta: Rate parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Exponential(β) where f(x) = β * exp(-βx) for x ≥ 0</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: [0, ∞)</span>
<span class="sd">    - Mean: 1/β</span>
<span class="sd">    - Mode: 0</span>
<span class="sd">    - Variance: 1/β²</span>

<span class="sd">    Note on Parameterization:</span>
<span class="sd">    - Stan uses rate parameterization: Exponential(β)</span>
<span class="sd">    - SciPy uses scale parameterization: Exponential(1/β)</span>
<span class="sd">    - Automatic transformation handles this difference</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Waiting time parameter</span>
<span class="sd">        &gt;&gt;&gt; wait_time = Exponential(beta=1.5)</span>
<span class="sd">        &gt;&gt;&gt; # Scale parameter with exponential prior</span>
<span class="sd">        &gt;&gt;&gt; tau = Exponential(beta=rate_prior)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">expon</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">exponential</span><span class="o">.</span><span class="n">Exponential</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span></div>



<div class="viewcode-block" id="ExpExponential">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpExponential">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpExponential</span><span class="p">(</span><span class="n">Exponential</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exp-Exponential distribution (log of exponential random variable).</span>

<span class="sd">    Implements the distribution of Y where exp(Y) ~ Exponential(β).</span>
<span class="sd">    This is equivalent to Y = log(X) where X ~ Exponential(β).</span>

<span class="sd">    :param beta: Rate parameter for the underlying exponential</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        If X ~ Exponential(β), then Y = log(X) ~ ExpExponential(β)</span>
<span class="sd">        f(y) = β * exp(y - β*exp(y)) for y ∈ (-∞, ∞)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: (-∞, ∞)</span>
<span class="sd">    - Related to Gumbel distribution family</span>
<span class="sd">    - Useful for log-scale modeling of exponential processes</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    `expexponential.stanfunctions` in the `stan` submodule) which are automatically</span>
<span class="sd">    included in any Stan program defined using this distribution.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Log-scale waiting time</span>
<span class="sd">        &gt;&gt;&gt; log_wait = ExpExponential(beta=1.0)</span>
<span class="sd">        &gt;&gt;&gt; # Log-transformed scale parameter</span>
<span class="sd">        &gt;&gt;&gt; log_scale = ExpExponential(beta=prior_rate)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;expexponential&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">expexponential</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpExponential</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span>

<div class="viewcode-block" id="ExpExponential.get_supporting_functions">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpExponential.get_supporting_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the expexponential.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-exponential density and random number generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Exponential distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include expexponential.stanfunctions&quot;</span>
        <span class="p">]</span></div>
</div>



<div class="viewcode-block" id="Lomax">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Lomax">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Lomax</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lomax distribution (Pareto Type II with location=0).</span>

<span class="sd">    Implements the Lomax distribution, which is a special case of the</span>
<span class="sd">    Pareto Type II distribution with location parameter set to 0.</span>

<span class="sd">    :param lambda_: Scale parameter</span>
<span class="sd">    :type lambda_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Lomax(λ, α) where f(x) = (α/λ) * (1 + x/λ)^(-α-1) for x ≥ 0</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: [0, ∞)</span>
<span class="sd">    - Mean: λ/(α-1) for α &gt; 1</span>
<span class="sd">    - Mode: 0</span>
<span class="sd">    - Heavy-tailed distribution</span>

<span class="sd">    Common Applications:</span>
<span class="sd">    - Modeling income distributions</span>
<span class="sd">    - Network analysis (degree distributions)</span>
<span class="sd">    - Reliability engineering</span>
<span class="sd">    - Extreme value modeling</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Heavy-tailed positive variable</span>
<span class="sd">        &gt;&gt;&gt; wealth = Lomax(lambda_=scale_param, alpha=shape_param)</span>
<span class="sd">        &gt;&gt;&gt; # Robust scale parameter</span>
<span class="sd">        &gt;&gt;&gt; sigma = Lomax(lambda_=1.0, alpha=2.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;pareto_type_2&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lomax</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Lomax</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="Lomax.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Lomax.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Format arguments for Stan pareto_type_2 distribution.</span>

<span class="sd">        :param lambda\_: Formatted lambda parameter string</span>
<span class="sd">        :type lambda\_: str</span>
<span class="sd">        :param alpha: Formatted alpha parameter string</span>
<span class="sd">        :type alpha: str</span>

<span class="sd">        :returns: &quot;0.0, lambda\_, alpha&quot; for Stan distribution call</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The Lomax distribution is implemented in Stan as Pareto Type II</span>
<span class="sd">        with location parameter fixed at 0.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;0.0, </span><span class="si">{</span><span class="n">lambda_</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2">&quot;</span></div>
</div>



<div class="viewcode-block" id="ExpLomax">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpLomax">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpLomax</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exp-Lomax distribution (log of Lomax random variable).</span>

<span class="sd">    Implements the distribution of Y where exp(Y) ~ Lomax(λ, α).</span>

<span class="sd">    :param lambda_: Scale parameter for underlying Lomax</span>
<span class="sd">    :type lambda_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param alpha: Shape parameter for underlying Lomax</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        If X ~ Lomax(λ, α), then Y = log(X) ~ ExpLomax(λ, α)</span>
<span class="sd">        f(y) = (α/λ) * exp(y) * (1 + exp(y)/λ)^(-α-1) for y ∈ (-∞, ∞)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: (-∞, ∞)</span>
<span class="sd">    - Log-scale version of heavy-tailed Lomax</span>
<span class="sd">    - Useful for modeling log-transformed heavy-tailed data</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    `explomax.stanfunctions` in the `stan` submodule) which are automatically</span>
<span class="sd">    included in any Stan program defined using this distribution.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Log-scale heavy-tailed variable</span>
<span class="sd">        &gt;&gt;&gt; log_income = ExpLomax(lambda_=scale, alpha=shape)</span>
<span class="sd">        &gt;&gt;&gt; # Robust log-scale parameter</span>
<span class="sd">        &gt;&gt;&gt; log_sigma = ExpLomax(lambda_=1.0, alpha=2.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;explomax&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">explomax</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpLomax</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="ExpLomax.get_supporting_functions">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpLomax.get_supporting_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the explomax.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-Lomax density and random number generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Lomax distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;#include explomax.stanfunctions&quot;</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="Dirichlet">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Dirichlet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dirichlet</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dirichlet distribution parameter.</span>

<span class="sd">    Implements the Dirichlet distribution for modeling probability simplexes.</span>
<span class="sd">    The distribution generates vectors that sum to 1, making it ideal for</span>
<span class="sd">    modeling categorical probabilities and mixture weights.</span>

<span class="sd">    :param alpha: Concentration parameters (can be scalar or array-like). If scalar,</span>
<span class="sd">        will be converted to the appropriate shape given by the `shape` kwarg.</span>
<span class="sd">    :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">    :param kwargs: Additional keyword arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Dirichlet(α) where f(x) = (Γ(Σαᵢ)/Πᵢ Γ(αᵢ)) * Πᵢ xᵢ^(αᵢ-1)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: K-dimensional simplex (Σxᵢ = 1, xᵢ &gt; 0)</span>
<span class="sd">    - Mean: E[Xᵢ] = αᵢ/Σαⱼ</span>
<span class="sd">    - Mode: (αᵢ-1)/(Σαⱼ-K) for all αᵢ &gt; 1</span>

<span class="sd">    Parameter Handling:</span>
<span class="sd">    - If alpha is scalar, &#39;shape&#39; must be provided to create uniform concentration</span>
<span class="sd">    - If alpha is array-like, it defines the concentration for each component</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Uniform Dirichlet (symmetric)</span>
<span class="sd">        &gt;&gt;&gt; p = Dirichlet(alpha=1.0, shape=(3,))</span>
<span class="sd">        &gt;&gt;&gt; # Non-uniform concentrations</span>
<span class="sd">        &gt;&gt;&gt; p = Dirichlet(alpha=np.array([0.5, 1.0, 2.0]))</span>
<span class="sd">        &gt;&gt;&gt; # Hierarchical concentration</span>
<span class="sd">        &gt;&gt;&gt; p = Dirichlet(alpha=alpha_prior)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span> <span class="o">=</span> <span class="s2">&quot;simplex&quot;</span>
    <span class="n">IS_SIMPLEX</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;dirichlet&quot;</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">dirichlet</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">dirichlet</span><span class="o">.</span><span class="n">Dirichlet</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dirichlet distribution with concentration parameters.</span>

<span class="sd">        :param alpha: Concentration parameters for each component</span>
<span class="sd">        :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">        :param kwargs: Additional arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">        :raises ValueError: If alpha is scalar but &#39;shape&#39; is not provided</span>

<span class="sd">        The initialization handles both scalar and vector specifications of</span>
<span class="sd">        concentration parameters, automatically creating uniform arrays when</span>
<span class="sd">        a scalar value is provided with an explicit shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a float or int is provided, then &quot;shape&quot; must be provided too. We will</span>
        <span class="c1"># create a numpy array filled of that shape filled with the value</span>
        <span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s2">&quot;shape&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If alpha is a float or int, then shape must be provided&quot;</span>
                <span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Run the init method of the class one level up in the MRO hierarchy</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Set `enforce_uniformity` appropriately</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="n">enforce_uniformity</span>  <span class="c1"># pylint: disable=no-member</span></div>



<div class="viewcode-block" id="ExpDirichlet">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpDirichlet</span><span class="p">(</span><span class="n">Dirichlet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exp-Dirichlet distribution (log of Dirichlet random variable).</span>

<span class="sd">    Implements the distribution of Y where exp(Y) ~ Dirichlet(α).</span>
<span class="sd">    This provides a log-simplex parameterization that can be more numerically</span>
<span class="sd">    stable for extreme concentration parameters and extremely high-dimensional</span>
<span class="sd">    simplexes, like those encountered when modeling deep mutational scanning data.</span>

<span class="sd">    :param alpha: Concentration parameters for underlying Dirichlet</span>
<span class="sd">    :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">    :param kwargs: Additional keyword arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        If X ~ Dirichlet(α), then Y = log(X) ~ ExpDirichlet(α)</span>
<span class="sd">        where Σexp(Yᵢ) = 1 (log-simplex constraint)</span>

<span class="sd">    Properties:</span>

<span class="sd">    - Support: Log-simplex {y : Σexp(yᵢ) = 1}</span>
<span class="sd">    - Raw parameterization uses K-1 dimensions with constraint transformation</span>
<span class="sd">    - More numerically stable for extreme concentrations</span>

<span class="sd">    Stan Implementation:</span>

<span class="sd">    - Uses custom constraint functions for log-simplex transformation</span>
<span class="sd">    - Raw parameter has K-1 dimensions (reduced for constraint)</span>
<span class="sd">    - Special thanks to Sean Pinkney for assistance with deriving the log probability</span>
<span class="sd">      density function; thanks also to Bob Carpenter and others for developing the</span>
<span class="sd">      log-simplex constraint used in SciStanPy. See</span>
<span class="sd">      `here &lt;https://discourse.mc-stan.org/t/log-simplex-constraints/39782&gt;_` for</span>
<span class="sd">      derivations and</span>
<span class="sd">      `here &lt;https://github.com/bob-carpenter/transforms/tree/main/simplex_transforms/stan/transforms&gt;`_</span>
<span class="sd">      for transforms.</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    `expdirichlet.stanfunctions` in the `stan` submodule) which are automatically</span>
<span class="sd">    included in any Stan program defined using this distribution.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Log-simplex probabilities</span>
<span class="sd">        &gt;&gt;&gt; log_p = ExpDirichlet(alpha=alpha_vec)</span>
<span class="sd">        &gt;&gt;&gt; # Numerically stable log-probabilities</span>
<span class="sd">        &gt;&gt;&gt; log_weights = ExpDirichlet(alpha=1.0, shape=(10,))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span> <span class="o">=</span> <span class="s2">&quot;real&quot;</span>
    <span class="n">IS_SIMPLEX</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">IS_LOG_SIMPLEX</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">UPPER_BOUND</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;expdirichlet&quot;</span>
    <span class="n">HAS_RAW_VARNAME</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">expdirichlet</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpDirichlet</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="ExpDirichlet.get_supporting_functions">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet.get_supporting_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the expdirichlet.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-Dirichlet density, constraint functions, and transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Dirichlet distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include expdirichlet.stanfunctions&quot;</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="ExpDirichlet.get_transformation_assignment">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet.get_transformation_assignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformation_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for log-simplex constraint transformation.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan transformation code with Jacobian adjustment</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Applies the inverse ILR (isometric log-ratio) transformation to</span>
<span class="sd">        convert from unconstrained K-1 dimensional space to log-simplex</span>
<span class="sd">        while automatically handling the Jacobian adjustment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We constrain and adjust the Jacobian for the transformation</span>
        <span class="n">raw_varname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span>
        <span class="p">)</span>
        <span class="n">transformed_varname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">transformed_varname</span><span class="si">}</span><span class="s2"> = inv_ilr_log_simplex_constrain_jacobian(</span><span class="si">{</span><span class="n">raw_varname</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="ExpDirichlet.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call with appropriate normalization suffix.</span>

<span class="sd">        When ExpDirichlet is used as a hyperparameter, the normalization coefficient</span>
<span class="sd">        is a constant and so will be ignored during MCMC to improve computational</span>
<span class="sd">        efficiency. When ExpDirichlet is not a hyperparameter (values for `alpha`</span>
<span class="sd">        are not constant), the normalized version is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no suffix is provided, determine whether we are using the normalized</span>
        <span class="c1"># or unnormalized version of the distribution. We use unnormalized when</span>
        <span class="c1"># the parameter is a hyperparameter with no parents.</span>
        <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;unnorm&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperparameter</span> <span class="k">else</span> <span class="s2">&quot;norm&quot;</span>

        <span class="c1"># Now we just run the parent method</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
            <span class="n">dist_suffix</span><span class="o">=</span><span class="n">dist_suffix</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ExpDirichlet.get_raw_stan_parameter_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet.get_raw_stan_parameter_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_raw_stan_parameter_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate declaration for raw parameter with reduced dimensions.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan parameter declaration for K-1 dimensional raw variable</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The raw parameter has K-1 dimensions instead of K to account for</span>
<span class="sd">        the simplex constraint. This raw variable is transformed to create the</span>
<span class="sd">        log-simplex constrained value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the parent method to get the raw variable name</span>
        <span class="n">raw_varname</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_raw_stan_parameter_declaration</span><span class="p">(</span>
            <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
        <span class="p">)</span>

        <span class="c1"># We should always have a raw variable name if we are using the Exp-Dirichlet</span>
        <span class="k">assert</span> <span class="n">raw_varname</span><span class="p">,</span> <span class="s2">&quot;Raw variable name should not be empty for Exp-Dirichlet&quot;</span>

        <span class="c1"># Every ExpDirichlet will have a &#39;vector&lt;upper=0.0&gt;[K]&#39; datatype. We want</span>
        <span class="c1"># to split the raw variable name on this signature</span>
        <span class="n">array_info</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">var_info</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(.*)vector&lt;upper=0.0&gt;\[([0-9]+)\](.+)&quot;</span><span class="p">,</span> <span class="n">raw_varname</span>
        <span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Remove extra dimension for the raw variable</span>

        <span class="c1"># Reconstruct the raw variable name with the correct number of dimensions.</span>
        <span class="c1"># Note that there is no upper bound on the raw variable</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_info</span><span class="si">}</span><span class="s2">vector[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]</span><span class="si">{</span><span class="n">var_info</span><span class="si">}</span><span class="s2">&quot;</span></div>
</div>



<div class="viewcode-block" id="Binomial">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Binomial">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Binomial</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Binomial distribution parameter.</span>

<span class="sd">    Implements the binomial distribution for modeling the number of successes</span>
<span class="sd">    in a fixed number of independent Bernoulli trials.</span>

<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param theta: Success probability</span>
<span class="sd">    :type theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Binomial(N, θ) where P(X = k) = C(N,k) * θᵏ * (1-θ)^(N-k)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: {0, 1, 2, ..., N}</span>
<span class="sd">    - Mean: N * θ</span>
<span class="sd">    - Variance: N * θ * (1-θ)</span>
<span class="sd">    - Mode: floor((N+1) * θ)</span>

<span class="sd">    Common Applications:</span>
<span class="sd">    - Number of successes in fixed trials</span>
<span class="sd">    - Proportion data with known denominators</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Number of successes in 10 trials</span>
<span class="sd">        &gt;&gt;&gt; successes = Binomial(N=10, theta=success_prob)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;binomial&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">binom</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binomial</span><span class="o">.</span><span class="n">Binomial</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;p&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;probs&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Poisson">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Poisson">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Poisson</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Poisson distribution parameter.</span>

<span class="sd">    Implements the Poisson distribution for modeling count data with</span>
<span class="sd">    a single rate parameter.</span>

<span class="sd">    :param lambda_: Rate parameter (mean number of events)</span>
<span class="sd">    :type lambda_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Poisson(λ) where P(X = k) = (λᵏ * exp(-λ)) / k!</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: {0, 1, 2, 3, ...}</span>
<span class="sd">    - Mean: λ</span>
<span class="sd">    - Variance: λ</span>
<span class="sd">    - Mode: floor(λ)</span>

<span class="sd">    Common Applications:</span>
<span class="sd">    - Event counting (arrivals, defects, etc.)</span>
<span class="sd">    - Modeling rare events</span>
<span class="sd">    - Count regression</span>
<span class="sd">    - Queueing theory</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Number of events per time period</span>
<span class="sd">        &gt;&gt;&gt; counts = Poisson(lambda_=event_rate)</span>
<span class="sd">        &gt;&gt;&gt; # Observed count data</span>
<span class="sd">        &gt;&gt;&gt; y_counts = Poisson(lambda_=fitted_rate).as_observable()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">Poisson</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;mu&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">_MultinomialBase</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for multinomial distribution variants.</span>

<span class="sd">    This abstract base class provides common functionality for different</span>
<span class="sd">    parameterizations of the multinomial distribution. It handles the</span>
<span class="sd">    special case where the number of trials (N) is implicit in Stan</span>
<span class="sd">    but explicit in SciPy/PyTorch interfaces.</span>

<span class="sd">    The class automatically handles parameter transformation and provides</span>
<span class="sd">    custom target incrementation that removes the N parameter from Stan</span>
<span class="sd">    distribution calls since it&#39;s implicit in the multinomial definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_TO_NP_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>  <span class="c1"># Squeeze the N parameter to match the numpy distribution&#39;s expected shape</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate target increment with N parameter removed.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan target increment without N parameter</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The multinomial distribution in Stan doesn&#39;t explicitly include</span>
<span class="sd">        the number of trials N in the function call, so this method</span>
<span class="sd">        removes it from the generated code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to strip the N parameter from the declaration as this is implicit</span>
        <span class="c1"># in the distribution as defined in Stan</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_target_incrementation</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Remove the N parameter</span>
        <span class="o">*</span><span class="n">raw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>


<div class="viewcode-block" id="Multinomial">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Multinomial">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Multinomial</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standard multinomial distribution parameter.</span>

<span class="sd">    Implements the multinomial distribution with probability vector theta</span>
<span class="sd">    and number of trials N. Models the number of observations in each</span>
<span class="sd">    category for a fixed number of trials.</span>

<span class="sd">    :param theta: Probability vector (must sum to 1)</span>
<span class="sd">    :type theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        X ~ Multinomial(N, θ) where P(X = x) = (N! / Πᵢ xᵢ!) * Πᵢ θᵢ^xᵢ</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Support: {x : Σxᵢ = N, xᵢ ≥ 0}</span>
<span class="sd">    - Mean: E[Xᵢ] = N * θᵢ</span>
<span class="sd">    - Variance: Var[Xᵢ] = N * θᵢ * (1 - θᵢ)</span>
<span class="sd">    - Covariance: Cov[Xᵢ, Xⱼ] = -N * θᵢ * θⱼ</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Categorical data with known totals</span>
<span class="sd">        &gt;&gt;&gt; counts = Multinomial(theta=category_probs, N=total_trials)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SIMPLEX_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Multinomial</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;probs&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="MultinomialLogit">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogit">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MultinomialLogit</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multinomial distribution with logit parameterization.</span>

<span class="sd">    Implements the multinomial distribution parameterized by logits (gamma)</span>
<span class="sd">    rather than probabilities.</span>

<span class="sd">    :param gamma: Logit vector (unconstrained real values)</span>
<span class="sd">    :type gamma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        θᵢ = exp(γᵢ) / Σⱼ exp(γⱼ) (softmax transformation)</span>
<span class="sd">        X ~ Multinomial(N, θ)</span>

<span class="sd">    Properties:</span>
<span class="sd">    - Unconstrained parameterization (γ ∈ ℝᴷ)</span>
<span class="sd">    - Natural for logistic regression extensions</span>
<span class="sd">    - Automatic softmax transformation applied</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Logit-parameterized multinomial</span>
<span class="sd">        &gt;&gt;&gt; counts = MultinomialLogit(gamma=logit_probs, N=total_trials)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial_logit&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial_logit</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">MultinomialLogit</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="s2">&quot;logits&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="s2">&quot;logits&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="MultinomialLogTheta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogTheta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MultinomialLogTheta</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multinomial distribution with log-probability parameterization.</span>

<span class="sd">    Implements the multinomial distribution in terms of the log of the theta</span>
<span class="sd">    parameter. This parameterization is useful for models that naturally</span>
<span class="sd">    work with log-probabilities. It can use the ExpDirichlet distribution as a</span>
<span class="sd">    prior to enforce the log-simplex constraint and keep computations completely</span>
<span class="sd">    in the log-probability space.</span>

<span class="sd">    :param log_theta: Log probability vector (log-simplex constraint)</span>
<span class="sd">    :type log_theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        θᵢ = exp(log_θᵢ) (with normalization: Σⱼ exp(log_θⱼ) = 1)</span>
<span class="sd">        X ~ Multinomial(N, θ)</span>

<span class="sd">    Properties:</span>

<span class="sd">    - Log-simplex parameterization</span>
<span class="sd">    - Numerically stable for small probabilities</span>
<span class="sd">    - Optional multinomial coefficient pre-computation</span>

<span class="sd">    Special Features:</span>

<span class="sd">    - Automatic multinomial coefficient calculation when used as observable. This</span>
<span class="sd">      results in improved computational efficiency by eliminating redundant calculations.</span>
<span class="sd">    - Coefficient removed when parameter has other children</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    `multinomial.stanfunctions` in the `stan` submodule) which are automatically</span>
<span class="sd">    included in any Stan program defined using this distribution.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Log-probability parameterized multinomial</span>
<span class="sd">        &gt;&gt;&gt; counts = MultinomialLogTheta(log_theta=log_probs, N=total_trials)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOG_SIMPLEX_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial_logtheta&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial_log_theta</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">MultinomialLogTheta</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">:</span> <span class="s2">&quot;log_p&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">:</span> <span class="s2">&quot;log_probs&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">log_theta</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="s2">&quot;custom_types.DiscreteParameterType&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MultinomialLogTheta with automatic coefficient handling.</span>

<span class="sd">        :param log_theta: Log probability parameter</span>
<span class="sd">        :type log_theta: custom_types.ContinuousParameterType</span>
<span class="sd">        :param N: Number of trials parameter</span>
<span class="sd">        :type N: custom_types.DiscreteParameterType</span>
<span class="sd">        :param kwargs: Additional keyword arguments</span>

<span class="sd">        The initialization automatically creates a multinomial coefficient</span>
<span class="sd">        component that is removed if the parameter gains children (indicating</span>
<span class="sd">        it&#39;s not an observable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Init the parent class with the appropriate parameters</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">log_theta</span><span class="o">=</span><span class="n">log_theta</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># By default, we allow a multinomial coefficient to be pre-calculated. This</span>
        <span class="c1"># assumes that the instance will be an observable parameter, so we modify</span>
        <span class="c1"># the `_record_child` function to remove the coefficient as soon as something</span>
        <span class="c1"># is added to the children.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span> <span class="o">=</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_record_child</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle removal of coefficient when parameter gains children.</span>

<span class="sd">        :param child: Child component being added</span>
<span class="sd">        :type child: AbstractModelComponent</span>

<span class="sd">        This method manages the multinomial coefficient based on the parameter&#39;s</span>
<span class="sd">        role in the model. The coefficient is automatically removed when the</span>
<span class="sd">        parameter gains non-coefficient children, indicating it&#39;s not purely</span>
<span class="sd">        an observable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is not a multinomial coefficient, then we have to remove that</span>
        <span class="c1"># coefficient from the children.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Otherwise, the list of children must be empty, as the coefficient will</span>
        <span class="c1"># be the first child added.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Run the parent method to record the child</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_record_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<div class="viewcode-block" id="MultinomialLogTheta.get_supporting_functions">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogTheta.get_supporting_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the multinomial.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for efficient</span>
<span class="sd">        computation of the multinomial log-theta density and normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include multinomial.stanfunctions&quot;</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="MultinomialLogTheta.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogTheta.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ, arguments-renamed</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">log_theta</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments with optional coefficient.</span>

<span class="sd">        :param log_theta: Formatted log_theta parameter string</span>
<span class="sd">        :type log_theta: str</span>
<span class="sd">        :param N: Formatted N parameter string</span>
<span class="sd">        :type N: str</span>
<span class="sd">        :param coeff: Formatted coefficient string (optional). Defaults to &quot;&quot;.</span>
<span class="sd">        :type coeff: str</span>

<span class="sd">        :returns: Formatted argument string for Stan distribution call</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The method handles inclusion of the multinomial coefficient when available,</span>
<span class="sd">        enabling more efficient computation by pre-calculating constant terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the coefficient is provided, insert it in the middle of the arguments.</span>
        <span class="c1"># Otherwise, just return the log_theta and N parameters. This is a bit of</span>
        <span class="c1"># a hack to make sure that &quot;N&quot; is stripped off by `get_target_incrementation`</span>
        <span class="c1"># regardless of whether the coefficient is provided or not.</span>
        <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">log_theta</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">log_theta</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="MultinomialLogTheta.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogTheta.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call with appropriate normalization and coefficients.</span>

<span class="sd">        :param index_opts: See parent method for details.</span>
<span class="sd">        :type index_opts: Optional[tuple[str, ...]]</span>
<span class="sd">        :param start_dims: See parent method for details.</span>
<span class="sd">        :type start_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param end_dims: See parent method for details.</span>
<span class="sd">        :type end_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param offset_adjustment: See parent method for details.</span>
<span class="sd">        :type offset_adjustment: int</span>
<span class="sd">        :param dist_suffix: Distribution function suffix</span>
<span class="sd">        :type dist_suffix: str</span>

<span class="sd">        :returns: Stan distribution call with proper normalization</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The method automatically selects between manual normalization (with</span>
<span class="sd">        coefficient) and standard normalization based on coefficient availability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If no suffix is provided and this is an observable, we want to add the</span>
        <span class="c1"># coefficient to the set of formattables and use manual normalization.</span>
        <span class="c1"># Otherwise, we just use the standard normalization.</span>
        <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;norm&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;coeff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
                <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;manual_norm&quot;</span>

        <span class="c1"># Build the right side</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">STAN_DIST</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">dist_suffix</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">write_dist_args</span><span class="p">(</span><span class="o">**</span><span class="n">formattables</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the multinomial coefficient component if it exists.</span>

<span class="sd">        :returns: Multinomial coefficient component or None</span>
<span class="sd">        :rtype: Optional[LogMultinomialCoefficient]</span>

<span class="sd">        The coefficient is automatically created for observable parameters</span>
<span class="sd">        and removed when the parameter gains other children, optimizing</span>
<span class="sd">        computation by pre-calculating constant terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">SciStanPy API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../scistanpy.html">scistanpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Bruce Wittmann.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>