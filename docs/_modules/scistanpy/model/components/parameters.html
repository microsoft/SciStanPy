<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scistanpy.model.components.parameters &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scistanpy.model.components.parameters</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation.</span>
<span class="c1"># Licensed under the MIT license.</span>

<span class="sd">&quot;&quot;&quot;Parameter classes for defining probabilistic model components in SciStanPy.</span>

<span class="sd">This module provides the core parameter classes that serve as building blocks for</span>
<span class="sd">constructing probabilistic models in SciStanPy. These classes represent random</span>
<span class="sd">variables with specific probability distributions and handle the complex task of</span>
<span class="sd">translating between Python model specifications, PyTorch modules, and Stan probabilistic</span>
<span class="sd">programming language code.</span>

<span class="sd">The parameter classes are designed to be composable, allowing complex hierarchical</span>
<span class="sd">models to be built through simple parameter relationships while maintaining</span>
<span class="sd">mathematical rigor and computational efficiency.</span>

<span class="sd">The following distributions are currently supported in SciStanPy:</span>

<span class="sd">Continuous Univariate</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Normal`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.HalfNormal`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.UnitNormal`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.LogNormal`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Beta`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Gamma`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.InverseGamma`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Exponential`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.ExpExponential`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Lomax`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.ExpLomax`</span>

<span class="sd">Continuous Multivariate</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Dirichlet`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.ExpDirichlet`</span>

<span class="sd">Discrete Univariate</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Binomial`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Poisson`</span>

<span class="sd">Discrete Multivariate</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.Multinomial`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.MultinomialLogit`</span>
<span class="sd">- :py:class:`~scistanpy.model.components.parameters.MultinomialLogTheta`</span>

<span class="sd">Is there a distribution you need that isn&#39;t listed here? Please open an issue or</span>
<span class="sd">submit a PR!</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.distributions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">scistanpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstract_model_component</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.custom_distributions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">custom_scipy_dists</span><span class="p">,</span>
    <span class="n">custom_torch_dists</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.transformations</span><span class="w"> </span><span class="kn">import</span> <span class="n">transformed_parameters</span>

<span class="n">cdfs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.components.transformations.cdfs&quot;</span><span class="p">)</span>
<span class="n">constants</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;scistanpy.model.components.constants&quot;</span><span class="p">)</span>
<span class="n">transformed_data</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lazy_import</span><span class="p">(</span>
    <span class="s2">&quot;scistanpy.model.components.transformations.transformed_data&quot;</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">custom_types</span>

<span class="c1"># pylint: disable=too-many-lines, line-too-long</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">]:</span> <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply element-wise inverse transformation (1/x).</span>

<span class="sd">    Simple inverse transformation function for parameter transformations.</span>
<span class="sd">    Defined at module level to avoid pickling issues with lambda functions.</span>

<span class="sd">    :param x: Input value(s) to transform</span>
<span class="sd">    :type x: Union[npt.NDArray[np.floating], custom_types.Float]</span>

<span class="sd">    :returns: Element-wise inverse of input</span>
<span class="sd">    :rtype: Union[npt.NDArray[np.floating], custom_types.Float]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">]:</span> <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_exp_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply element-wise exponential transformation.</span>

<span class="sd">    Simple exponential transformation function for parameter transformations.</span>
<span class="sd">    Defined at module level to avoid pickling issues with lambda functions.</span>

<span class="sd">    :param x: Input array to transform</span>
<span class="sd">    :type x: npt.NDArray[np.floating]</span>

<span class="sd">    :returns: Element-wise exponential of input</span>
<span class="sd">    :rtype: npt.NDArray[np.floating]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># TODO: Make sure samples from torch distributions obey the same bounds as noted</span>
<span class="c1"># in the classes.</span>
<span class="c1"># TODO: Make sure samples from Stan distributions obey the same bounds as noted</span>
<span class="c1"># in the classes.</span>


<div class="viewcode-block" id="ParameterMeta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ParameterMeta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParameterMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Metaclass for automatic CDF transform class generation.</span>

<span class="sd">    :param name: Name of the class being created</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param bases: Base classes for the new class</span>
<span class="sd">    :type bases: tuple</span>
<span class="sd">    :param attrs: Class attributes dictionary</span>
<span class="sd">    :type attrs: dict</span>

<span class="sd">    This metaclass automatically creates cumulative distribution function (CDF)</span>
<span class="sd">    and related transform classes for each Parameter subclass, enabling automatic</span>
<span class="sd">    generation of probabilistic transforms and survival functions.</span>

<span class="sd">    The metaclass creates four transform classes for each parameter and assigns</span>
<span class="sd">    them to the following class variables:</span>

<span class="sd">        - :py:attr:`Parameter.CDF &lt;scistanpy.model.components.parameters.Parameter.CDF&gt;`,</span>
<span class="sd">          based on the :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">          cdfs.CDF` class and describing the cumulative distribution function for</span>
<span class="sd">          the parameter.</span>
<span class="sd">        - :py:attr:`Parameter.SF &lt;scistanpy.model.components.parameters.Parameter.SF&gt;`,</span>
<span class="sd">          based on the :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">          cdfs.SurvivalFunction` class and describing the survival function (1 - CDF)</span>
<span class="sd">          for the parameter.</span>
<span class="sd">        - :py:attr:`Parameter.LOG_CDF &lt;scistanpy.model.components.parameters.Parameter.</span>
<span class="sd">          LOG_CDF&gt;`, based on the :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">          cdfs.LogCDF` class and describing the logarithmic cumulative distribution</span>
<span class="sd">          function for the parameter.</span>
<span class="sd">        - :py:attr:`Parameter.LOG_SF &lt;scistanpy.model.components.parameters.Parameter.</span>
<span class="sd">          LOG_SF&gt;`, based on the :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">          cdfs.LogSurvivalFunction` class and describing the logarithmic survival</span>
<span class="sd">          function for the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create CDF transform classes for the Parameter subclass.&quot;&quot;&quot;</span>
        <span class="c1"># Run the parent class&#39;s __init__ method</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Add CDF, SF, LOG_CDF, and LOG_SF classes to the Parameter subclass</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">CDF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="s2">&quot;CDF&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">CDF</span><span class="p">,),</span>
            <span class="p">{</span>
                <span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">,</span>
                <span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="s2">&quot;__qualname__&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.CDF&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">SF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="s2">&quot;SF&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">SurvivalFunction</span><span class="p">,),</span>
            <span class="p">{</span>
                <span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">,</span>
                <span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="s2">&quot;__qualname__&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.SF&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_CDF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="s2">&quot;LOG_CDF&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogCDF</span><span class="p">,),</span>
            <span class="p">{</span>
                <span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">,</span>
                <span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="s2">&quot;__qualname__&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.LOG_CDF&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_SF</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="s2">&quot;LOG_SF&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogSurvivalFunction</span><span class="p">,),</span>
            <span class="p">{</span>
                <span class="s2">&quot;PARAMETER&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">,</span>
                <span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="s2">&quot;__qualname__&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.LOG_SF&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="ClassOrInstanceMethod">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ClassOrInstanceMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassOrInstanceMethod</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Descriptor used as a decorator to enable dual class/instance method behavior.</span>

<span class="sd">    This descriptor allows methods to behave differently when called as class</span>
<span class="sd">    methods versus instance methods, enabling flexible parameter handling for</span>
<span class="sd">    CDF-like functions that can use either explicit parameters or instance</span>
<span class="sd">    parameter values.</span>

<span class="sd">    :param func: Function to wrap with dual behavior</span>
<span class="sd">    :type func: Callable</span>

<span class="sd">    When called as an instance method, the descriptor automatically uses the</span>
<span class="sd">    instance&#39;s parameter values. When called as a class method, it requires</span>
<span class="sd">    explicit parameter specification.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

<div class="viewcode-block" id="ClassOrInstanceMethod.__get__">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ClassOrInstanceMethod.__get__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return appropriate method based on call context.</span>

<span class="sd">        :param instance: Instance object if called as instance method, None for class method</span>
<span class="sd">        :param owner: Class that owns the method</span>

<span class="sd">        :returns: Configured method with appropriate parameter handling</span>
<span class="sd">        :rtype: Callable</span>

<span class="sd">        The returned method automatically handles parameter passing based on</span>
<span class="sd">        whether it&#39;s called as a class or instance method, validating required</span>
<span class="sd">        parameters and applying appropriate transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># `x` must always be a kwarg</span>
            <span class="k">if</span> <span class="s2">&quot;x&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected `x` to be a keyword argument for the CDF-like methods.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Check for extra kwargs</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">extra_kwargs</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">owner</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">}</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected arguments passed to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extra_kwargs</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># If the instance is not provided, then kwargs must be provided</span>
            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Check for missing kwargs</span>
                <span class="k">if</span> <span class="n">missing_kwargs</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">owner</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;If calling </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> as a static method, the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;following parameters must be provided: </span><span class="si">{</span><span class="n">missing_kwargs</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Run the wrapped method using provided kwargs</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># If the instance is not provided, we run the wrapped method using the</span>
            <span class="c1"># parent parameter values</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                <span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">instance</span><span class="o">.</span><span class="n">_parents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># pylint: disable=protected-access</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inner</span></div>
</div>



<div class="viewcode-block" id="Parameter">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Parameter</span><span class="p">(</span>
    <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ParameterMeta</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all probabilistic parameters in SciStanPy models.</span>

<span class="sd">    This class provides the foundational infrastructure for representing random</span>
<span class="sd">    variables with specific probability distributions. It handles the complex</span>
<span class="sd">    mapping between Python model specifications and Stan code generation while</span>
<span class="sd">    providing integration with SciPy and PyTorch ecosystems.</span>

<span class="sd">    :param kwargs: Distribution parameters (mu, sigma, etc. depending on subclass)</span>

<span class="sd">    :raises NotImplementedError: If required class attributes are missing (i.e.,</span>
<span class="sd">        if subclass was incorrectly defined)</span>
<span class="sd">    :raises TypeError: If required distribution parameters are missing</span>

<span class="sd">    :cvar STAN_DIST: Stan distribution name for code generation</span>
<span class="sd">    :type STAN_DIST: str</span>
<span class="sd">    :cvar HAS_RAW_VARNAME: Whether parameter uses a raw/transformed parameterization</span>
<span class="sd">    :type HAS_RAW_VARNAME: bool</span>
<span class="sd">    :cvar SCIPY_DIST: Corresponding SciPy distribution class</span>
<span class="sd">    :type SCIPY_DIST: Optional[Union[type[stats.rv_continuous], type[stats.rv_discrete]]]</span>
<span class="sd">    :cvar TORCH_DIST: Corresponding PyTorch distribution class</span>
<span class="sd">    :type TORCH_DIST: Optional[Union[type[dist.distribution.Distribution],</span>
<span class="sd">        type[custom_torch_dists.CustomDistribution]]]</span>
<span class="sd">    :cvar STAN_TO_SCIPY_NAMES: Parameter name mapping for SciPy interface</span>
<span class="sd">    :type STAN_TO_SCIPY_NAMES: dict[str, str]</span>
<span class="sd">    :cvar STAN_TO_TORCH_NAMES: Parameter name mapping for PyTorch interface</span>
<span class="sd">    :type STAN_TO_TORCH_NAMES: dict[str, str]</span>
<span class="sd">    :cvar STAN_TO_SCIPY_TRANSFORMS: Parameter transformation functions converting between</span>
<span class="sd">        Stan and SciPy parametrizations</span>
<span class="sd">    :type STAN_TO_SCIPY_TRANSFORMS: dict[str, Callable[[npt.NDArray], npt.NDArray]]</span>
<span class="sd">    :cvar CDF: Automatically generated :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">        cdfs.CDF` class.</span>
<span class="sd">    :type CDF: type[cdfs.CDF]</span>
<span class="sd">    :cvar SF: Automatically generated :py:class:`~scistanpy.model.components.transformations.</span>
<span class="sd">        cdfs.SurvivalFunction` class.</span>
<span class="sd">    :type SF: type[cdfs.SurvivalFunction]</span>
<span class="sd">    :cvar LOG_CDF: Automatically generated :py:class:`~scistanpy.model.components.</span>
<span class="sd">        transformations.cdfs.LogCDF` class.</span>
<span class="sd">    :type LOG_CDF: type[cdfs.LogCDF]</span>
<span class="sd">    :cvar LOG_SF: Automatically generated :py:class:`~scistanpy.model.components.</span>
<span class="sd">        transformations.cdfs.LogSurvivalFunction` class.</span>
<span class="sd">    :type LOG_SF: type[cdfs.LogSurvivalFunction]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the distribution in Stan code (e.g. &quot;normal&quot;, &quot;binomial&quot;).&quot;&quot;&quot;</span>

    <span class="n">HAS_RAW_VARNAME</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether the parameter intrinsically uses a raw/transformed parameterization.&quot;&quot;&quot;</span>

    <span class="n">CDF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">CDF</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of :py:class:`~scistanpy.model.components.transformations.cdfs.CDF`</span>
<span class="sd">    describing the cumulative distribution function for the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">SurvivalFunction</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of :py:class:`~scistanpy.model.components.transformations.cdfs.SurvivalFunction`</span>
<span class="sd">    describing the survival function for the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOG_CDF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogCDF</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of :py:class:`~scistanpy.model.components.transformations.cdfs.LogCDF`</span>
<span class="sd">    describing the log cumulative distribution function for the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOG_SF</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">cdfs</span><span class="o">.</span><span class="n">LogSurvivalFunction</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of :py:class:`~scistanpy.model.components.transformations.cdfs.LogSurvivalFunction`</span>
<span class="sd">    describing the log survival function for the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SCIPY_DIST</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_continuous</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_discrete</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corresponding SciPy distribution class (e.g., `scipy.stats.norm`).&quot;&quot;&quot;</span>

    <span class="n">TORCH_DIST</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">type</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">distribution</span><span class="o">.</span><span class="n">Distribution</span><span class="p">]</span>
        <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">CustomDistribution</span><span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corresponding PyTorch distribution class (e.g., `torch.distributions.Normal`).&quot;&quot;&quot;</span>

    <span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    There can be differences in parameter names between Stan and SciPy. This dictionary</span>
<span class="sd">    maps between the two naming conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_TO_TORCH_NAMES</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    There can be differences in parameter names between Stan and PyTorch. This dictionary</span>
<span class="sd">    maps between the two naming conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some distributions are parametrized differently between Stan and SciPy. This</span>
<span class="sd">    dictionary provides transformation functions to convert parameters from Stan&#39;s</span>
<span class="sd">    parametrization to SciPy&#39;s parametrization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize parameter with distribution-specific arguments.&quot;&quot;&quot;</span>
        <span class="c1"># Confirm that class attributes are set correctly</span>
        <span class="k">if</span> <span class="n">missing_attributes</span> <span class="o">:=</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">&quot;STAN_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;CDF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LOG_CDF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LOG_SF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SCIPY_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TORCH_DIST&quot;</span><span class="p">,</span>
                <span class="s2">&quot;STAN_TO_SCIPY_NAMES&quot;</span><span class="p">,</span>
                <span class="s2">&quot;STAN_TO_TORCH_NAMES&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The following class attributes must be defined: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure we have the expected parameters</span>
        <span class="k">if</span> <span class="n">missing_params</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Missing parameters </span><span class="si">{</span><span class="n">missing_params</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize the parameters</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Parameters can be manually set as observables, so we need a flag to</span>
        <span class="c1"># track this</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initialize a parametrization using PyTorch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Parameter.init_pytorch">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.init_pytorch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_pytorch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize PyTorch parameter on *unconstrained* space for gradient-based</span>
<span class="sd">        optimization.</span>

<span class="sd">        :param init_val: Initial parameter values on *unconstrained* space. Uniform</span>
<span class="sd">            between -1 and 1 if None. Defaults to None.</span>
<span class="sd">        :type init_val: Optional[Union[npt.NDArray, torch.Tensor]]</span>
<span class="sd">        :param seed: Random seed for initialization. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :raises ValueError: If called on observable parameters</span>
<span class="sd">        :raises ValueError: If ``init_val`` shape doesn&#39;t match parameter shape</span>

<span class="sd">        This method sets up the parameter for PyTorch-based optimization by</span>
<span class="sd">        creating a trainable ``nn.Parameter``. The initialization strategy uses</span>
<span class="sd">        uniform random values in [-1, 1] if no explicit values are provided.</span>

<span class="sd">        .. important::</span>
<span class="sd">            Initialization values are considered to be in unconstrained space, whether</span>
<span class="sd">            provided or otherwise. An appropriate transform is applied depending</span>
<span class="sd">            on the bounds of the distribution represented by the class to take it to</span>
<span class="sd">            a constrained space (e.g., exponentiation for positive distributions).</span>

<span class="sd">        .. note::</span>
<span class="sd">            Observable parameters cannot be initialized as they represent fixed</span>
<span class="sd">            data rather than learnable parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This cannot be called if the parameter is an observable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observables do not have a torch parametrization&quot;</span><span class="p">)</span>

        <span class="c1"># If no initialization value is provided, then we create one on the range</span>
        <span class="c1"># of -1 to 1.</span>
        <span class="k">if</span> <span class="n">init_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># If the initialization value is a numpy array, convert it to a tensor</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">init_val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>

        <span class="c1"># The shape of the initialization value must match the shape of the</span>
        <span class="c1"># parameter being initialized</span>
        <span class="k">if</span> <span class="n">init_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the initialization value must match the shape of the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameter. Expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, provided: </span><span class="si">{</span><span class="n">init_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize the parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level_draws</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">]],</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="s2">&quot;custom_types.Float&quot;</span><span class="p">,</span> <span class="s2">&quot;custom_types.Integer&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw samples from the parameter&#39;s distribution using SciPy backend.</span>

<span class="sd">        :param level_draws: Parameter values from parent components</span>
<span class="sd">        :type level_draws: dict[str, Union[npt.NDArray, custom_types.Float]]</span>
<span class="sd">        :param seed: Random seed for reproducible sampling</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Sampled values from the distribution</span>
<span class="sd">        :rtype: Union[npt.NDArray, custom_types.Float, custom_types.Integer]</span>

<span class="sd">        This method applies necessary parameter transformations and name mappings</span>
<span class="sd">        to convert from Stan parameter conventions to SciPy conventions, then</span>
<span class="sd">        samples from the corresponding SciPy distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform and rename the draws from the previous level.</span>
        <span class="n">level_draws</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_TRANSFORMS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
            <span class="p">)(</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="n">level_draws</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Draw from the scipy distribution</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">SCIPY_DIST</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="o">**</span><span class="n">level_draws</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Parameter.as_observable">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.as_observable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Parameter&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark parameter as observable (representing observed data).</span>

<span class="sd">        :returns: Self-reference for method chaining</span>
<span class="sd">        :rtype: Parameter</span>

<span class="sd">        Observable parameters represent known data rather than unknown variables</span>
<span class="sd">        to be inferred. This method:</span>

<span class="sd">            - Sets the observable flag to True</span>
<span class="sd">            - Removes PyTorch parameterization (observables aren&#39;t optimized)</span>
<span class="sd">            - Enables generation of appropriate Stan code for data blocks</span>

<span class="sd">        This method will typically not be needed, as SciStanPy automatically assigns</span>
<span class="sd">        parameters with no children in the depenency graph as observables.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; y_obs = Normal(mu=mu_param, sigma=sigma_param).as_observable()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the observable attribute to True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># We do not have a torch parameterization for observables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Parameter.get_target_incrementation">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_target_incrementation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan target increment statement for log-probability.</span>

<span class="sd">        :param index_opts: Potential names for indexing variables (e.g., (&#39;i&#39;, &#39;j&#39;,</span>
<span class="sd">            &#39;k&#39;, ...)).</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan target increment statement (e.g., &quot;y ~ normal(mu, sigma)&quot;</span>
<span class="sd">            or target += normal_lpdf(y | mu, sigma)&quot;).</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method generates the Stan code that adds this parameter&#39;s log-probability</span>
<span class="sd">        (e.g., &quot;target += normal_lpdf(y | mu, sigma)&quot; or &quot;y ~ normal(mu, sigma)&quot;)</span>
<span class="sd">        contribution to the target density.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the left side and operator</span>
        <span class="n">left_side</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span><span class="si">}</span><span class="s2"> ~ &quot;</span>

        <span class="c1"># Get the right-hand-side of the incrementation</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Put it all together</span>
        <span class="k">return</span> <span class="n">left_side</span> <span class="o">+</span> <span class="n">right_side</span></div>


<div class="viewcode-block" id="Parameter.get_generated_quantities">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_generated_quantities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_generated_quantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for posterior predictive sampling.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan code for generated quantities block</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method creates Stan code for the generated quantities block,</span>
<span class="sd">        enabling posterior predictive sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generated_varname</span><span class="p">)</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span><span class="w"> </span><span class="n">dist_suffix</span><span class="o">=</span><span class="s1">&#39;rng&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_torch_logprob">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_torch_logprob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_torch_logprob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">observed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute log-probability using PyTorch backend for gradient computation.</span>

<span class="sd">        :param observed: Observed values for observable parameters. Defaults to</span>
<span class="sd">            None. Required if parameter is observable. Must be None if parameter</span>
<span class="sd">            is latent.</span>
<span class="sd">        :type observed: Optional[torch.Tensor]</span>

<span class="sd">        :returns: Log-probability tensor with gradient tracking</span>
<span class="sd">        :rtype: torch.Tensor</span>

<span class="sd">        :raises ValueError: If observable parameter lacks observed values</span>
<span class="sd">        :raises ValueError: If latent parameter has observed values</span>

<span class="sd">        This method computes log-probabilities using PyTorch distributions,</span>
<span class="sd">        enabling gradient-based optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Observed parameters must have an observed value.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="ow">and</span> <span class="n">observed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observed parameters must have an observed value.&quot;</span><span class="p">)</span>

        <span class="c1"># If this is not an observable, then we should not have an observed value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="ow">and</span> <span class="n">observed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Latent parameters should not have an observed value.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch_dist_instance</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span>
            <span class="n">observed</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch_parametrization</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="Parameter.get_rng">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_rng">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rng</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get random number generator for sampling operations.</span>

<span class="sd">        :param seed: Optional seed for reproducible generation. Defaults to None.</span>
<span class="sd">        :type seed: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: NumPy random number generator</span>
<span class="sd">        :rtype: np.random.Generator</span>

<span class="sd">        Returns the global :py:obj:`scistanpy.RNG` if no seed is provided, otherwise</span>
<span class="sd">        creates a new generator with the specified seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return the global random number generator if no seed is provided. Otherwise,</span>
        <span class="c1"># return a new random number generator with the provided seed.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scistanpy</span><span class="o">.</span><span class="n">RNG</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.write_dist_args">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.write_dist_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">to_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments for Stan code generation.</span>

<span class="sd">        :param to_format: Formatted parameter strings keyed by parameter name</span>
<span class="sd">        :type to_format: str</span>

<span class="sd">        :returns: Comma-separated argument string for Stan distribution calls</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method creates properly formatted argument lists for Stan</span>
<span class="sd">        distribution functions, ordering arguments according to Stan</span>
<span class="sd">        conventions and handling parameter name mappings.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; param = Normal(mu=0, sigma=1)</span>
<span class="sd">            &gt;&gt;&gt; param.write_dist_args(mu=&quot;mean&quot;, sigma=&quot;stddev&quot;)</span>
<span class="sd">            &#39;mean, stddev&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_SCIPY_NAMES</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate right-hand side of Stan statements.</span>

<span class="sd">        :param index_opts: Options for indexing variable names (e.g., (&#39;i&#39;, &#39;j&#39;,</span>
<span class="sd">            &#39;k&#39;, ...)). If None, no indexing is applied.</span>
<span class="sd">        :type index_opts: Optional[tuple[str, ...]]</span>
<span class="sd">        :param start_dims: First indexable dimension of parent model components.</span>
<span class="sd">            Defaults to None, meaning the first dimension is the first indexable</span>
<span class="sd">            dimension for all parents.</span>
<span class="sd">        :type start_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param end_dims: Last indexable dimension of parent model components. Defaults</span>
<span class="sd">            to None, meaning the last dimension is the last indexable dimension</span>
<span class="sd">            for all parents.</span>
<span class="sd">        :type end_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param offset_adjustment: Index offset adjustment. For example, if `index_opts`</span>
<span class="sd">            are (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) and `offset_adjustment` is 1, the effective allowed</span>
<span class="sd">            indices will be (&#39;b&#39;, &#39;c&#39;). This argument is critical for aligning</span>
<span class="sd">            dimensions between parent and child model components that have different</span>
<span class="sd">            numbers of dimensions (i.e., as a result of broadcasting). Defaults</span>
<span class="sd">            to 0.</span>
<span class="sd">        :type offset_adjustment: int</span>
<span class="sd">        :param dist_suffix: Distribution function suffix (e.g., &quot;_rng&quot;). Defaults</span>
<span class="sd">            to &quot;&quot;.</span>
<span class="sd">        :type dist_suffix: str</span>

<span class="sd">        :returns: Stan distribution call string</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="o">=</span><span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Build the distribution argument and format the Stan code</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">dist_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">STAN_DIST</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">write_dist_args</span><span class="p">(</span><span class="o">**</span><span class="n">formattables</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">return</span> <span class="n">code</span></div>


<div class="viewcode-block" id="Parameter.get_transformed_data_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_transformed_data_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformed_data_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the ``transformed data`` block of Stan code.</span>

<span class="sd">        :returns: Stan code for transformed data declarations (empty by default)</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Most parameters don&#39;t require transformed data declarations. This method</span>
<span class="sd">        can be overridden by subclasses that need to declare transformed data variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># None by default</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Parameter.get_generated_quantity_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_generated_quantity_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_generated_quantity_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan variable declaration for generated quantities.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration. For example,</span>
<span class="sd">            if ``True`` and the parameter is defined as a multidimensional float,</span>
<span class="sd">            the returned stan dtype will not be ``array[...Ndim - 1...] vector``,</span>
<span class="sd">            but ``array[...NDim...] float``. Defaults to ``True``, as this is the</span>
<span class="sd">            format expected by generated quantities blocks.</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan variable declaration for posterior predictive sampling</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates appropriate variable declarations for the generated quantities</span>
<span class="sd">        block, enabling posterior predictive sampling with correct variable</span>
<span class="sd">        types and constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_stan_variable</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generated_varname</span><span class="p">,</span> <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.get_raw_stan_parameter_declaration">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.get_raw_stan_parameter_declaration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_raw_stan_parameter_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan parameter declaration for raw (untransformed) variables.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration. See</span>
<span class="sd">            ``get_generated_quantity_declaration`` for more information. Defaults</span>
<span class="sd">            to ``False``.</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan parameter declaration for raw variables</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For parameters using non-centered or other reparameterizations, this generates</span>
<span class="sd">        declarations for the underlying raw variables that are transformed to create</span>
<span class="sd">        the actual parameters. The ``get_transformation_assignment`` function will</span>
<span class="sd">        return Stan code that converts this raw parameter to the desired parameter.</span>
<span class="sd">        For parameters that do not use a raw variable, this returns an empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_stan_variable</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span><span class="p">,</span> <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


    <span class="c1"># pylint: disable=no-self-argument</span>
<div class="viewcode-block" id="Parameter.cdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.cdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.CDF&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create cumulative distribution function transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: CDF transform object</span>
<span class="sd">        :rtype: cdfs.CDF</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is a convenience method for building an instance of the</span>
<span class="sd">            :py:class:`~scistanpy.model.components.transforms.cdf.CDF` subclass</span>
<span class="sd">            associated with the parameter. It can be used as either a class method,</span>
<span class="sd">            in which case parameters must be explicitly provided, or an instance</span>
<span class="sd">            method (in which case instance parameter values will be used).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # As class method</span>
<span class="sd">            &gt;&gt;&gt; cdf = Normal.cdf(mu=0.0, sigma=1.0, x=data)</span>
<span class="sd">            &gt;&gt;&gt; # As instance method</span>
<span class="sd">            &gt;&gt;&gt; normal_param = Normal(mu=0.0, sigma=1.0)</span>
<span class="sd">            &gt;&gt;&gt; cdf = normal_param.cdf(x=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CDF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.ccdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.ccdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ccdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.SurvivalFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create complementary CDF (survival function) transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Survival function transform object</span>
<span class="sd">        :rtype: cdfs.SurvivalFunction</span>

<span class="sd">        Creates survival function (1 - CDF) transforms for survival analysis.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is a convenience method for building an instance of the</span>
<span class="sd">            :py:class:`~scistanpy.model.components.transforms.cdf.SurvivalFunction`</span>
<span class="sd">            subclass associated with the parameter. It can be used as either a class</span>
<span class="sd">            method, in which case parameters must be explicitly provided, or an</span>
<span class="sd">            instance method (in which case instance parameter values will be used).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # As class method</span>
<span class="sd">            &gt;&gt;&gt; sf = Normal.ccdf(mu=0.0, sigma=1.0, x=data)</span>
<span class="sd">            &gt;&gt;&gt; # As instance method</span>
<span class="sd">            &gt;&gt;&gt; normal_param = Normal(mu=0.0, sigma=1.0)</span>
<span class="sd">            &gt;&gt;&gt; sf = normal_param.ccdf(x=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">SF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.log_cdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.log_cdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_cdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.LogCDF&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create logarithmic CDF transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Log-CDF transform object</span>
<span class="sd">        :rtype: cdfs.LogCDF</span>

<span class="sd">        Creates log-CDF transforms for numerical stability in extreme</span>
<span class="sd">        tail probability computations.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is a convenience method for building an instance of the</span>
<span class="sd">            :py:class:`~scistanpy.model.components.transforms.cdf.LogCDF` subclass</span>
<span class="sd">            associated with the parameter. It can be used as either a class method,</span>
<span class="sd">            in which case parameters must be explicitly provided, or an instance</span>
<span class="sd">            method (in which case instance parameter values will be used).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_CDF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parameter.log_ccdf">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Parameter.log_ccdf">[docs]</a>
    <span class="nd">@ClassOrInstanceMethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_ccdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="s2">&quot;custom_types.CombinableParameterType&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdfs.LogSurvivalFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create logarithmic survival function transform.</span>

<span class="sd">        :param params: Distribution parameters (if called as class method) and</span>
<span class="sd">            parameter value.</span>
<span class="sd">        :type params: custom_types.CombinableParameterType</span>

<span class="sd">        :returns: Log-survival function transform object</span>
<span class="sd">        :rtype: cdfs.LogSurvivalFunction</span>

<span class="sd">        Creates log-survival function transforms for numerical stability</span>
<span class="sd">        in extreme tail probability computations.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is a convenience method for building an instance of the</span>
<span class="sd">            :py:class:`~scistanpy.model.components.transforms.cdf.LogSurvivalFunction`</span>
<span class="sd">            subclass associated with the parameter. It can be used as either a class</span>
<span class="sd">            method, in which case parameters must be explicitly provided, or an</span>
<span class="sd">            instance method (in which case instance parameter values will be used).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">LOG_SF</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>


    <span class="c1"># pylint: enable=no-self-argument</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return human-readable string representation of the parameter.</span>

<span class="sd">        :returns: String showing parameter name and distribution</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Creates a readable representation showing the parameter assignment</span>
<span class="sd">        in mathematical notation, useful for model inspection and debugging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">right_side</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[start:end]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_varname</span><span class="si">}</span><span class="s2"> ~ </span><span class="si">{</span><span class="n">right_side</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">torch_dist_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.SciStanPyDistribution&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get PyTorch distribution instance with current parameter values.</span>

<span class="sd">        :returns: Configured PyTorch distribution object</span>
<span class="sd">        :rtype: custom_types.SciStanPyDistribution</span>

<span class="sd">        Creates a PyTorch distribution instance using the current (constrained)</span>
<span class="sd">        parameter values, enabling gradient-based computations and optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">TORCH_DIST</span><span class="p">(</span>  <span class="c1"># pylint: disable=not-callable</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">STAN_TO_TORCH_NAMES</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span> <span class="n">torch</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">torch_parametrization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_hyperparameter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter is a hyperparameter (has only constant parents).</span>

<span class="sd">        :returns: True if all parent parameters are constants</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Hyperparameters are top-level parameters in the model hierarchy</span>
<span class="sd">        that depend only on fixed constants rather than other random variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">torch_parametrization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get PyTorch parameter tensor with appropriate constraints applied.</span>

<span class="sd">        :returns: Constrained parameter tensor for optimization</span>
<span class="sd">        :rtype: torch.Tensor</span>

<span class="sd">        :raises ValueError: If called on observable parameters</span>

<span class="sd">        Returns the PyTorch parameter tensor with appropriate transformations</span>
<span class="sd">        applied to enforce bounds, simplex constraints, or other restrictions.</span>
<span class="sd">        The returned tensor is suitable for gradient-based optimization and obeys</span>
<span class="sd">        the bounds of the probability distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the parameter is an observable, there is no torch parametrization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observables do not have a torch parametrization&quot;</span><span class="p">)</span>

        <span class="c1"># Just return the parameter if there are no bounds</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_SIMPLEX</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_LOG_SIMPLEX</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span>

        <span class="c1"># Set bounds where we have both upper and lower</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_SIMPLEX</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">IS_LOG_SIMPLEX</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="o">+</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">)</span>

        <span class="c1"># If not both bounds, then we must have one bound. We assume the parameter</span>
        <span class="c1"># is defined in the log space and exponentiate it to get the positive value.</span>
        <span class="n">exp_param</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_parametrization</span><span class="p">)</span>

        <span class="c1"># Now if we only have a lower bound</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOWER_BOUND</span> <span class="o">+</span> <span class="n">exp_param</span>

        <span class="c1"># If we only have an upper bound</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">UPPER_BOUND</span> <span class="o">-</span> <span class="n">exp_param</span>

        <span class="c1"># We should never get here</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Invalid bounds&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generated_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variable name for posterior predictive sampling.</span>

<span class="sd">        :returns: Variable name with &quot;_ppc&quot; suffix for generated quantities</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        :raises ValueError: If called on non-observable parameters</span>

<span class="sd">        Observable parameters generate posterior predictive samples in the</span>
<span class="sd">        ``generated quantities`` block of Stan code using this modified variable</span>
<span class="sd">        name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only available for observables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Generated variables are only available for observables&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_varname</span><span class="si">}</span><span class="s2">_ppc&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter represents observed data.</span>

<span class="sd">        :returns: ``True`` if parameter is observable</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Parameters are observable if explicitly marked as such or if they</span>
<span class="sd">        have no children (representing terminal nodes in the model graph).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">TransformedData</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">raw_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get raw variable name for reparameterized parameters.</span>

<span class="sd">        :returns: Raw variable name with &quot;_raw&quot; suffix, or empty string if there</span>
<span class="sd">            is no raw variable name associated with the parameter.</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Some parameters use reparameterization techniques (like non-centered</span>
<span class="sd">        parameterization) that require separate raw variables in Stan code. This</span>
<span class="sd">        property returns the appropriate raw variable name when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stan_model_varname</span><span class="si">}</span><span class="s2">_raw&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">HAS_RAW_VARNAME</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span></div>



<div class="viewcode-block" id="ContinuousDistribution">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ContinuousDistribution">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContinuousDistribution</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">transformed_parameters</span><span class="o">.</span><span class="n">TransformableParameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parameters with continuous sample spaces.</span>

<span class="sd">    This class extends :py:class:`~scistanpy.model.components.parameters.Parameter`</span>
<span class="sd">    to provide functionality specific to continuous probability distributions. It</span>
<span class="sd">    also inherits transformation capabilities that enable complex hierarchical model</span>
<span class="sd">    construction using mathematical operators.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DiscreteDistribution">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.DiscreteDistribution">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DiscreteDistribution</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parameters with discrete sample spaces.</span>

<span class="sd">    This class extends :py:class:`~scistanpy.model.components.parameters.Parameter`</span>
<span class="sd">    for discrete probability distributions, handling the specific requirements of</span>
<span class="sd">    integer-valued random variables.</span>

<span class="sd">    :cvar BASE_STAN_DTYPE: Stan data type for discrete variables (&quot;int&quot;)</span>
<span class="sd">    :cvar LOWER_BOUND: Default lower bound for discrete values (0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updated relative to :py:class:`~scistanpy.model.components.parameters.Parameter`</span>
<span class="sd">    to reflect that discrete parameters are represented as integers in Stan.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updated relative to :py:class:`~scistanpy.model.components.parameters.Parameter`</span>
<span class="sd">    to reflect that all discrete distributions currently implemented in SciStanPy</span>
<span class="sd">    are defined for non-negative integers. This sets the default lower bound to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Normal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Normal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normal (Gaussian) distribution parameter.</span>

<span class="sd">    Implements the normal distribution with location (mu) and scale (sigma)</span>
<span class="sd">    parameters. Supports automatic non-centered parameterization for improved</span>
<span class="sd">    sampling in hierarchical models.</span>

<span class="sd">    :param mu: Location parameter (mean)</span>
<span class="sd">    :type mu: custom_types.ContinuousParameterType</span>
<span class="sd">    :param sigma: Scale parameter (standard deviation)</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param noncentered: Whether to use non-centered parameterization in hierarchical</span>
<span class="sd">        models. Defaults to True.</span>
<span class="sd">    :type noncentered: bool</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            P(x | \mu, \sigma) = \frac{1}{\sigma\sqrt{2\pi}} *</span>
<span class="sd">            \exp\left(-\frac{((x-\mu)/\sigma)^2}{2}\right)</span>


<span class="sd">    Properties:</span>

<span class="sd">    .. list-table::</span>

<span class="sd">        * - Support</span>
<span class="sd">          - :math:`(-\infty, \infty)`</span>
<span class="sd">        * - Mean</span>
<span class="sd">          - :math:`\mu`</span>
<span class="sd">        * - Median</span>
<span class="sd">          - :math:`\mu`</span>
<span class="sd">        * - Mode</span>
<span class="sd">          - :math:`\mu`</span>
<span class="sd">        * - Variance</span>
<span class="sd">          - :math:`\sigma^2`</span>

<span class="sd">    In hierarchical models, the non-centered parametrization is used by default.</span>
<span class="sd">    In this case, a separate raw variable is introduced, and the actual parameter</span>
<span class="sd">    is defined as a transformation of this raw variable. This can lead to</span>
<span class="sd">    improved sampling efficiency in many scenarios:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            z &amp;\sim \text{Normal}(0, 1) \\</span>
<span class="sd">            x &amp;= \mu + \sigma * z</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">noncentered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Build the instance</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Are we using non-centered parameterization?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noncentered</span> <span class="o">=</span> <span class="n">noncentered</span>

<div class="viewcode-block" id="Normal.get_transformation_assignment">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_transformation_assignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformation_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for parameter transformation.</span>

<span class="sd">        :param index_opts: Potential names for indexing variables (e.g., (&#39;i&#39;, &#39;j&#39;,</span>
<span class="sd">            &#39;k&#39;, ...)).</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan transformation code.</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For non-centered parameterization, returns Stan code that defines the</span>
<span class="sd">        parameter as a transformation of a raw variable drawn from a unit normal</span>
<span class="sd">        distribution. Otherwise,  uses the parent class default transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is centered, then we use the parent method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_transformation_assignment</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Get our formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
        <span class="n">mu_declaration</span><span class="p">,</span> <span class="n">sigma_declaration</span> <span class="o">=</span> <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="n">raw_declaration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span>
        <span class="p">)</span>

        <span class="c1"># Otherwise, we redefine this parameter as the transformation of a draw</span>
        <span class="c1"># from a unit normal distribution</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">mu_declaration</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">sigma_declaration</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;.* </span><span class="si">{</span><span class="n">raw_declaration</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Normal.get_target_incrementation">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_target_incrementation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan target increment with appropriate variable names.</span>

<span class="sd">        :param index_opts: Potential names for indexing variables (e.g., (&#39;i&#39;, &#39;j&#39;,</span>
<span class="sd">            &#39;k&#39;, ...)).</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan target increment statement</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        For non-centered parameterization, uses the raw variable name in the target</span>
<span class="sd">        increment while the transformed variable is computed in the transformed</span>
<span class="sd">        parameters block. Otherwise, uses the parent implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the parent method</span>
        <span class="n">parent_incrementation</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_target_incrementation</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># If not noncentered, we are done</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parent_incrementation</span>

        <span class="c1"># Otherwise, replace the default variable name with the non-centered variable</span>
        <span class="c1"># name</span>
        <span class="n">default_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parent_incrementation</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">default_name</span><span class="si">}</span><span class="s2"> ~&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2"> ~&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Normal.get_right_side">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Normal.get_right_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call for Stan code.</span>

<span class="sd">        For non-centered parameterization, returns &quot;std_normal()&quot; for the raw variable.</span>
<span class="sd">        Otherwise uses the parent implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If not noncentered, run the parent method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_noncentered</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
                <span class="n">index_opts</span><span class="p">,</span>
                <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
                <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
                <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
                <span class="n">dist_suffix</span><span class="o">=</span><span class="n">dist_suffix</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Otherwise, make sure we do not have the suffix set and return the standard</span>
        <span class="c1"># normal distribution</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;Non-centered parameters should not have a distribution suffix&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;std_normal()&quot;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_noncentered</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if parameter uses non-centered parameterization.</span>

<span class="sd">        :returns: ``True`` if using non-centered parameterization</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Non-centered parameterization is used when:</span>

<span class="sd">        - ``noncentered`` flag is ``True`` during initialization.</span>
<span class="sd">        - Parameter is not a hyperparameter</span>
<span class="sd">        - Parameter is not observable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noncentered</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperparameter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">observable</span>

    <span class="n">HAS_RAW_VARNAME</span> <span class="o">=</span> <span class="n">is_noncentered</span></div>



<div class="viewcode-block" id="HalfNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.HalfNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HalfNormal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Half-normal distribution parameter (normal truncated at zero).</span>

<span class="sd">    Implements the half-normal distribution, which is a normal distribution</span>
<span class="sd">    truncated to positive values. Commonly used for scale parameters.</span>

<span class="sd">    :param sigma: Scale parameter</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            P(x | \sigma) = \frac{2}{\sigma\sqrt{2\pi}} *</span>
<span class="sd">            \exp\left(-\frac{x^2}{2\sigma^2}\right) \text{ for } x \geq 0</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`[0, \infty)`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`\sigma\sqrt{\dfrac{2}{\pi}}`</span>
<span class="sd">            * - Median</span>
<span class="sd">              - :math:`\sigma\sqrt{2}\operatorname{erf}^{-1}(0.5)`</span>
<span class="sd">            * - Mode</span>
<span class="sd">              - :math:`0`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`\sigma^2\left(1 - \dfrac{2}{\pi}\right)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">halfnorm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">half_normal</span><span class="o">.</span><span class="n">HalfNormal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>  <span class="c1"># pylint: disable=arguments-differ</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments for Stan.</span>

<span class="sd">        :param sigma: Formatted sigma parameter string</span>
<span class="sd">        :type sigma: str</span>

<span class="sd">        :returns: &quot;0, sigma&quot; for Stan normal distribution call</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;0, </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="UnitNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.UnitNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnitNormal</span><span class="p">(</span><span class="n">Normal</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Standard normal distribution (mu=0, sigma=1).</span>

<span class="sd">    Implements the standard normal distribution with fixed parameters.</span>
<span class="sd">    This is a convenience class for the commonly used N(0,1) distribution.</span>

<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            P(x) = \frac{e^{-\frac{x^2}{2}}}{\sqrt{2\pi}}</span>

<span class="sd">    Properties:</span>

<span class="sd">    .. list-table::</span>

<span class="sd">        * - Support</span>
<span class="sd">          - :math:`(-\infty, \infty)`</span>
<span class="sd">        * - Mean</span>
<span class="sd">          - :math:`0`</span>
<span class="sd">        * - Median</span>
<span class="sd">          - :math:`0`</span>
<span class="sd">        * - Mode</span>
<span class="sd">          - :math:`0`</span>
<span class="sd">        * - Variance</span>
<span class="sd">          - :math:`1`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;std_normal&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">noncentered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Sigma is not togglable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">is_togglable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ, unused-argument</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return empty argument string for Stan std_normal distribution.</span>

<span class="sd">        :param mu: Location parameter (unused for std_normal)</span>
<span class="sd">        :type mu: str</span>
<span class="sd">        :param sigma: Scale parameter (unused for std_normal)</span>
<span class="sd">        :type sigma: str</span>

<span class="sd">        :returns: Empty string (std_normal takes no arguments)</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No arguments needed for the unit normal distribution in Stan.</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>



<div class="viewcode-block" id="LogNormal">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.LogNormal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogNormal</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Log-normal distribution parameter.</span>

<span class="sd">    Implements the log-normal distribution where :math:`\log(X)` follows a normal</span>
<span class="sd">    distribution. Commonly used for modeling positive quantities with multiplicative</span>
<span class="sd">    effects.</span>

<span class="sd">    :param mu: Location parameter for underlying normal</span>
<span class="sd">    :type mu: custom_types.ContinuousParameterType</span>
<span class="sd">    :param sigma: Scale parameter for underlying normal</span>
<span class="sd">    :type sigma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \text{If } Y &amp;\sim \text{Normal}(\mu, \sigma), \text{then } \\ \\</span>
<span class="sd">            X &amp;\sim \text{LogNormal}(\mu, \sigma), \text{where } \\ \\</span>
<span class="sd">            P(x | \mu, \sigma) &amp;= \frac{1}{x\sigma\sqrt{2\pi}} *</span>
<span class="sd">            \exp\left(-\frac{(\ln(x)-\mu)^2}{2\sigma^2}\right) \text{ for } x &gt; 0</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">           * - Support</span>
<span class="sd">             - :math:`(0, \infty)`</span>
<span class="sd">           * - Mean</span>
<span class="sd">             - :math:`\exp\left(\mu + \frac{\sigma^2}{2}\right)`</span>
<span class="sd">           * - Median</span>
<span class="sd">             - :math:`\exp(\mu)`</span>
<span class="sd">           * - Mode</span>
<span class="sd">             - :math:`\exp(\mu - \sigma^2)`</span>
<span class="sd">           * - Variance</span>
<span class="sd">             - :math:`\left(\exp(\sigma^2) - 1\right) \exp\left(2\mu + \sigma^2\right)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sigma&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;lognormal&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">LogNormal</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;s&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="n">_exp_transform</span><span class="p">}</span></div>



<div class="viewcode-block" id="Beta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Beta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Beta</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Beta distribution parameter.</span>

<span class="sd">    Implements the beta distribution with shape parameters alpha and beta.</span>
<span class="sd">    The distribution has support on (0, 1) and is commonly used for modeling</span>
<span class="sd">    probabilities and proportions.</span>

<span class="sd">    :param alpha: First shape parameter (concentration)</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Second shape parameter (concentration)</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \alpha, \beta) &amp;= \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)} *</span>
<span class="sd">            x^{\alpha - 1} (1 - x)^{\beta - 1} \text{ for } 0 &lt; x &lt; 1 \\</span>
<span class="sd">            \text{where } \Gamma(z) &amp;= \int_0^\infty t^{z-1} e^{-t} dt</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">           * - Support</span>
<span class="sd">             - :math:`(0, 1)`</span>
<span class="sd">           * - Mean</span>
<span class="sd">             - :math:`\frac{\alpha}{\alpha + \beta}`</span>
<span class="sd">           * - Mode</span>
<span class="sd">             - :math:`\frac{\alpha - 1}{\alpha + \beta - 2}` for :math:`\alpha, \beta &gt; 1`</span>
<span class="sd">           * - Variance</span>
<span class="sd">             - :math:`\frac{\alpha \beta}{(\alpha + \beta)^2 (\alpha + \beta + 1)}`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Prior distributions for probabilities</span>
<span class="sd">        - Modeling proportions and percentages</span>
<span class="sd">        - Bayesian A/B testing</span>
<span class="sd">        - Mixture model component weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">UPPER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">beta</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">Beta</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration1&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration0&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Gamma">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Gamma">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Gamma</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gamma distribution parameter.</span>

<span class="sd">    Implements the gamma distribution with shape (alpha) and rate (beta)</span>
<span class="sd">    parameters. Commonly used for modeling positive continuous quantities</span>
<span class="sd">    with specific shape characteristics.</span>

<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Rate parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \alpha, \beta) &amp;= \frac{\beta^\alpha}{\Gamma(\alpha)} *</span>
<span class="sd">            x^{\alpha - 1} e^{-\beta x} \text{ for } x &gt; 0 \\</span>
<span class="sd">            \text{where } \Gamma(z) &amp;= \int_0^\infty t^{z-1} e^{-t} dt</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`(0, \infty)`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`\frac{\alpha}{\beta}`</span>
<span class="sd">            * - Mode</span>
<span class="sd">              - :math:`\frac{\alpha - 1}{\beta}` for :math:`\alpha &gt; 1`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`\frac{\alpha}{\beta^2}`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;gamma&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">gamma</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">Gamma</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span></div>



<div class="viewcode-block" id="InverseGamma">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.InverseGamma">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InverseGamma</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inverse gamma distribution parameter.</span>

<span class="sd">    Implements the inverse gamma distribution, commonly used as a conjugate</span>
<span class="sd">    prior for variance parameters in Bayesian analysis.</span>

<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param beta: Scale parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \alpha, \beta) &amp;= \frac{\beta^\alpha}{\Gamma(\alpha)} *</span>
<span class="sd">            x^{-\alpha - 1} e^{-\beta / x} \text{ for } x &gt; 0 \\</span>
<span class="sd">            \text{where } \Gamma(z) &amp;= \int_0^\infty t^{z-1} e^{-t} dt</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`(0, \infty)`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`\frac{\beta}{\alpha - 1}` for :math:`\alpha &gt; 1`</span>
<span class="sd">            * - Mode</span>
<span class="sd">              - :math:`\frac{\beta}{\alpha + 1}`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`\frac{\beta^2}{(\alpha - 1)^2(\alpha - 2)}` for :math:`\alpha &gt; 2`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Conjugate prior for normal variance</span>
<span class="sd">        - Hierarchical modeling of scale parameters</span>
<span class="sd">        - Bayesian regression variance modeling</span>
<span class="sd">&quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;inv_gamma&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgamma</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">inverse_gamma</span><span class="o">.</span><span class="n">InverseGamma</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Exponential">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Exponential">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Exponential</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exponential distribution parameter.</span>

<span class="sd">    Implements the exponential distribution with rate parameter beta.</span>
<span class="sd">    Commonly used for modeling waiting times and survival analysis.</span>

<span class="sd">    :param beta: Rate parameter</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \beta) &amp;= \beta e^{-\beta x} \text{ for } x \geq 0</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">           * - Support</span>
<span class="sd">             - :math:`[0, \infty)`</span>
<span class="sd">           * - Mean</span>
<span class="sd">             - :math:`\frac{1}{\beta}`</span>
<span class="sd">           * - Mode</span>
<span class="sd">             - :math:`0`</span>
<span class="sd">           * - Variance</span>
<span class="sd">             - :math:`\frac{1}{\beta^2}`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">}</span>
    <span class="n">LOWER_BOUND</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">expon</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">exponential</span><span class="o">.</span><span class="n">Exponential</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span></div>



<div class="viewcode-block" id="ExpExponential">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpExponential">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpExponential</span><span class="p">(</span><span class="n">Exponential</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exp-Exponential distribution (log of exponential random variable).</span>

<span class="sd">    Implements the distribution of :math:`Y` where :math:`\exp(Y) \sim</span>
<span class="sd">    \text{Exponential}(\beta)`.</span>

<span class="sd">    :param beta: Rate parameter for the underlying exponential</span>
<span class="sd">    :type beta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \text{If } X &amp;\sim \text{Exponential}(\beta), \text{then } \\ \\</span>
<span class="sd">            Y &amp;= \log(X) \sim \text{ExpExponential}(\beta), \text{where } \\ \\</span>
<span class="sd">            P(y | \beta) &amp;= \beta * \exp(y - \beta * \exp(y)) \text{ for } y \in (-\infty, \infty)</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>
<span class="sd">        - Support: :math:`(-\infty, \infty)`</span>
<span class="sd">        - Related to Gumbel distribution family</span>
<span class="sd">        - Useful for log-scale modeling of exponential processes</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    :doc:`../stan/stan_functions`) which are automatically included in any Stan</span>
<span class="sd">    program defined using this distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;expexponential&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">expexponential</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpExponential</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_SCIPY_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">_inverse_transform</span>
    <span class="p">}</span>  <span class="c1"># Transform beta to match the scipy distribution&#39;s scale parameter</span>

<div class="viewcode-block" id="ExpExponential.get_supporting_functions">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpExponential.get_supporting_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the expexponential.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-exponential density and random number generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Exponential distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include expexponential.stanfunctions&quot;</span>
        <span class="p">]</span></div>
</div>



<div class="viewcode-block" id="Lomax">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Lomax">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Lomax</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Lomax distribution (Pareto Type II with location=0).</span>

<span class="sd">    Implements the Lomax distribution, which is a special case of the</span>
<span class="sd">    Pareto Type II distribution with location parameter set to 0.</span>

<span class="sd">    :param lambda\_: Scale parameter</span>
<span class="sd">    :type lambda\_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param alpha: Shape parameter</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \lambda, \alpha) &amp;= \frac{\alpha}{\lambda} *</span>
<span class="sd">            \left(1 + \frac{x}{\lambda}\right)^{-\alpha - 1} \text{ for } x \geq 0</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`[0, \infty)`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`\frac{\lambda}{\alpha - 1}` for :math:`\alpha &gt; 1`</span>
<span class="sd">            * - Mode</span>
<span class="sd">              - :math:`0`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`\frac{\lambda^2}{(\alpha - 1)^2(\alpha - 2)}` for :math:`\alpha &gt; 2`</span>


<span class="sd">    Common Applications:</span>
<span class="sd">        - Modeling income distributions</span>
<span class="sd">        - Network analysis (degree distributions)</span>
<span class="sd">        - Reliability engineering</span>
<span class="sd">        - Extreme value modeling</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;pareto_type_2&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lomax</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Lomax</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Format arguments for Stan pareto_type_2 distribution.</span>

<span class="sd">        :param lambda\_: Formatted lambda parameter string</span>
<span class="sd">        :type lambda\_: str</span>
<span class="sd">        :param alpha: Formatted alpha parameter string</span>
<span class="sd">        :type alpha: str</span>

<span class="sd">        :returns: &quot;0.0, lambda\_, alpha&quot; for Stan distribution call</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The Lomax distribution is implemented in Stan as Pareto Type II</span>
<span class="sd">        with location parameter fixed at 0.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;0.0, </span><span class="si">{</span><span class="n">lambda_</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="ExpLomax">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpLomax">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpLomax</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exp-Lomax distribution (log of Lomax random variable).</span>

<span class="sd">    Implements the distribution of :math:`Y` where :math:`\exp(Y) \sim</span>
<span class="sd">    \text{Lomax}(\lambda, \alpha)`.</span>

<span class="sd">    :param lambda\_: Scale parameter for underlying Lomax</span>
<span class="sd">    :type lambda\_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param alpha: Shape parameter for underlying Lomax</span>
<span class="sd">    :type alpha: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \text{If } X &amp;\sim \text{Lomax}(\lambda, \alpha), \text{then } \\ \\</span>
<span class="sd">            Y &amp;= \log(X) \sim \text{ExpLomax}(\lambda, \alpha), \text{where } \\ \\</span>
<span class="sd">            P(y | \lambda, \alpha) &amp;= \frac{\alpha}{\lambda} * \exp(y) *</span>
<span class="sd">            \left(1 + \frac{\exp(y)}{\lambda}\right)^{-\alpha - 1} \text{ for } y</span>
<span class="sd">            \in (-\infty, \infty)</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    This distribution requires custom Stan functions for implementation (see</span>
<span class="sd">    :doc:`../stan/stan_functions`) which are automatically included in any Stan</span>
<span class="sd">    program defined using this distribution.</span>
<span class="sd">&quot;&quot;&quot;</span>

    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;explomax&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">explomax</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpLomax</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;lambda_&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the explomax.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-Lomax density and random number generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Lomax distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;#include explomax.stanfunctions&quot;</span><span class="p">]</span></div>



<div class="viewcode-block" id="Dirichlet">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Dirichlet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dirichlet</span><span class="p">(</span><span class="n">ContinuousDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dirichlet distribution parameter.</span>

<span class="sd">    Implements the Dirichlet distribution for modeling probability simplexes.</span>
<span class="sd">    The distribution generates vectors that sum to 1, making it ideal for</span>
<span class="sd">    modeling categorical probabilities and mixture weights.</span>

<span class="sd">    :param alpha: Concentration parameters (can be scalar or array-like). If scalar,</span>
<span class="sd">        will be converted to the appropriate shape given by the `shape` kwarg.</span>
<span class="sd">    :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">    :param kwargs: Additional keyword arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(x | \alpha) &amp;= \frac{\Gamma(\sum_{i=1}^K \alpha_i)}{\prod_{i=1}^K</span>
<span class="sd">            \Gamma(\alpha_i)} \prod_{i=1}^K x_i^{\alpha_i - 1} \text{ for } x_i &gt; 0,</span>
<span class="sd">            \sum_{i=1}^K x_i = 1 \\</span>
<span class="sd">            \text{where } \Gamma(z) &amp;= \int_0^\infty t^{z-1} e^{-t} dt</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`\{x : \sum_{i=1}^K x_i = 1, x_i &gt; 0\}`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`E[X_i] = \frac{\alpha_i}{\sum_{j=1}^K \alpha_j}`</span>
<span class="sd">            * - Mode</span>
<span class="sd">              - :math:`\frac{\alpha_i - 1}{\sum_{j=1}^K \alpha_j - K}` for all :math:`\alpha_i &gt; 1`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`\frac{\alpha_i (\sum_{j=1}^K \alpha_j - \alpha_i)}</span>
<span class="sd">                {(\sum_{j=1}^K \alpha_j)^2 (\sum_{j=1}^K \alpha_j + 1)}`</span>
<span class="sd">                for all :math:`\alpha_i &gt; 1`</span>
<span class="sd">            * - Covariance</span>
<span class="sd">              - :math:`\frac{-\alpha_i \alpha_j}{(\sum_{k=1}^K \alpha_k)^2</span>
<span class="sd">                (\sum_{k=1}^K \alpha_k + 1)}` for all :math:`i \neq j` and</span>
<span class="sd">                :math:`\alpha_i, \alpha_j &gt; 1`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Modeling categorical probabilities</span>

<span class="sd">    .. note::</span>
<span class="sd">        SciStanPy&#39;s implementation of the Dirichlet distribution allows for defining</span>
<span class="sd">        concentration parameters (:math:`\alpha`) as either scalar values or arrays.</span>
<span class="sd">        If a scalar is provided, the `shape` keyword argument must also be specified</span>
<span class="sd">        to define the dimensionality of the simplex--the scalar will be expanded</span>
<span class="sd">        to a uniform array of that shape. This flexibility enables both symmetric</span>
<span class="sd">        Dirichlet distributions (where all components have the same concentration)</span>
<span class="sd">        and asymmetric distributions with distinct concentration parameters for each</span>
<span class="sd">        component.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span> <span class="o">=</span> <span class="s2">&quot;simplex&quot;</span>
    <span class="n">IS_SIMPLEX</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;dirichlet&quot;</span>
    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">dirichlet</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">dirichlet</span><span class="o">.</span><span class="n">Dirichlet</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dirichlet distribution with concentration parameters.</span>

<span class="sd">        :param alpha: Concentration parameters for each component</span>
<span class="sd">        :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">        :param kwargs: Additional arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">        :raises ValueError: If alpha is scalar but &#39;shape&#39; is not provided</span>

<span class="sd">        The initialization handles both scalar and vector specifications of</span>
<span class="sd">        concentration parameters, automatically creating uniform arrays when</span>
<span class="sd">        a scalar value is provided with an explicit shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a float or int is provided, then &quot;shape&quot; must be provided too. We will</span>
        <span class="c1"># create a numpy array filled of that shape filled with the value</span>
        <span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s2">&quot;shape&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If alpha is a float or int, then shape must be provided&quot;</span>
                <span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Run the init method of the class one level up in the MRO hierarchy</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Set `enforce_uniformity` appropriately</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">enforce_uniformity</span> <span class="o">=</span> <span class="n">enforce_uniformity</span>  <span class="c1"># pylint: disable=no-member</span></div>



<div class="viewcode-block" id="ExpDirichlet">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.ExpDirichlet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpDirichlet</span><span class="p">(</span><span class="n">Dirichlet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exp-Dirichlet distribution (log of Dirichlet random variable).</span>

<span class="sd">    Implements the distribution of :math:`Y` where :math:`\exp(Y) ~ \text{Dirichlet}(\alpha)`.</span>
<span class="sd">    This provides a log-simplex parameterization that can be more numerically</span>
<span class="sd">    stable for extreme concentration parameters and extremely high-dimensional</span>
<span class="sd">    simplexes, like those encountered when modeling deep mutational scanning data.</span>

<span class="sd">    :param alpha: Concentration parameters for underlying Dirichlet</span>
<span class="sd">    :type alpha: Union[AbstractModelComponent, npt.ArrayLike]</span>
<span class="sd">    :param kwargs: Additional keyword arguments including &#39;shape&#39; if alpha is scalar</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \text{If } X &amp;\sim \text{Dirichlet}(\alpha), \text{then } \\ \\</span>
<span class="sd">            Y &amp;= \log(X) \sim \text{ExpDirichlet}(\alpha), \text{where } \\ \\</span>
<span class="sd">            P(y | \alpha) &amp;= \frac{\sqrt{K}}{\exp{(y_K)}}\frac{\Gamma(\sum_{i=1}^K \alpha_i)}{\prod_{i=1}^K</span>
<span class="sd">            \Gamma(\alpha_i)} \prod_{i=1}^K \exp(y_i \alpha_i) \text{ for }</span>
<span class="sd">            y_i \in (-\infty, \infty),</span>
<span class="sd">            \sum_{i=1}^K \exp(y_i) = 1 \\</span>
<span class="sd">            \text{where } \Gamma(z) &amp;= \int_0^\infty t^{z-1} e^{-t} dt</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>
<span class="sd">        - Log-probability is computed in the log-simplex space</span>
<span class="sd">        - More numerically stable for extreme concentration parameters</span>
<span class="sd">        - Suitable for high-dimensional simplexes</span>
<span class="sd">        - Useful for modeling compositional data on log scale</span>

<span class="sd">    .. note::</span>
<span class="sd">        The Exp-Dirichlet distribution is not natively supported in Stan, so this</span>
<span class="sd">        implementation includes custom Stan functions for the probability density,</span>
<span class="sd">        transformations, and random number generation. These functions are automatically</span>
<span class="sd">        included in any Stan program defined using this distribution. Special thanks</span>
<span class="sd">        to Sean Pinkney for assistance with deriving the log probability density</span>
<span class="sd">        function for the distribution; thanks also to Bob Carpenter and others for</span>
<span class="sd">        developing the log-simplex constraint used in SciStanPy. See</span>
<span class="sd">        `here &lt;https://discourse.mc-stan.org/t/log-simplex-constraints/39782&gt;`__</span>
<span class="sd">        for derivations and `here &lt;https://github.com/bob-carpenter/transforms/tree</span>
<span class="sd">        /main/simplex_transforms/stan/transforms&gt;`__ for transforms.</span>

<span class="sd">    .. note::</span>
<span class="sd">        When used as a hyperparameter (i.e., :math:`\alpha` is constant), the</span>
<span class="sd">        normalization constant of the distribution is also constant and can be</span>
<span class="sd">        ignored during MCMC sampling to improve computational efficiency. This</span>
<span class="sd">        implementation automatically detects when the Exp-Dirichlet is used as a</span>
<span class="sd">        hyperparameter and switches to the unnormalized version of the distribution</span>
<span class="sd">        in such cases. If :math:`\alpha` is not constant, the normalized version</span>
<span class="sd">        is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BASE_STAN_DTYPE</span> <span class="o">=</span> <span class="s2">&quot;real&quot;</span>
    <span class="n">IS_SIMPLEX</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">IS_LOG_SIMPLEX</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">LOWER_BOUND</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">UPPER_BOUND</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;expdirichlet&quot;</span>
    <span class="n">HAS_RAW_VARNAME</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">expdirichlet</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">ExpDirichlet</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;alpha&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s2">&quot;concentration&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the expdirichlet.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for proper implementation</span>
<span class="sd">        of the exp-Dirichlet density, constraint functions, and transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to extend the set of supporting functions to include the custom</span>
        <span class="c1"># Stan functions for the Exp-Dirichlet distribution</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include expdirichlet.stanfunctions&quot;</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_transformation_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Stan code for log-simplex constraint transformation.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan transformation code with Jacobian adjustment</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Applies the inverse ILR (isometric log-ratio) transformation to</span>
<span class="sd">        convert from unconstrained K-1 dimensional space to log-simplex</span>
<span class="sd">        while automatically handling the Jacobian adjustment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We constrain and adjust the Jacobian for the transformation</span>
        <span class="n">raw_varname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span> <span class="n">_name_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_varname</span>
        <span class="p">)</span>
        <span class="n">transformed_varname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">transformed_varname</span><span class="si">}</span><span class="s2"> = inv_ilr_log_simplex_constrain_jacobian(</span><span class="si">{</span><span class="n">raw_varname</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call with appropriate normalization suffix.</span>

<span class="sd">        When ExpDirichlet is used as a hyperparameter, the normalization coefficient</span>
<span class="sd">        is a constant and so will be ignored during MCMC to improve computational</span>
<span class="sd">        efficiency. When ExpDirichlet is not a hyperparameter (values for `alpha`</span>
<span class="sd">        are not constant), the normalized version is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no suffix is provided, determine whether we are using the normalized</span>
        <span class="c1"># or unnormalized version of the distribution. We use unnormalized when</span>
        <span class="c1"># the parameter is a hyperparameter with no parents.</span>
        <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;unnorm&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperparameter</span> <span class="k">else</span> <span class="s2">&quot;norm&quot;</span>

        <span class="c1"># Now we just run the parent method</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
            <span class="n">dist_suffix</span><span class="o">=</span><span class="n">dist_suffix</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_raw_stan_parameter_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_basetype</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate declaration for raw parameter with reduced dimensions.</span>

<span class="sd">        :param force_basetype: Whether to force base type declaration</span>
<span class="sd">        :type force_basetype: bool</span>

<span class="sd">        :returns: Stan parameter declaration for K-1 dimensional raw variable</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The raw parameter has K-1 dimensions instead of K to account for</span>
<span class="sd">        the simplex constraint. This raw variable is transformed to create the</span>
<span class="sd">        log-simplex constrained value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the parent method to get the raw variable name</span>
        <span class="n">raw_varname</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_raw_stan_parameter_declaration</span><span class="p">(</span>
            <span class="n">force_basetype</span><span class="o">=</span><span class="n">force_basetype</span>
        <span class="p">)</span>

        <span class="c1"># We should always have a raw variable name if we are using the Exp-Dirichlet</span>
        <span class="k">assert</span> <span class="n">raw_varname</span><span class="p">,</span> <span class="s2">&quot;Raw variable name should not be empty for Exp-Dirichlet&quot;</span>

        <span class="c1"># Every ExpDirichlet will have a &#39;vector&lt;upper=0.0&gt;[K]&#39; datatype. We want</span>
        <span class="c1"># to split the raw variable name on this signature</span>
        <span class="n">array_info</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">var_info</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(.*)vector&lt;upper=0.0&gt;\[([0-9]+)\](.+)&quot;</span><span class="p">,</span> <span class="n">raw_varname</span>
        <span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Remove extra dimension for the raw variable</span>

        <span class="c1"># Reconstruct the raw variable name with the correct number of dimensions.</span>
        <span class="c1"># Note that there is no upper bound on the raw variable</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_info</span><span class="si">}</span><span class="s2">vector[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]</span><span class="si">{</span><span class="n">var_info</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="Binomial">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Binomial">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Binomial</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Binomial distribution parameter.</span>

<span class="sd">    Implements the binomial distribution for modeling the number of successes</span>
<span class="sd">    in a fixed number of independent Bernoulli trials.</span>

<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param theta: Success probability</span>
<span class="sd">    :type theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(X = k | N, \theta) &amp;= \binom{N}{k} \theta^k (1 - \theta)^{N - k}</span>
<span class="sd">            \text{ for } k = 0, 1, ..., N</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">              * - Support</span>
<span class="sd">                - :math:`\{0, 1, 2, ..., N\}`</span>
<span class="sd">              * - Mean</span>
<span class="sd">                - :math:`N \theta`</span>
<span class="sd">              * - Variance</span>
<span class="sd">                - :math:`N \theta (1 - \theta)`</span>
<span class="sd">              * - Mode</span>
<span class="sd">                - :math:`\lfloor (N + 1) \theta \rfloor`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Number of successes in fixed trials</span>
<span class="sd">        - Proportion data with known denominators</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;binomial&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">binom</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binomial</span><span class="o">.</span><span class="n">Binomial</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;p&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;probs&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Poisson">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Poisson">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Poisson</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Poisson distribution parameter.</span>

<span class="sd">    Implements the Poisson distribution for modeling count data with</span>
<span class="sd">    a single rate parameter.</span>

<span class="sd">    :param lambda_: Rate parameter (mean number of events)</span>
<span class="sd">    :type lambda_: custom_types.ContinuousParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(X = k | \lambda) &amp;= \frac{\lambda^k e^{-\lambda}}{k!}</span>
<span class="sd">            \text{ for } k = 0, 1, 2, ...</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>

<span class="sd">        .. list-table::</span>

<span class="sd">            *  - Support</span>
<span class="sd">               - :math:`\{0, 1, 2, ...\}`</span>
<span class="sd">            *  - Mean</span>
<span class="sd">               - :math:`\lambda`</span>
<span class="sd">            *  - Variance</span>
<span class="sd">               - :math:`\lambda`</span>
<span class="sd">            *  - Mode</span>
<span class="sd">               - :math:`\lfloor \lambda \rfloor`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Event counting (arrivals, defects, etc.)</span>
<span class="sd">        - Modeling rare events</span>
<span class="sd">        - Count regression</span>
<span class="sd">        - Queueing theory</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">POSITIVE_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">Poisson</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;mu&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_&quot;</span><span class="p">:</span> <span class="s2">&quot;rate&quot;</span><span class="p">}</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">_MultinomialBase</span><span class="p">(</span><span class="n">DiscreteDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for multinomial distribution variants.</span>

<span class="sd">    This abstract base class provides common functionality for different</span>
<span class="sd">    parameterizations of the multinomial distribution. It handles the</span>
<span class="sd">    special case where the number of trials (N) is implicit in Stan</span>
<span class="sd">    but explicit in SciPy/PyTorch interfaces.</span>

<span class="sd">    The class automatically handles parameter transformation and provides</span>
<span class="sd">    custom target incrementation that removes the N parameter from Stan</span>
<span class="sd">    distribution calls since it&#39;s implicit in the multinomial definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_TO_NP_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>  <span class="c1"># Squeeze the N parameter to match the numpy distribution&#39;s expected shape</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_incrementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate target increment with N parameter removed.</span>

<span class="sd">        :param index_opts: Indexing options for multi-dimensional parameters</span>
<span class="sd">        :type index_opts: tuple[str, ...]</span>

<span class="sd">        :returns: Stan target increment without N parameter</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The multinomial distribution in Stan doesn&#39;t explicitly include</span>
<span class="sd">        the number of trials N in the function call, so this method</span>
<span class="sd">        removes it from the generated code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to strip the N parameter from the declaration as this is implicit</span>
        <span class="c1"># in the distribution as defined in Stan</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_target_incrementation</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>

        <span class="c1"># Remove the N parameter</span>
        <span class="o">*</span><span class="n">raw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>


<div class="viewcode-block" id="Multinomial">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.Multinomial">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Multinomial</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Standard multinomial distribution parameter.</span>

<span class="sd">    Implements the multinomial distribution with probability vector :math:`\theta`</span>
<span class="sd">    and number of trials :math:`N`. Models the number of observations in each</span>
<span class="sd">    category for a fixed number of trials.</span>

<span class="sd">    :param theta: Probability vector (must sum to 1)</span>
<span class="sd">    :type theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            P(X = x | N, \theta) &amp;= \frac{N!}{\prod_{i=1}^K x_i!} \prod_{i=1}^K</span>
<span class="sd">            \theta_i^{x_i} \text{ for } x_i \geq 0, \sum_{i=1}^K x_i = N \\</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    Properties:</span>
<span class="sd">        .. list-table::</span>

<span class="sd">            * - Support</span>
<span class="sd">              - :math:`\{x : \sum x_i = N, x_i \geq 0\}`</span>
<span class="sd">            * - Mean</span>
<span class="sd">              - :math:`N \theta_i`</span>
<span class="sd">            * - Variance</span>
<span class="sd">              - :math:`N \theta_i (1 - \theta_i)`</span>
<span class="sd">            * - Covariance</span>
<span class="sd">              - :math:`-N \theta_i \theta_j`</span>

<span class="sd">    Common Applications:</span>
<span class="sd">        - Categorical count data</span>
<span class="sd">        - Multinomial logistic regression</span>
<span class="sd">        - Natural language processing (word counts)</span>
<span class="sd">        - Genetics (allele frequencies)</span>
<span class="sd">        - Marketing (customer choice modeling)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SIMPLEX_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">Multinomial</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="s2">&quot;probs&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="MultinomialLogit">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogit">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MultinomialLogit</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Multinomial distribution with logit parameterization.</span>

<span class="sd">    Implements the multinomial distribution parameterized by logits (:math:`\gamma`)</span>
<span class="sd">    rather than probabilities. Logits are unconstrained real values that are transformed</span>
<span class="sd">    to probabilities via the softmax function. This parameterization is useful for</span>
<span class="sd">    models that naturally work with logits, such as logistic regression extensions.</span>

<span class="sd">    :param gamma: Logit vector (unconstrained real values)</span>
<span class="sd">    :type gamma: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \theta_i &amp;= \frac{\exp(\gamma_i)}{\sum_{j=1}^K \exp(\gamma_j)} \\ \\</span>
<span class="sd">            X &amp;\sim \text{Multinomial}(N, \theta)</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    .. warning::</span>
<span class="sd">        It is easy to create non-identifiable models using this parameterization.</span>
<span class="sd">        Make sure to include appropriate priors or constraints on logits to ensure</span>
<span class="sd">        model identifiability.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial_logit&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial_logit</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">MultinomialLogit</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="s2">&quot;logits&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="s2">&quot;logits&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="MultinomialLogTheta">
<a class="viewcode-back" href="../../../../api/model/components/parameters.html#scistanpy.model.components.parameters.MultinomialLogTheta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MultinomialLogTheta</span><span class="p">(</span><span class="n">_MultinomialBase</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Multinomial distribution with log-probability parameterization.</span>

<span class="sd">    Implements the multinomial distribution in terms of the log of the theta</span>
<span class="sd">    parameter. This parameterization is useful for models that naturally</span>
<span class="sd">    work with log-probabilities. It can use the ExpDirichlet distribution as a</span>
<span class="sd">    prior to enforce the log-simplex constraint and keep computations completely</span>
<span class="sd">    in the log-probability space. This is extremely useful for high-dimensional</span>
<span class="sd">    multinomials where categories may have very small probabilities (e.g., deep</span>
<span class="sd">    mutational scanning data).</span>

<span class="sd">    :param log_theta: Log probability vector (log-simplex constraint)</span>
<span class="sd">    :type log_theta: custom_types.ContinuousParameterType</span>
<span class="sd">    :param N: Number of trials</span>
<span class="sd">    :type N: custom_types.DiscreteParameterType</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to parent class</span>

<span class="sd">    Mathematical Definition:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \theta_i &amp;= \exp(\log{\theta_i}) \quad \text{(with normalization: }</span>
<span class="sd">            \sum_j \exp(\log{\theta_j}) = 1) \\</span>
<span class="sd">            X &amp;\sim \text{Multinomial}(N, \theta)</span>
<span class="sd">            \end{align*}</span>

<span class="sd">    .. note::</span>
<span class="sd">        This distribution is not natively supported in Stan, so this implementation</span>
<span class="sd">        includes custom Stan functions for the probability density and random</span>
<span class="sd">        number generation. These functions are automatically included in any Stan</span>
<span class="sd">        program defined using this distribution.</span>

<span class="sd">    .. hint::</span>
<span class="sd">        When used to model observed data (i.e., as an observable parameter),</span>
<span class="sd">        the multinomial coefficient is automatically calculated and included in</span>
<span class="sd">        the ``transformed data`` block of Stan code. This improves computational</span>
<span class="sd">        efficiency by eliminating redundant calculations during MCMC sampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOG_SIMPLEX_PARAMS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">}</span>
    <span class="n">STAN_DIST</span> <span class="o">=</span> <span class="s2">&quot;multinomial_logtheta&quot;</span>
    <span class="n">SCIPY_DIST</span> <span class="o">=</span> <span class="n">custom_scipy_dists</span><span class="o">.</span><span class="n">multinomial_log_theta</span>
    <span class="n">TORCH_DIST</span> <span class="o">=</span> <span class="n">custom_torch_dists</span><span class="o">.</span><span class="n">MultinomialLogTheta</span>
    <span class="n">STAN_TO_SCIPY_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">:</span> <span class="s2">&quot;log_p&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span>
    <span class="n">STAN_TO_TORCH_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;log_theta&quot;</span><span class="p">:</span> <span class="s2">&quot;log_probs&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;total_count&quot;</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">log_theta</span><span class="p">:</span> <span class="s2">&quot;custom_types.ContinuousParameterType&quot;</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="s2">&quot;custom_types.DiscreteParameterType&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MultinomialLogTheta with automatic coefficient handling.</span>

<span class="sd">        :param log_theta: Log probability parameter</span>
<span class="sd">        :type log_theta: custom_types.ContinuousParameterType</span>
<span class="sd">        :param N: Number of trials parameter</span>
<span class="sd">        :type N: custom_types.DiscreteParameterType</span>
<span class="sd">        :param kwargs: Additional keyword arguments</span>

<span class="sd">        The initialization automatically creates a multinomial coefficient</span>
<span class="sd">        component that is removed if the parameter gains children (indicating</span>
<span class="sd">        it&#39;s not an observable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Init the parent class with the appropriate parameters</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">log_theta</span><span class="o">=</span><span class="n">log_theta</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># By default, we allow a multinomial coefficient to be pre-calculated. This</span>
        <span class="c1"># assumes that the instance will be an observable parameter, so we modify</span>
        <span class="c1"># the `_record_child` function to remove the coefficient as soon as something</span>
        <span class="c1"># is added to the children.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span> <span class="o">=</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_record_child</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">abstract_model_component</span><span class="o">.</span><span class="n">AbstractModelComponent</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle removal of coefficient when parameter gains children.</span>

<span class="sd">        :param child: Child component being added</span>
<span class="sd">        :type child: AbstractModelComponent</span>

<span class="sd">        This method manages the multinomial coefficient based on the parameter&#39;s</span>
<span class="sd">        role in the model. The coefficient is automatically removed when the</span>
<span class="sd">        parameter gains non-coefficient children, indicating it&#39;s not purely</span>
<span class="sd">        an observable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is not a multinomial coefficient, then we have to remove that</span>
        <span class="c1"># coefficient from the children.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Otherwise, the list of children must be empty, as the coefficient will</span>
        <span class="c1"># be the first child added.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Run the parent method to record the child</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_record_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_supporting_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of required Stan function includes.</span>

<span class="sd">        :returns: List containing the multinomial.stanfunctions include</span>
<span class="sd">        :rtype: list[str]</span>

<span class="sd">        This distribution requires custom Stan functions for efficient</span>
<span class="sd">        computation of the multinomial log-theta density and normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_supporting_functions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;#include multinomial.stanfunctions&quot;</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_dist_args</span><span class="p">(</span>  <span class="c1"># pylint: disable=arguments-differ, arguments-renamed</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">log_theta</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format distribution arguments with optional coefficient.</span>

<span class="sd">        :param log_theta: Formatted log_theta parameter string</span>
<span class="sd">        :type log_theta: str</span>
<span class="sd">        :param N: Formatted N parameter string</span>
<span class="sd">        :type N: str</span>
<span class="sd">        :param coeff: Formatted coefficient string (optional). Defaults to &quot;&quot;.</span>
<span class="sd">        :type coeff: str</span>

<span class="sd">        :returns: Formatted argument string for Stan distribution call</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The method handles inclusion of the multinomial coefficient when available,</span>
<span class="sd">        enabling more efficient computation by pre-calculating constant terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the coefficient is provided, insert it in the middle of the arguments.</span>
        <span class="c1"># Otherwise, just return the log_theta and N parameters. This is a bit of</span>
        <span class="c1"># a hack to make sure that &quot;N&quot; is stripped off by `get_target_incrementation`</span>
        <span class="c1"># regardless of whether the coefficient is provided or not.</span>
        <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">log_theta</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">log_theta</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_opts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_adjustment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dist_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate distribution call with appropriate normalization and coefficients.</span>

<span class="sd">        :param index_opts: See parent method for details.</span>
<span class="sd">        :type index_opts: Optional[tuple[str, ...]]</span>
<span class="sd">        :param start_dims: See parent method for details.</span>
<span class="sd">        :type start_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param end_dims: See parent method for details.</span>
<span class="sd">        :type end_dims: Optional[dict[str, custom_types.Integer]]</span>
<span class="sd">        :param offset_adjustment: See parent method for details.</span>
<span class="sd">        :type offset_adjustment: int</span>
<span class="sd">        :param dist_suffix: Distribution function suffix</span>
<span class="sd">        :type dist_suffix: str</span>

<span class="sd">        :returns: Stan distribution call with proper normalization</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The method automatically selects between manual normalization (with</span>
<span class="sd">        coefficient) and standard normalization based on coefficient availability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the formattables</span>
        <span class="n">formattables</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_right_side</span><span class="p">(</span>
            <span class="n">index_opts</span><span class="p">,</span>
            <span class="n">start_dims</span><span class="o">=</span><span class="n">start_dims</span><span class="p">,</span>
            <span class="n">end_dims</span><span class="o">=</span><span class="n">end_dims</span><span class="p">,</span>
            <span class="n">offset_adjustment</span><span class="o">=</span><span class="n">offset_adjustment</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If no suffix is provided and this is an observable, we want to add the</span>
        <span class="c1"># coefficient to the set of formattables and use manual normalization.</span>
        <span class="c1"># Otherwise, we just use the standard normalization.</span>
        <span class="k">if</span> <span class="n">dist_suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;norm&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formattables</span><span class="p">[</span><span class="s2">&quot;coeff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="o">.</span><span class="n">get_indexed_varname</span><span class="p">(</span><span class="n">index_opts</span><span class="p">)</span>
                <span class="n">dist_suffix</span> <span class="o">=</span> <span class="s2">&quot;manual_norm&quot;</span>

        <span class="c1"># Build the right side</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">STAN_DIST</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">dist_suffix</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">write_dist_args</span><span class="p">(</span><span class="o">**</span><span class="n">formattables</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">transformed_data</span><span class="o">.</span><span class="n">LogMultinomialCoefficient</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the multinomial coefficient component if it exists.</span>

<span class="sd">        :returns: Multinomial coefficient component or None</span>
<span class="sd">        :rtype: Optional[LogMultinomialCoefficient]</span>

<span class="sd">        The coefficient is automatically created for observable parameters</span>
<span class="sd">        and removed when the parameter gains other children, optimizing</span>
<span class="sd">        computation by pre-calculating constant terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">SciStanPy API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/index.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../scistanpy.html">scistanpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Microsoft Corporation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>