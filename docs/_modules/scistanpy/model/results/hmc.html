<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scistanpy.model.results.hmc &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scistanpy.model.results.hmc</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation.</span>
<span class="c1"># Licensed under the MIT license.</span>

<span class="sd">&quot;&quot;&quot;Hamiltonian Monte Carlo (HMC) sampling results analysis and diagnostics.</span>

<span class="sd">This module provides tools for analyzing and diagnosing HMC sampling results from</span>
<span class="sd">Stan models. It offers specialized classes and functions for processing</span>
<span class="sd">MCMC output, conducting diagnostic tests, and creating interactive visualizations</span>
<span class="sd">for model validation and troubleshooting.</span>

<span class="sd">The module centers around the SampleResults class, which extends MLEInferenceRes</span>
<span class="sd">to provide HMC-specific functionality including convergence diagnostics, sample</span>
<span class="sd">quality assessment, and specialized visualization tools for identifying problematic</span>
<span class="sd">parameters and sampling behavior.</span>

<span class="sd">Key Features:</span>
<span class="sd">    - MCMC diagnostic test suites</span>
<span class="sd">    - Interactive visualization tools for failed diagnostics</span>
<span class="sd">    - Efficient CSV to NetCDF conversion for large datasets</span>
<span class="sd">    - Dask-enabled processing for memory-intensive operations</span>
<span class="sd">    - Specialized trace plot analysis for problematic variables</span>
<span class="sd">    - Automated detection and reporting of sampling issues</span>

<span class="sd">Diagnostic Capabilities:</span>
<span class="sd">    - R-hat convergence assessment</span>
<span class="sd">    - Effective sample size (ESS) evaluation</span>
<span class="sd">    - Energy fraction of missing information (E-BFMI) analysis</span>
<span class="sd">    - Divergence detection and analysis</span>
<span class="sd">    - Tree depth saturation monitoring</span>
<span class="sd">    - Variable-specific failure pattern identification</span>

<span class="sd">The module is designed to handle both small-scale interactive analysis and</span>
<span class="sd">large-scale batch processing of MCMC results, with particular attention to</span>
<span class="sd">memory efficiency and computational performance for complex models.</span>

<span class="sd">Performance Considerations:</span>
<span class="sd">    - NetCDF storage format for efficient large dataset handling</span>
<span class="sd">    - Dask integration for out-of-core computation</span>
<span class="sd">    - Chunked processing strategies for memory management</span>
<span class="sd">    - Optimized data structures for diagnostic computation</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">glob</span><span class="w"> </span><span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">arviz</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">az</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dask</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">holoviews</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">hv</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5netcdf</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">panel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">cmdstanpy.cmdstan_args</span><span class="w"> </span><span class="kn">import</span> <span class="n">CmdStanArgs</span><span class="p">,</span> <span class="n">SamplerArgs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cmdstanpy.stanfit</span><span class="w"> </span><span class="kn">import</span> <span class="n">CmdStanMCMC</span><span class="p">,</span> <span class="n">RunSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cmdstanpy.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_sampler_csv</span><span class="p">,</span> <span class="n">scan_config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">plotting</span><span class="p">,</span> <span class="n">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.defaults</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_EBFMI_THRESH</span><span class="p">,</span>
    <span class="n">DEFAULT_ESS_THRESH</span><span class="p">,</span>
    <span class="n">DEFAULT_RHAT_THRESH</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.components.transformations</span><span class="w"> </span><span class="kn">import</span> <span class="n">transformed_parameters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy.model.results</span><span class="w"> </span><span class="kn">import</span> <span class="n">mle</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">custom_types</span><span class="p">,</span> <span class="n">Model</span>

<span class="c1"># pylint: disable=too-many-lines</span>

<span class="c1"># Maps between the precision of the data and the numpy types</span>
<span class="n">_NP_TYPE_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;double&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">},</span>
    <span class="s2">&quot;single&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span>
    <span class="s2">&quot;half&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">},</span>
<span class="p">}</span>


<div class="viewcode-block" id="_symmetrize_quantiles">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc._symmetrize_quantiles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_symmetrize_quantiles</span><span class="p">(</span>
    <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Symmetrize and validate quantile sequences for plotting.</span>

<span class="sd">    This utility function takes a sequence of quantiles and creates a symmetric</span>
<span class="sd">    set by adding complementary quantiles and ensuring the median is included.</span>
<span class="sd">    It also validates that all quantiles are properly bounded.</span>

<span class="sd">    :param quantiles: Sequence of quantile values between 0 and 1</span>
<span class="sd">    :type quantiles: Sequence[custom_types.Float]</span>

<span class="sd">    :returns: Symmetrized and sorted list of quantiles including median</span>
<span class="sd">    :rtype: list[custom_types.Float]</span>

<span class="sd">    :raises ValueError: If quantiles are not between 0 and 1</span>
<span class="sd">    :raises AssertionError: If result doesn&#39;t have odd length or include median</span>

<span class="sd">    The function ensures:</span>
<span class="sd">    - All quantiles are between 0 and 1 (exclusive)</span>
<span class="sd">    - Complementary quantiles are added (e.g., 0.1 â†’ 0.1, 0.9)</span>
<span class="sd">    - Median (0.5) is always included</span>
<span class="sd">    - Result has odd length for symmetric confidence intervals</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; quantiles = _symmetrize_quantiles([0.1, 0.2])</span>
<span class="sd">        &gt;&gt;&gt; # Returns [0.1, 0.2, 0.5, 0.8, 0.9]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the quantiles</span>
    <span class="n">quantiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="mi">1</span> <span class="o">-</span> <span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quantiles</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="mf">0.5</span><span class="p">})</span>

    <span class="c1"># Check that the quantiles are between 0 and 1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quantiles</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Quantiles must be between 0 and 1. Please provide a valid list of &quot;</span>
            <span class="s2">&quot;quantiles.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Check that the quantiles are odd in number and include 0.5</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Quantiles must be odd in number&quot;</span>
    <span class="n">median_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">quantiles</span><span class="p">[</span><span class="n">median_ind</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;Quantiles must include 0.5&quot;</span>

    <span class="k">return</span> <span class="n">quantiles</span></div>



<div class="viewcode-block" id="VariableAnalyzer">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.VariableAnalyzer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariableAnalyzer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interactive analysis tool for variables that fail MCMC diagnostic tests.</span>

<span class="sd">    This class provides an interactive interface for analyzing individual variables</span>
<span class="sd">    that have failed diagnostic tests during MCMC sampling. It creates a dashboard</span>
<span class="sd">    with widgets for selecting variables, metrics, and specific array indices,</span>
<span class="sd">    along with trace plots showing the problematic sampling behavior.</span>

<span class="sd">    :param sample_results: SampleResults object containing MCMC diagnostics</span>
<span class="sd">    :type sample_results: SampleResults</span>
<span class="sd">    :param plot_width: Width of plots in pixels. Defaults to 800.</span>
<span class="sd">    :type plot_width: custom_types.Integer</span>
<span class="sd">    :param plot_height: Height of plots in pixels. Defaults to 400.</span>
<span class="sd">    :type plot_height: custom_types.Integer</span>
<span class="sd">    :param plot_quantiles: Whether to plot quantiles vs raw values. Defaults to False.</span>
<span class="sd">    :type plot_quantiles: bool</span>

<span class="sd">    :ivar sample_results: Reference to source sampling results</span>
<span class="sd">    :ivar plot_quantiles: Flag controlling plot content type</span>
<span class="sd">    :ivar n_chains: Number of MCMC chains in the results</span>
<span class="sd">    :ivar x: Array of step indices for x-axis</span>
<span class="sd">    :ivar failed_vars: Dictionary mapping variable names to failure information</span>
<span class="sd">    :ivar varchoice: Widget for selecting variables to analyze</span>
<span class="sd">    :ivar metricchoice: Widget for selecting diagnostic metrics</span>
<span class="sd">    :ivar indexchoice: Widget for selecting array indices</span>
<span class="sd">    :ivar plot_width: Recorded width of plots</span>
<span class="sd">    :ivar plot_height: Recorded height of plots</span>
<span class="sd">    :ivar fig: HoloViews pane containing the current plot</span>
<span class="sd">    :ivar layout: Panel layout containing all interface elements</span>

<span class="sd">    The analyzer automatically identifies variables that have failed diagnostic</span>
<span class="sd">    tests and organizes them by failure type. It provides trace plots that can</span>
<span class="sd">    show either raw parameter values or their quantiles relative to passing</span>
<span class="sd">    samples, helping identify the nature of sampling problems.</span>

<span class="sd">    Key Features:</span>
<span class="sd">    - Automatic identification of failed variables and metrics</span>
<span class="sd">    - Interactive widget-based navigation</span>
<span class="sd">    - Trace plots with chain-specific coloring</span>
<span class="sd">    - Quantile-based analysis for identifying sampling bias</span>
<span class="sd">    - Real-time plot updates based on widget selections</span>

<span class="sd">    Note:</span>
<span class="sd">        This class should not be instantiated directly. Use the</span>
<span class="sd">        plot_variable_failure_quantile_traces method of SampleResults instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=attribute-defined-outside-init</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_results</span><span class="p">:</span> <span class="s2">&quot;SampleResults&quot;</span><span class="p">,</span>
        <span class="n">plot_width</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
        <span class="n">plot_height</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
        <span class="n">plot_quantiles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># Hold a reference to the sample results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_results</span> <span class="o">=</span> <span class="n">sample_results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_quantiles</span> <span class="o">=</span> <span class="n">plot_quantiles</span>

        <span class="c1"># Some placeholders for whether or not we both updating the plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_vals</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Record the number of chains and an array for the steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_chains</span> <span class="o">=</span> <span class="n">sample_results</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sample_results</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;draw&quot;</span><span class="p">])</span>

        <span class="c1"># Identify failed variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identify_failed_vars</span><span class="p">()</span>

        <span class="c1"># Set up the holoviews plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_width</span> <span class="o">=</span> <span class="n">plot_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_height</span> <span class="o">=</span> <span class="n">plot_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">pane</span><span class="o">.</span><span class="n">HoloViews</span><span class="p">(</span>
            <span class="n">hv</span><span class="o">.</span><span class="n">Curve</span><span class="p">([])</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_height</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Plot&quot;</span><span class="p">,</span>
            <span class="n">align</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set up widgets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">widgets</span><span class="o">.</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">widgets</span><span class="o">.</span><span class="n">Select</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Metric&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">widgets</span><span class="o">.</span><span class="n">Select</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_var_data</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_metric_selector</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_metric_data</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_index_selector</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_plot</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_metric_data</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_index_selector</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_plot</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_update_plot</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>

        <span class="c1"># Package widgets and figure into a layout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Trigger the initial data retrieval and plotting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_identify_failed_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify variables that failed diagnostic tests.</span>

<span class="sd">        This method analyzes the variable diagnostic tests in the SampleResults</span>
<span class="sd">        object to identify which variables failed which tests, organizing the</span>
<span class="sd">        information for easy access by the widget interface.</span>

<span class="sd">        The method populates the failed_vars dictionary with variable names as</span>
<span class="sd">        keys and tuples containing dimension information and failure details</span>
<span class="sd">        as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Identify both the variables that fail and their indices</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">varname</span><span class="p">,</span>
            <span class="n">vartests</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_results</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_tests</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># The first variable name is the metric</span>
            <span class="k">assert</span> <span class="n">vartests</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;metric&quot;</span>

            <span class="c1"># Process each metric for this variable</span>
            <span class="n">metric_test_summaries</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">vartests</span><span class="o">.</span><span class="n">metric</span><span class="p">:</span>

                <span class="c1"># Get the test results for the metric</span>
                <span class="n">metrictests</span> <span class="o">=</span> <span class="n">vartests</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

                <span class="c1"># Get the indices of the failing tests</span>
                <span class="k">if</span> <span class="n">metrictests</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">failing_inds</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">metrictests</span><span class="p">))</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">failing_inds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">metrictests</span> <span class="k">else</span> <span class="p">[]</span>  <span class="c1"># Just variable name</span>

                <span class="c1"># Record the failing tests</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">failing_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">metric_test_summaries</span><span class="p">[</span><span class="n">metric</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">=</span> <span class="n">failing_inds</span>

            <span class="c1"># If there are any failing tests, add them to the dictionary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric_test_summaries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vartests</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">metric_test_summaries</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_metric_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update metric selection options based on selected variable.</span>

<span class="sd">        :param event: Panel event object (required for callback interface)</span>

<span class="sd">        This callback method updates the available metric options when a new</span>
<span class="sd">        variable is selected, ensuring only relevant diagnostic metrics are</span>
<span class="sd">        shown for the current variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the current variable name</span>
        <span class="n">current_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Update the metric choice options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># If the currently selected metric is not in the new options, set it to</span>
        <span class="c1"># the first one</span>
        <span class="k">if</span> <span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update index selection options based on selected variable and metric.</span>

<span class="sd">        :param event: Panel event object (required for callback interface)</span>

<span class="sd">        This callback method updates the available index options when a new</span>
<span class="sd">        variable or metric is selected, showing only the array indices that</span>
<span class="sd">        failed the selected diagnostic test.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the current variable name</span>
        <span class="n">current_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Update the index choice options</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

        <span class="c1"># If the currently selected index is not in the new options, set it to</span>
        <span class="c1"># the first one</span>
        <span class="k">if</span> <span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_var_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve and prepare data for the selected variable.</span>

<span class="sd">        :param event: Panel event object (required for callback interface)</span>

<span class="sd">        This callback method loads the sample data for the currently selected</span>
<span class="sd">        variable and prepares it for analysis and visualization, including</span>
<span class="sd">        dimension validation and array reshaping.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the samples for the selected variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_results</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span>

        <span class="c1"># Check the dimensions of the variable</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_vars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We also want the samples as a numpy array with the draw and chain dimensions</span>
        <span class="c1"># last</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_samples</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_metric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve and prepare diagnostic test data for the selected metric.</span>

<span class="sd">        :param event: Panel event object (required for callback interface)</span>

<span class="sd">        This callback method processes the diagnostic test results for the</span>
<span class="sd">        currently selected metric, separating failing and passing samples</span>
<span class="sd">        for comparative analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the tests for the selected variable and metric</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_results</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_tests</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span>
        <span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Make sure the dimensions are correct</span>
        <span class="k">assert</span> <span class="n">tests</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Tests as numpy array</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">tests</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Map between index name and failing index. Separate the failing and passing</span>
        <span class="c1"># samples. Note the different approach for scalar variables (no indices)</span>
        <span class="k">if</span> <span class="n">tests</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="o">...</span><span class="p">}</span>  <span class="c1"># No indices, no map</span>
            <span class="k">if</span> <span class="n">tests</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_passing_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_passing_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">indices</span><span class="p">)):</span> <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">tests</span><span class="p">)))</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_passing_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="p">[</span><span class="n">tests</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_np_samples</span><span class="p">[</span><span class="o">~</span><span class="n">tests</span><span class="p">],</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the trace plot based on current widget selections.</span>

<span class="sd">        :param event: Panel event object (required for callback interface)</span>

<span class="sd">        This callback method generates new trace plots when widget selections</span>
<span class="sd">        change, creating overlays that show sampling traces for each chain</span>
<span class="sd">        with appropriate styling and hover information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Skip the update if the values haven&#39;t changed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previous_vals</span> <span class="o">==</span> <span class="p">(</span>
            <span class="n">new_vals</span> <span class="o">:=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_vals</span> <span class="o">=</span> <span class="n">new_vals</span>

        <span class="c1"># Get the variable name</span>
        <span class="n">varname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Calculate the relative quantiles for the selected failing index relative</span>
        <span class="c1"># to the passing samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>  <span class="c1"># For scalars</span>
            <span class="n">failing_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failing_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indexchoice</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="n">n_failing</span><span class="p">,</span> <span class="n">n_passing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_failing_samples</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_passing_samples</span><span class="p">)</span>

        <span class="c1"># We always calculate quantiles. If there are no reference samples, however,</span>
        <span class="c1"># quantiles are undefined. We raise a warning if there are more failing</span>
        <span class="c1"># samples than passing samples and the user is trying to plot quantiles.</span>
        <span class="k">if</span> <span class="n">n_passing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_quantiles</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No passing samples found for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">. Cannot &quot;</span>
                    <span class="s2">&quot;calculate quantiles.&quot;</span>
                <span class="p">)</span>
            <span class="n">failing_quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">failing_samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_failing</span> <span class="o">&gt;</span> <span class="n">n_passing</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_quantiles</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;There are more failing samples than passing samples for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">varchoice</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s2">. Consider plotting true values instead.&quot;</span>
                <span class="p">)</span>
            <span class="n">failing_quantiles</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">calculate_relative_quantiles</span><span class="p">(</span>
                <span class="n">reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_passing_samples</span><span class="p">,</span>
                <span class="n">observed</span><span class="o">=</span><span class="n">failing_samples</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We should have shape (n_chains, n_draws)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">failing_samples</span><span class="o">.</span><span class="n">shape</span>
            <span class="o">==</span> <span class="n">failing_quantiles</span><span class="o">.</span><span class="n">shape</span>
            <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Build an overlay for the failing quantiles and use it to update the plot</span>
        <span class="n">overlay_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chains</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_quantiles</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_quantiles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">failing_samples</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">order_vdim</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sample Quantile&quot;</span><span class="p">,</span> <span class="s2">&quot;Sample Value&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">failing_quantiles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">order_vdim</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sample Value&quot;</span><span class="p">,</span> <span class="s2">&quot;Sample Quantile&quot;</span><span class="p">]</span>
            <span class="n">overlay_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">order</span><span class="p">,</span> <span class="n">n_passing</span><span class="p">),</span>
                <span class="n">kdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Step&quot;</span><span class="p">],</span>
                <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">order_vdim</span><span class="p">,</span> <span class="s2">&quot;N Reference Variables&quot;</span><span class="p">],</span>
            <span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">line_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="p">({</span><span class="s2">&quot;ylim&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_quantiles</span> <span class="k">else</span> <span class="p">{}))</span>

        <span class="c1"># Create the overlay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">NdOverlay</span><span class="p">(</span><span class="n">overlay_dict</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="s2">&quot;Chain&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metricchoice</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;hover&quot;</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_height</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="VariableAnalyzer.display">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.VariableAnalyzer.display">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display the complete interactive analysis interface.</span>

<span class="sd">        :returns: Panel layout containing all widgets and plots</span>
<span class="sd">        :rtype: pn.Layout</span>

<span class="sd">        This method returns the complete interactive interface for display</span>
<span class="sd">        in Jupyter notebooks or Panel applications.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span></div>
</div>



<div class="viewcode-block" id="CmdStanMCMCToNetCDFConverter">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.CmdStanMCMCToNetCDFConverter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CmdStanMCMCToNetCDFConverter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Efficient converter from CmdStan CSV output to NetCDF format.</span>

<span class="sd">    This class handles the conversion of CmdStan CSV output files to NetCDF</span>
<span class="sd">    format, providing efficient storage and access for large MCMC datasets.</span>
<span class="sd">    It properly organizes data into appropriate groups and handles dimension</span>
<span class="sd">    naming and chunking strategies.</span>

<span class="sd">    :param fit: CmdStanMCMC object or path to CSV files</span>
<span class="sd">    :type fit: Union[CmdStanMCMC, str, list[str], os.PathLike]</span>
<span class="sd">    :param model: SciStanPy model object for metadata extraction</span>
<span class="sd">    :type model: Model</span>
<span class="sd">    :param data: Optional observed data dictionary. Defaults to None.</span>
<span class="sd">    :type data: Optional[dict[str, Any]]</span>

<span class="sd">    :ivar fit: CmdStanMCMC object containing sampling results</span>
<span class="sd">    :ivar model: Reference to the original SciStanPy model</span>
<span class="sd">    :ivar data: Observed data used for model fitting</span>
<span class="sd">    :ivar config: Configuration dictionary from Stan sampling</span>
<span class="sd">    :ivar num_draws: Total number of draws including warmup if saved</span>
<span class="sd">    :ivar varname_to_column_order: Mapping from variables to csv column indices</span>

<span class="sd">    The converter handles:</span>
<span class="sd">    - Automatic detection of variable types and dimensions</span>
<span class="sd">    - Proper NetCDF group organization</span>
<span class="sd">    - Chunking strategies for large datasets</span>
<span class="sd">    - Data type optimization based on precision requirements</span>

<span class="sd">    This class is used internally by the cmdstan_csv_to_netcdf function and</span>
<span class="sd">    should not be instantiated directly in most use cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">:</span> <span class="n">CmdStanMCMC</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;Model&quot;</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization involves collecting information about the different variables</span>
<span class="sd">        in the fit object. This includes the names of the variables, their shapes,</span>
<span class="sd">        and their types. This information is used to create the HDF5 file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If `fit` is a string, we assume we need to load it from disk</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">fit_from_csv_noload</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

        <span class="c1"># The fit and model are stored as attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Record the config object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">cmdstan_config</span>

        <span class="c1"># The number of chains is per thread. We want the number of chains total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;total_chains&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">runset</span><span class="o">.</span><span class="n">csv_files</span><span class="p">)</span>

        <span class="c1"># How many samples are we expecting?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_warmup&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;save_warmup&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># Argsort the columns for each variable such that the columns are in row-major</span>
        <span class="c1"># order. This is important for efficiently saving to the HDF5 file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varname_to_column_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_c_order</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_c_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine optimal column ordering for efficient NetCDF storage.</span>

<span class="sd">        :returns: Dictionary mapping variable names to column order arrays</span>
<span class="sd">        :rtype: dict[str, npt.NDArray[np.int64]]</span>

<span class="sd">        This method analyzes the CSV column structure to determine the optimal</span>
<span class="sd">        ordering for writing multi-dimensional arrays to NetCDF format, ensuring</span>
<span class="sd">        efficient memory access patterns and proper array reconstruction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need a regular expression for parsing indices out of variable names</span>
        <span class="n">ind_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\[([0-9,]+)\]&quot;</span><span class="p">)</span>

        <span class="c1"># Get the indices of each column in the csv files. If there is no match,</span>
        <span class="c1"># then there are no indices and we return an empty tuple.</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">match_obj</span> <span class="o">:=</span> <span class="n">ind_re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
                <span class="k">else</span> <span class="p">()</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">column_names</span>
        <span class="p">]</span>

        <span class="c1"># Now we assign the row-major argsort of indices to each variable</span>
        <span class="n">varname_to_column_order</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">method_vars</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">stan_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">):</span>

            <span class="c1"># Slice out the indices for this variable</span>
            <span class="n">var_inds</span> <span class="o">=</span> <span class="n">column_indices</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">start_idx</span> <span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">end_idx</span><span class="p">]</span>

            <span class="c1"># All indices must be unique</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">var_inds</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_inds</span><span class="p">)</span>

            <span class="c1"># All indices should have the appropriate number of dimensions</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">var_inds</span><span class="p">)</span>

            <span class="c1"># All indices should fit within the dimensions of the variable</span>
            <span class="k">for</span> <span class="n">dimind</span><span class="p">,</span> <span class="n">dimsize</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">dimind</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dimsize</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">var_inds</span><span class="p">)</span>

            <span class="c1"># Argsort the indices such that the last dimension changes fastest (c-major)</span>
            <span class="n">varname_to_column_order</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_inds</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">var_inds</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">varname_to_column_order</span>

<div class="viewcode-block" id="CmdStanMCMCToNetCDFConverter.write_netcdf">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.CmdStanMCMCToNetCDFConverter.write_netcdf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;half&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
        <span class="n">mib_per_chunk</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the converted data to NetCDF format.</span>

<span class="sd">        :param filename: Output filename. Auto-generated if None. Defaults to None.</span>
<span class="sd">        :type filename: Optional[str]</span>
<span class="sd">        :param precision: Numerical precision for arrays. Defaults to &quot;single&quot;.</span>
<span class="sd">        :type precision: Literal[&quot;double&quot;, &quot;single&quot;, &quot;half&quot;]</span>
<span class="sd">        :param mib_per_chunk: Memory limit per chunk in MiB. Defaults to None, meaning</span>
<span class="sd">            use Dask default.</span>
<span class="sd">        :type mib_per_chunk: Optional[custom_types.Integer]</span>

<span class="sd">        :returns: Path to the created NetCDF file</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        This method orchestrates the complete conversion process:</span>
<span class="sd">        1. Creates NetCDF file with appropriate structure</span>
<span class="sd">        2. Sets up dimensions based on model and data characteristics</span>
<span class="sd">        3. Creates variables with optimal chunking strategies</span>
<span class="sd">        4. Populates data from CSV files with progress tracking</span>

<span class="sd">        The resulting NetCDF file contains properly organized groups for</span>
<span class="sd">        posterior samples, posterior predictive samples, sample statistics,</span>
<span class="sd">        and observed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no filename is provided, we create one based on the csv files</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filename</span>
            <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">runset</span><span class="o">.</span><span class="n">csv_files</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nc&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Get the data types for the method and stan variables</span>
        <span class="n">method_var_dtypes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;lp__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="s2">&quot;accept_stat__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="s2">&quot;stepsize__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="s2">&quot;treedepth__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;int&quot;</span><span class="p">],</span>
            <span class="s2">&quot;n_leapfrog__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;int&quot;</span><span class="p">],</span>
            <span class="s2">&quot;divergent__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;int&quot;</span><span class="p">],</span>
            <span class="s2">&quot;energy__&quot;</span><span class="p">:</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">stan_var_dtypes</span><span class="p">,</span> <span class="n">stan_var_dimnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stan_var_dtypes_dimnames</span><span class="p">(</span>
            <span class="n">precision</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">stan_var_dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">method_var_dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">),</span> <span class="s2">&quot;Stan variable names should not overlap with method variable names.&quot;</span>

        <span class="c1"># Create the HDF5 file</span>
        <span class="k">with</span> <span class="n">h5netcdf</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">netcdf_file</span><span class="p">:</span>

            <span class="c1"># Write attributes to the file</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">&quot;stan_version_major&quot;</span><span class="p">,</span>
                <span class="s2">&quot;stan_version_minor&quot;</span><span class="p">,</span>
                <span class="s2">&quot;stan_version_patch&quot;</span><span class="p">,</span>
                <span class="s2">&quot;model&quot;</span><span class="p">,</span>
                <span class="s2">&quot;start_datetime&quot;</span><span class="p">,</span>
                <span class="s2">&quot;method&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_warmup&quot;</span><span class="p">,</span>
                <span class="s2">&quot;save_warmup&quot;</span><span class="p">,</span>
                <span class="s2">&quot;max_depth&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_chains&quot;</span><span class="p">,</span>
                <span class="s2">&quot;data_file&quot;</span><span class="p">,</span>
                <span class="s2">&quot;diagnostic_file&quot;</span><span class="p">,</span>
                <span class="s2">&quot;seed&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sig_figs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_threads&quot;</span><span class="p">,</span>
                <span class="s2">&quot;stanc_version&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">netcdf_file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">cmdstan_config</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

            <span class="c1"># Set dimensions</span>
            <span class="n">netcdf_file</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;chain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;total_chains&quot;</span><span class="p">],</span>
                <span class="s2">&quot;draw&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">dimname</span><span class="p">:</span> <span class="n">dimsize</span>
                    <span class="k">for</span> <span class="n">varinfo</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stan_var_dimnames</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">dimname</span><span class="p">,</span> <span class="n">dimsize</span> <span class="ow">in</span> <span class="n">varinfo</span>
                <span class="p">},</span>
            <span class="p">}</span>

            <span class="c1"># We need a group for metadata, samples, posterior predictive checks,</span>
            <span class="c1"># observations, and transformed parameters.</span>
            <span class="n">metadata_group</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;sample_stats&quot;</span><span class="p">)</span>
            <span class="n">sample_group</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;posterior&quot;</span><span class="p">)</span>
            <span class="n">ppc_group</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;posterior_predictive&quot;</span><span class="p">)</span>
            <span class="n">observed_group</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;observed_data&quot;</span><span class="p">)</span>

            <span class="c1"># Create variables for each of the method variables. Build a mapping</span>
            <span class="c1"># from the variable name to the dataset object. We store all of the</span>
            <span class="c1"># method variables with a single chunk.</span>
            <span class="n">varname_to_dset</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">varname</span><span class="p">:</span> <span class="n">metadata_group</span><span class="o">.</span><span class="n">create_variable</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">varname</span><span class="p">,</span>
                    <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">method_var_dtypes</span><span class="p">[</span><span class="n">varname</span><span class="p">],</span>
                    <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;total_chains&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">method_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="c1"># Now we can create a dataset for each stan variable. We update the</span>
            <span class="c1"># mapping from the variable name to the dataset object</span>
            <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">stan_dtype</span> <span class="ow">in</span> <span class="n">stan_var_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># Get the shape of the variable</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_info</span> <span class="o">:=</span> <span class="n">stan_var_dimnames</span><span class="p">[</span><span class="n">varname</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">named_shape</span><span class="p">,</span> <span class="n">true_shape</span> <span class="o">=</span> <span class="p">(),</span> <span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">named_shape</span><span class="p">,</span> <span class="n">true_shape</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">shape_info</span><span class="p">)</span>

                <span class="c1"># Calculate the chunk shape. We always hold the first two dimensions</span>
                <span class="c1"># frozen. This is because the first two dimensions are what we</span>
                <span class="c1"># are typically performing operations over.</span>
                <span class="n">chunk_shape</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_chunk_shape</span><span class="p">(</span>
                    <span class="n">array_shape</span><span class="o">=</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;total_chains&quot;</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">true_shape</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">array_precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="n">mib_per_chunk</span><span class="p">,</span>
                    <span class="n">frozen_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="c1"># We record without the &#39;_ppc&#39; suffix</span>
                <span class="n">recorded_varname</span> <span class="o">=</span> <span class="n">varname</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="s2">&quot;_ppc&quot;</span><span class="p">)</span>

                <span class="c1"># Build the group</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">ppc_group</span> <span class="k">if</span> <span class="n">varname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_ppc&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">sample_group</span>
                <span class="n">varname_to_dset</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">create_variable</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">recorded_varname</span><span class="p">,</span>
                    <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">named_shape</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">stan_dtype</span><span class="p">,</span>
                    <span class="n">chunks</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># If an observable, also create a dataset in the observed group</span>
                <span class="c1"># and populate it with the data</span>
                <span class="k">if</span> <span class="n">varname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_ppc&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">observed_group</span><span class="o">.</span><span class="n">create_variable</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">recorded_varname</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">recorded_varname</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                        <span class="n">dimensions</span><span class="o">=</span><span class="n">named_shape</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">stan_dtype</span><span class="p">,</span>
                        <span class="n">chunks</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                    <span class="p">)</span>

            <span class="c1"># Now we populate the datasets with the data from the csv files</span>
            <span class="k">for</span> <span class="n">chain_ind</span><span class="p">,</span> <span class="n">csv_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">tqdm</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">runset</span><span class="o">.</span><span class="n">csv_files</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Converting CSV to NetCDF&quot;</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">draw_ind</span><span class="p">,</span> <span class="n">draw</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">tqdm</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_csv</span><span class="p">(</span>
                            <span class="n">filename</span><span class="o">=</span><span class="n">csv_file</span><span class="p">,</span>
                            <span class="n">method_var_dtypes</span><span class="o">=</span><span class="n">method_var_dtypes</span><span class="p">,</span>
                            <span class="n">stan_var_dtypes</span><span class="o">=</span><span class="n">stan_var_dtypes</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span><span class="p">,</span>
                        <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Processing chain </span><span class="si">{</span><span class="n">chain_ind</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvals</span> <span class="ow">in</span> <span class="n">draw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">varname_to_dset</span><span class="p">[</span><span class="n">varname</span><span class="p">][</span>
                            <span class="n">chain_ind</span><span class="p">,</span> <span class="n">draw_ind</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">varvals</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

                <span class="c1"># We must have all the draws for this chain</span>
                <span class="k">assert</span> <span class="n">draw_ind</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_draws</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># pylint: disable=W0631</span>

        <span class="k">return</span> <span class="n">filename</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_stan_var_dtypes_dimnames</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;half&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span> <span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine data types and dimension names for Stan variables.</span>

<span class="sd">        :param precision: Numerical precision specification</span>
<span class="sd">        :type precision: Literal[&quot;double&quot;, &quot;single&quot;, &quot;half&quot;]</span>

<span class="sd">        :returns: Tuple of (data_types_dict, dimension_names_dict)</span>
<span class="sd">        :rtype: tuple[dict[str, Union[type[np.floating], type[np.integer]]],</span>
<span class="sd">            dict[str, tuple[tuple[str, int], ...]]]</span>

<span class="sd">        This method analyzes the SciStanPy model to determine appropriate</span>
<span class="sd">        NumPy data types and dimension naming schemes for all variables</span>
<span class="sd">        that will be stored in the NetCDF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_dimname</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[()]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Retrieves the dimension names for the current component.&quot;&quot;&quot;</span>
            <span class="c1"># Get the name of the dimensions</span>
            <span class="n">named_shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dimind</span><span class="p">,</span> <span class="n">dimsize</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

                <span class="c1"># See if we can get the name of the dimension. If we cannot, this must</span>
                <span class="c1"># be a singleton dimension</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dimname</span> <span class="o">:=</span> <span class="n">dim_map</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">dimind</span><span class="p">,</span> <span class="n">dimsize</span><span class="p">)))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">dimsize</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">continue</span>

                <span class="c1"># If we have a name, record</span>
                <span class="n">named_shape</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dimname</span><span class="p">,</span> <span class="n">dimsize</span><span class="p">))</span>

            <span class="c1"># If we have no dimensions, we return an empty tuple</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">named_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">()</span>

            <span class="c1"># We have our named shape</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">named_shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># We will need the map from dimension depth and size to dimension name</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_dimname_map</span><span class="p">()</span>

        <span class="c1"># Datatypes for the stan variables</span>
        <span class="n">stan_var_dtypes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stan_var_dimnames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_model_components_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># We only take parameters and transformed parameters</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">component</span><span class="p">,</span>
                <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">transformed_parameters</span><span class="o">.</span><span class="n">TransformedParameter</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Update the varname if needed</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">component</span><span class="o">.</span><span class="n">observable</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s2">_ppc&quot;</span>

            <span class="c1"># Record the datatype</span>
            <span class="n">stan_var_dtypes</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_NP_TYPE_MAP</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span>
                <span class="p">(</span>
                    <span class="s2">&quot;int&quot;</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">DiscreteDistribution</span><span class="p">)</span>
                    <span class="k">else</span> <span class="s2">&quot;float&quot;</span>
                <span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Record the dimension names</span>
            <span class="n">stan_var_dimnames</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dimname</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stan_var_dtypes</span><span class="p">,</span> <span class="n">stan_var_dimnames</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method_var_dtypes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span> <span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]],</span>
        <span class="n">stan_var_dtypes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span> <span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse CSV file and yield properly formatted arrays.</span>

<span class="sd">        :param filename: Path to CSV file to parse</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :param method_var_dtypes: Data types for method variables</span>
<span class="sd">        :type method_var_dtypes: dict[str, Union[type[np.floating], type[np.integer]]]</span>
<span class="sd">        :param stan_var_dtypes: Data types for Stan variables</span>
<span class="sd">        :type stan_var_dtypes: dict[str, Union[type[np.floating], type[np.integer]]]</span>

<span class="sd">        :yields: Dictionary of variable names to properly shaped arrays for each draw</span>
<span class="sd">        :rtype: Generator[dict[str, npt.NDArray], None, None]</span>

<span class="sd">        This generator function parses CSV files line by line, converting each</span>
<span class="sd">        row into properly typed and shaped NumPy arrays according to the</span>
<span class="sd">        variable specifications determined during initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Start parsing the file line by line</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csv_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">csv_file</span><span class="p">:</span>

                <span class="c1"># Skip the header information. This was parsed by the fit object.</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lp__&quot;</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Split the components of the line</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>

                <span class="c1"># Build the arrays for each variable</span>
                <span class="n">processed_vals</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                    <span class="n">method_var_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">stan_var_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">):</span>

                    <span class="c1"># Get the variable object from the metadata</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                        <span class="s2">&quot;stan_vars&quot;</span> <span class="k">if</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">stan_var_dtypes</span> <span class="k">else</span> <span class="s2">&quot;method_vars&quot;</span><span class="p">,</span>
                    <span class="p">)[</span><span class="n">varname</span><span class="p">]</span>

                    <span class="c1"># Using that variable object, slice out the data, convert to</span>
                    <span class="c1"># an appropriately typed numpy array, reorder it such that it</span>
                    <span class="c1"># is a flattened row-major array, then reshape it to the final</span>
                    <span class="c1"># shape. Note that we convert to a float first followed by a</span>
                    <span class="c1"># conversion to the final type. This is because some numbers</span>
                    <span class="c1"># are stored in the CSV as scientific notation.</span>
                    <span class="n">processed_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">start_idx</span> <span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">end_idx</span><span class="p">]]</span>
                    <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">varname_to_column_order</span><span class="p">[</span><span class="n">varname</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                        <span class="n">processed_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">processed_val</span><span class="p">)</span>
                    <span class="n">processed_val</span> <span class="o">=</span> <span class="n">processed_val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

                    <span class="c1"># Confirm that the array is c-contiguous and record</span>
                    <span class="k">assert</span> <span class="n">processed_val</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">]</span>
                    <span class="n">processed_vals</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_val</span>

                <span class="c1"># Yield the processed values for this line</span>
                <span class="k">yield</span> <span class="n">processed_vals</span></div>



<div class="viewcode-block" id="cmdstan_csv_to_netcdf">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.cmdstan_csv_to_netcdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span> <span class="o">|</span> <span class="n">CmdStanMCMC</span><span class="p">,</span>
    <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;Model&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;half&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="n">mib_per_chunk</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert CmdStan CSV output to efficient NetCDF format.</span>

<span class="sd">    This function provides a high-level interface for converting CmdStan</span>
<span class="sd">    sampling results from CSV format to NetCDF, enabling efficient storage</span>
<span class="sd">    and processing of large MCMC datasets.</span>

<span class="sd">    :param path: Path to CSV files or CmdStanMCMC object</span>
<span class="sd">    :type path: Union[str, list[str], os.PathLike, CmdStanMCMC]</span>
<span class="sd">    :param model: SciStanPy model used for sampling</span>
<span class="sd">    :type model: Model</span>
<span class="sd">    :param data: Observed data dictionary. Uses model default if None. Defaults to None.</span>
<span class="sd">    :type data: Optional[dict[str, Any]]</span>
<span class="sd">    :param output_filename: Output NetCDF filename. Auto-generated if None. Defaults to None.</span>
<span class="sd">    :type output_filename: Optional[str]</span>
<span class="sd">    :param precision: Numerical precision for stored arrays. Defaults to &quot;single&quot;.</span>
<span class="sd">    :type precision: Literal[&quot;double&quot;, &quot;single&quot;, &quot;half&quot;]</span>
<span class="sd">    :param mib_per_chunk: Memory limit per chunk in MiB. Defaults to None, meaning</span>
<span class="sd">        use Dask default.</span>
<span class="sd">    :type mib_per_chunk: Optional[custom_types.Integer]</span>

<span class="sd">    :returns: Path to created NetCDF file</span>
<span class="sd">    :rtype: str</span>

<span class="sd">    The conversion process:</span>
<span class="sd">    1. Analyzes model structure to determine optimal storage layout</span>
<span class="sd">    2. Creates NetCDF file with appropriate groups and dimensions</span>
<span class="sd">    3. Converts CSV data with proper chunking for memory efficiency</span>
<span class="sd">    4. Organizes results into ArviZ-compatible structure</span>

<span class="sd">    Benefits of NetCDF format:</span>
<span class="sd">    - Significantly faster loading compared to CSV</span>
<span class="sd">    - Memory-efficient access with chunking support</span>
<span class="sd">    - Metadata preservation and self-describing format</span>
<span class="sd">    - Integration with scientific Python ecosystem</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; netcdf_path = cmdstan_csv_to_netcdf(</span>
<span class="sd">        ...     &#39;model_output*.csv&#39;, model, precision=&#39;single&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; results = SampleResults.from_disk(netcdf_path)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If no data, check for default data in the model. Otherwise, data provided</span>
    <span class="c1"># takes priority</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">has_default_data</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">default_data</span>

    <span class="c1"># Build the converter</span>
    <span class="n">converter</span> <span class="o">=</span> <span class="n">CmdStanMCMCToNetCDFConverter</span><span class="p">(</span><span class="n">fit</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Run conversion</span>
    <span class="k">return</span> <span class="n">converter</span><span class="o">.</span><span class="n">write_netcdf</span><span class="p">(</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">output_filename</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">mib_per_chunk</span><span class="o">=</span><span class="n">mib_per_chunk</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="dask_enabled_summary_stats">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.dask_enabled_summary_stats">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dask_enabled_summary_stats</span><span class="p">(</span><span class="n">inference_obj</span><span class="p">:</span> <span class="n">az</span><span class="o">.</span><span class="n">InferenceData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute summary statistics using Dask for memory efficiency.</span>

<span class="sd">    :param inference_obj: ArviZ InferenceData object containing posterior samples</span>
<span class="sd">    :type inference_obj: az.InferenceData</span>

<span class="sd">    :returns: Dataset containing computed summary statistics</span>
<span class="sd">    :rtype: xr.Dataset</span>

<span class="sd">    This function computes basic summary statistics (mean, standard deviation,</span>
<span class="sd">    and highest density intervals) using Dask for memory-efficient computation</span>
<span class="sd">    on large datasets that might not fit in memory.</span>

<span class="sd">    The function leverages Dask&#39;s lazy evaluation to:</span>
<span class="sd">    - Queue multiple computations for efficient execution</span>
<span class="sd">    - Minimize memory usage through chunked processing</span>
<span class="sd">    - Provide progress tracking for long-running computations</span>

<span class="sd">    Computed Statistics:</span>
<span class="sd">    - Mean across chains and draws</span>
<span class="sd">    - Standard deviation across chains and draws</span>
<span class="sd">    - 94% highest density intervals</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; stats = dask_enabled_summary_stats(inference_data)</span>
<span class="sd">        &gt;&gt;&gt; print(stats.sel(metric=&#39;mean&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Queue up the delayed computations</span>
    <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">az_dask</span><span class="p">():</span>
        <span class="n">delayed_summaries</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">)),</span>
            <span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">)),</span>
            <span class="n">az</span><span class="o">.</span><span class="n">hdi</span><span class="p">(</span>
                <span class="n">inference_obj</span><span class="p">,</span>
                <span class="n">hdi_prob</span><span class="o">=</span><span class="mf">0.94</span><span class="p">,</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;hdi&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
            <span class="p">),</span>
        <span class="p">]</span>

        <span class="c1"># Compute the results</span>
        <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">hdi</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">delayed_summaries</span><span class="p">)</span>

    <span class="c1"># Concatenate the results</span>
    <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">mean</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]),</span>
            <span class="n">std</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sd&quot;</span><span class="p">]),</span>
            <span class="n">hdi</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;hdi_3%&quot;</span><span class="p">,</span> <span class="s2">&quot;hdi_97%&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">),</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="dask_enabled_diagnostics">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.dask_enabled_diagnostics">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dask_enabled_diagnostics</span><span class="p">(</span><span class="n">inference_obj</span><span class="p">:</span> <span class="n">az</span><span class="o">.</span><span class="n">InferenceData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute MCMC diagnostics using Dask for memory efficiency.</span>

<span class="sd">    :param inference_obj: ArviZ InferenceData object containing posterior samples</span>
<span class="sd">    :type inference_obj: az.InferenceData</span>

<span class="sd">    :returns: Dataset containing computed diagnostic metrics</span>
<span class="sd">    :rtype: xr.Dataset</span>

<span class="sd">    This function computes comprehensive MCMC diagnostic metrics using Dask</span>
<span class="sd">    for memory-efficient computation on large datasets. All diagnostics are</span>
<span class="sd">    computed simultaneously to maximize efficiency.</span>

<span class="sd">    Computed Diagnostics:</span>
<span class="sd">    - Monte Carlo standard errors (mean and sd methods)</span>
<span class="sd">    - Effective sample sizes (bulk and tail)</span>
<span class="sd">    - R-hat convergence diagnostic</span>

<span class="sd">    The Dask implementation enables:</span>
<span class="sd">    - Parallel computation across available cores</span>
<span class="sd">    - Memory-efficient processing of large datasets</span>
<span class="sd">    - Automatic load balancing and optimization</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; diagnostics = dask_enabled_diagnostics(inference_data)</span>
<span class="sd">        &gt;&gt;&gt; print(diagnostics.sel(metric=&#39;r_hat&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Run computations</span>
    <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">az_dask</span><span class="p">():</span>
        <span class="n">diagnostics</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
            <span class="n">az</span><span class="o">.</span><span class="n">mcse</span><span class="p">(</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">),</span>
            <span class="n">az</span><span class="o">.</span><span class="n">mcse</span><span class="p">(</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sd&quot;</span><span class="p">),</span>
            <span class="n">az</span><span class="o">.</span><span class="n">ess</span><span class="p">(</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bulk&quot;</span><span class="p">),</span>
            <span class="n">az</span><span class="o">.</span><span class="n">ess</span><span class="p">(</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tail&quot;</span><span class="p">),</span>
            <span class="n">az</span><span class="o">.</span><span class="n">rhat</span><span class="p">(</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1"># Concatenate the results and return</span>
    <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="p">[</span><span class="n">metric</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;mcse_mean&quot;</span><span class="p">,</span> <span class="s2">&quot;mcse_sd&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span> <span class="s2">&quot;r_hat&quot;</span><span class="p">],</span> <span class="n">diagnostics</span>
            <span class="p">)</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="SampleResults">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SampleResults</span><span class="p">(</span><span class="n">mle</span><span class="o">.</span><span class="n">MLEInferenceRes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Comprehensive analysis interface for HMC sampling results. This class should</span>
<span class="sd">    never be instantiated directly. Instead, use the `from_disk` method to load the</span>
<span class="sd">    appropriate results object from disk.</span>

<span class="sd">    This class extends MLEInferenceRes to provide specialized functionality</span>
<span class="sd">    for analyzing Hamiltonian Monte Carlo sampling results from Stan. It offers</span>
<span class="sd">    comprehensive diagnostic capabilities, interactive visualization tools,</span>
<span class="sd">    and efficient data management for large MCMC datasets.</span>

<span class="sd">    :param model: SciStanPy model used for sampling. Defaults to None.</span>
<span class="sd">    :type model: Optional[Model]</span>
<span class="sd">    :param fit: CmdStanMCMC object or path to CSV files. Defaults to None.</span>
<span class="sd">    :type fit: Optional[Union[str, list[str], os.PathLike, CmdStanMCMC]]</span>
<span class="sd">    :param data: Observed data dictionary. Defaults to None.</span>
<span class="sd">    :type data: Optional[dict[str, npt.NDArray]]</span>
<span class="sd">    :param precision: Numerical precision for arrays. Defaults to &quot;single&quot;.</span>
<span class="sd">    :type precision: Literal[&quot;double&quot;, &quot;single&quot;, &quot;half&quot;]</span>
<span class="sd">    :param inference_obj: Pre-existing InferenceData or NetCDF path. Defaults to None.</span>
<span class="sd">    :type inference_obj: Optional[Union[az.InferenceData, str]]</span>
<span class="sd">    :param mib_per_chunk: Memory limit per chunk in MiB. Defaults to None.</span>
<span class="sd">    :type mib_per_chunk: Optional[custom_types.Integer]</span>
<span class="sd">    :param use_dask: Whether to use Dask for computation. Defaults to False.</span>
<span class="sd">    :type use_dask: bool</span>

<span class="sd">    :ivar fit: CmdStanMCMC object containing sampling metadata</span>
<span class="sd">    :ivar use_dask: Flag controlling Dask usage for computation</span>

<span class="sd">    The class provides comprehensive functionality for:</span>
<span class="sd">    - MCMC convergence diagnostics and reporting</span>
<span class="sd">    - Sample quality assessment and visualization</span>
<span class="sd">    - Interactive analysis of problematic variables</span>
<span class="sd">    - Efficient handling of large datasets with Dask integration</span>
<span class="sd">    - Automated detection and reporting of sampling issues</span>

<span class="sd">    Key Diagnostic Features:</span>
<span class="sd">    - R-hat convergence assessment</span>
<span class="sd">    - Effective sample size evaluation</span>
<span class="sd">    - Energy-based diagnostics (E-BFMI)</span>
<span class="sd">    - Divergence detection and analysis</span>
<span class="sd">    - Tree depth saturation monitoring</span>

<span class="sd">    The class automatically handles NetCDF conversion for efficient storage</span>
<span class="sd">    and supports both in-memory and out-of-core computation depending on</span>
<span class="sd">    dataset size and available memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Model&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span> <span class="o">|</span> <span class="n">CmdStanMCMC</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;half&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
        <span class="n">inference_obj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">az</span><span class="o">.</span><span class="n">InferenceData</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mib_per_chunk</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_dask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Store the CmdStanMCMC object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="n">fit</span>

        <span class="c1"># Note whether we are using dask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dask</span> <span class="o">=</span> <span class="n">use_dask</span>

        <span class="c1"># If the inference object is None, we assume that we need to create a NETCDF</span>
        <span class="c1"># file from the CmdStanMCMC object.</span>
        <span class="k">if</span> <span class="n">inference_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Compile results to a NetCDF file</span>
            <span class="n">inference_obj</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">mib_per_chunk</span><span class="o">=</span><span class="n">mib_per_chunk</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># If the inference object is a string, we assume that it is a NetCDF file</span>
        <span class="c1"># to be loaded from disk</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inference_obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="c1"># Load the inference object. Ignore warnings about chunking.</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span>
                    <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="n">message</span><span class="o">=</span><span class="s2">&quot;The specified chunks separate the stored chunks along dimension&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">inference_obj</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">inference_obj</span><span class="p">,</span>
                    <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;h5netcdf&quot;</span><span class="p">,</span>
                    <span class="n">group_kwargs</span><span class="o">=</span><span class="p">{</span>
                        <span class="n">k</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;chunks&quot;</span><span class="p">:</span> <span class="s2">&quot;auto&quot;</span> <span class="k">if</span> <span class="n">use_dask</span> <span class="k">else</span> <span class="kc">None</span><span class="p">}</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;posterior&quot;</span><span class="p">,</span> <span class="s2">&quot;posterior_predictive&quot;</span><span class="p">,</span> <span class="s2">&quot;sample_stats&quot;</span><span class="p">)</span>
                    <span class="p">},</span>
                <span class="p">)</span>

        <span class="c1"># Initialize the parent class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inference_obj</span><span class="p">)</span>

<div class="viewcode-block" id="SampleResults.calculate_summaries">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.calculate_summaries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_summaries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_vars</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;like&quot;</span><span class="p">,</span> <span class="s2">&quot;regex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;stats&quot;</span><span class="p">,</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">round_to</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">circ_var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stat_focus</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">stat_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">callable</span><span class="p">],</span> <span class="nb">callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">hdi_prob</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="mf">0.94</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">diagnostic_varnames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;mcse_mean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mcse_sd&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span>
            <span class="s2">&quot;r_hat&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute comprehensive summary statistics and diagnostics for MCMC results.</span>

<span class="sd">        This method extends the parent class functionality to provide HMC-specific</span>
<span class="sd">        diagnostic capabilities, including automatic separation of statistics and</span>
<span class="sd">        diagnostics into appropriate InferenceData groups. See `az.summary` for</span>
<span class="sd">        more detail on arguments.</span>

<span class="sd">        :param var_names: Variable names to include. Defaults to None (all variables).</span>
<span class="sd">        :type var_names: Optional[list[str]]</span>
<span class="sd">        :param filter_vars: Variable filtering method. Defaults to None.</span>
<span class="sd">        :type filter_vars: Optional[Literal[None, &quot;like&quot;, &quot;regex&quot;]]</span>
<span class="sd">        :param kind: Type of computations to perform. Defaults to &quot;all&quot;.</span>
<span class="sd">        :type kind: Literal[&quot;all&quot;, &quot;stats&quot;, &quot;diagnostics&quot;]</span>
<span class="sd">        :param round_to: Decimal places for rounding. Defaults to 2.</span>
<span class="sd">        :type round_to: custom_types.Integer</span>
<span class="sd">        :param circ_var_names: Names of circular variables. Defaults to None.</span>
<span class="sd">        :type circ_var_names: Optional[list[str]]</span>
<span class="sd">        :param stat_focus: Primary statistic for focus. Defaults to &quot;mean&quot;.</span>
<span class="sd">        :type stat_focus: str</span>
<span class="sd">        :param stat_funcs: Custom statistic functions. Defaults to None.</span>
<span class="sd">        :type stat_funcs: Optional[Union[dict[str, callable], callable]]</span>
<span class="sd">        :param extend: Whether to include extended statistics. Defaults to True.</span>
<span class="sd">            Only meaningful if `stat_funcs` is not `None`.</span>
<span class="sd">        :type extend: bool</span>
<span class="sd">        :param hdi_prob: Probability for highest density interval. Defaults to 0.94.</span>
<span class="sd">        :type hdi_prob: custom_types.Float</span>
<span class="sd">        :param skipna: Whether to skip NaN values. Defaults to False.</span>
<span class="sd">        :type skipna: bool</span>
<span class="sd">        :param diagnostic_varnames: Names of diagnostic metrics. Defaults to (&quot;mcse_mean&quot;,</span>
<span class="sd">            &quot;mcse_sd&quot;, &quot;ess_bulk&quot;, &quot;ess_tail&quot;, &quot;r_hat&quot;).</span>
<span class="sd">        :type diagnostic_varnames: Sequence[str]</span>

<span class="sd">        :returns: Combined dataset with all computed metrics</span>
<span class="sd">        :rtype: xr.Dataset</span>

<span class="sd">        Enhanced Features:</span>
<span class="sd">        - Automatic Dask acceleration for large datasets</span>
<span class="sd">        - Separation of statistics and diagnostics into appropriate groups</span>
<span class="sd">        - Memory-efficient computation strategies</span>

<span class="sd">        The method automatically updates the InferenceData object with new groups:</span>
<span class="sd">        - variable_summary_stats: Basic summary statistics</span>
<span class="sd">        - variable_diagnostic_stats: MCMC diagnostic metrics</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We use custom functions if we are using dask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dask</span><span class="p">:</span>

            <span class="c1"># Calculate the two datasets</span>
            <span class="n">summary_stats</span> <span class="o">=</span> <span class="n">dask_enabled_summary_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>
            <span class="n">diagnostics</span> <span class="o">=</span> <span class="n">dask_enabled_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>

            <span class="c1"># Combine datasets to get the summaries</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">summaries</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">summary_stats</span><span class="p">,</span> <span class="n">diagnostics</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;stats&quot;</span><span class="p">:</span>
                <span class="n">summaries</span> <span class="o">=</span> <span class="n">summary_stats</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">:</span>
                <span class="n">summaries</span> <span class="o">=</span> <span class="n">diagnostics</span>

        <span class="c1"># Otherwise, we use the default ArviZ functions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Run the inherited method to get the summary statistics</span>
            <span class="n">summaries</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">calculate_summaries</span><span class="p">(</span>
                <span class="n">var_names</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span>
                <span class="n">filter_vars</span><span class="o">=</span><span class="n">filter_vars</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                <span class="n">round_to</span><span class="o">=</span><span class="n">round_to</span><span class="p">,</span>
                <span class="n">circ_var_names</span><span class="o">=</span><span class="n">circ_var_names</span><span class="p">,</span>
                <span class="n">stat_focus</span><span class="o">=</span><span class="n">stat_focus</span><span class="p">,</span>
                <span class="n">stat_funcs</span><span class="o">=</span><span class="n">stat_funcs</span><span class="p">,</span>
                <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">,</span>
                <span class="n">hdi_prob</span><span class="o">=</span><span class="n">hdi_prob</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Identify the diagnostic and summary statistics</span>
            <span class="n">noted_diagnostics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">diagnostic_varnames</span><span class="p">)</span>
            <span class="n">calculated_metrics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">summaries</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="n">diagnostic_metrics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">noted_diagnostics</span> <span class="o">&amp;</span> <span class="n">calculated_metrics</span><span class="p">)</span>
            <span class="n">stat_metrics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">calculated_metrics</span> <span class="o">-</span> <span class="n">noted_diagnostics</span><span class="p">)</span>

            <span class="n">summary_stats</span> <span class="o">=</span> <span class="n">summaries</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">stat_metrics</span><span class="p">)</span>
            <span class="n">diagnostics</span> <span class="o">=</span> <span class="n">summaries</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">diagnostic_metrics</span><span class="p">)</span>

        <span class="c1"># Update the groups</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_group</span><span class="p">(</span><span class="s2">&quot;variable_diagnostic_stats&quot;</span><span class="p">,</span> <span class="n">diagnostics</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;stats&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_group</span><span class="p">(</span><span class="s2">&quot;variable_summary_stats&quot;</span><span class="p">,</span> <span class="n">summary_stats</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summaries</span></div>


<div class="viewcode-block" id="SampleResults.calculate_diagnostics">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.calculate_diagnostics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute MCMC diagnostics with side effects and reporting.</span>

<span class="sd">        :returns: Dataset containing diagnostic metrics</span>
<span class="sd">        :rtype: xr.Dataset</span>

<span class="sd">        This convenience method computes only diagnostic metrics by calling</span>
<span class="sd">        calculate_summaries with kind=&quot;diagnostics&quot;. It preserves all side</span>
<span class="sd">        effects including updating the InferenceData object groups.</span>

<span class="sd">        The method is designed as a simple interface for users who only need</span>
<span class="sd">        diagnostic information without summary statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_summaries</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;diagnostics&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleResults.evaluate_sample_stats">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.evaluate_sample_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_sample_stats</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_tree_depth</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ebfmi_thresh</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="n">DEFAULT_EBFMI_THRESH</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate sample-level diagnostic statistics for MCMC quality assessment.</span>

<span class="sd">        :param max_tree_depth: Maximum tree depth threshold. Uses model default if None.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :type max_tree_depth: Optional[custom_types.Integer]</span>
<span class="sd">        :param ebfmi_thresh: E-BFMI threshold for energy diagnostics. Defaults to 0.2.</span>
<span class="sd">        :type ebfmi_thresh: custom_types.Float</span>

<span class="sd">        :returns: Dataset with boolean arrays indicating test failures</span>
<span class="sd">        :rtype: xr.Dataset</span>

<span class="sd">        This method evaluates sample-level diagnostic statistics to identify</span>
<span class="sd">        problematic samples in the MCMC chains. Tests are considered failures</span>
<span class="sd">        when samples exhibit the following characteristics:</span>

<span class="sd">        Failure Conditions:</span>
<span class="sd">        - **Tree Depth**: Sample reached maximum tree depth (saturation)</span>
<span class="sd">        - **E-BFMI**: Energy-based fraction of missing information below threshold</span>
<span class="sd">        - **Divergence**: Sample diverged during Hamiltonian dynamics</span>

<span class="sd">        The resulting boolean arrays have True values indicating failed samples</span>
<span class="sd">        and False values indicating successful samples. This information is</span>
<span class="sd">        stored in the &#39;sample_diagnostic_tests&#39; group of the InferenceData object.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; sample_tests = results.evaluate_sample_stats(ebfmi_thresh=0.15)</span>
<span class="sd">            &gt;&gt;&gt; n_diverged = sample_tests.diverged.sum().item()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Number of divergent samples: {n_diverged}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If not provided, extract the maximum tree depth from the attributes</span>
        <span class="k">if</span> <span class="n">max_tree_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_tree_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;max_depth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Run all tests and build a dataset</span>
        <span class="n">sample_tests</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;low_ebfmi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_stats</span><span class="o">.</span><span class="n">energy__</span> <span class="o">&lt;</span> <span class="n">ebfmi_thresh</span><span class="p">,</span>
                <span class="s2">&quot;max_tree_depth_reached&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_stats</span><span class="o">.</span><span class="n">treedepth__</span>
                <span class="o">==</span> <span class="n">max_tree_depth</span><span class="p">,</span>
                <span class="s2">&quot;diverged&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_stats</span><span class="o">.</span><span class="n">divergent__</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># pylint: enable=no-member</span>

        <span class="c1"># Add the new group to the ArviZ object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_group</span><span class="p">(</span><span class="s2">&quot;sample_diagnostic_tests&quot;</span><span class="p">,</span> <span class="n">sample_tests</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sample_tests</span></div>


<div class="viewcode-block" id="SampleResults.evaluate_variable_diagnostic_stats">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.evaluate_variable_diagnostic_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_variable_diagnostic_stats</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">r_hat_thresh</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="n">DEFAULT_RHAT_THRESH</span><span class="p">,</span>
        <span class="n">ess_thresh</span><span class="o">=</span><span class="n">DEFAULT_ESS_THRESH</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate variable-level diagnostic statistics for convergence assessment.</span>

<span class="sd">        :param r_hat_thresh: R-hat threshold for convergence. Defaults to 1.01.</span>
<span class="sd">        :type r_hat_thresh: custom_types.Float</span>
<span class="sd">        :param ess_thresh: ESS threshold per chain. Defaults to 100.</span>
<span class="sd">        :type ess_thresh: custom_types.Integer</span>

<span class="sd">        :returns: Dataset with boolean arrays indicating variable-level test failures</span>
<span class="sd">        :rtype: xr.Dataset</span>

<span class="sd">        :raises ValueError: If variable_diagnostic_stats group doesn&#39;t exist</span>
<span class="sd">        :raises ValueError: If required metrics are missing</span>

<span class="sd">        This method evaluates variable-level diagnostic statistics to identify</span>
<span class="sd">        parameters that exhibit poor sampling behavior. Tests are considered</span>
<span class="sd">        failures when variables meet the following criteria:</span>

<span class="sd">        Failure Conditions:</span>
<span class="sd">        - **R-hat**: Split R-hat statistic &gt;= threshold (poor convergence)</span>
<span class="sd">        - **ESS Bulk**: Bulk effective sample size / n_chains &lt;= threshold per chain</span>
<span class="sd">        - **ESS Tail**: Tail effective sample size / n_chains &lt;= threshold per chain</span>

<span class="sd">        Results are stored in the &#39;variable_diagnostic_tests&#39; group with boolean</span>
<span class="sd">        arrays indicating which variables failed which tests.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; var_tests = results.evaluate_variable_diagnostic_stats(r_hat_thresh=1.02)</span>
<span class="sd">            &gt;&gt;&gt; failed_convergence = var_tests.sel(metric=&#39;r_hat&#39;).sum()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Variables with poor convergence: {failed_convergence.sum().item()}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to check if the `variable_diagnostic_stats` group exists. If it doesn&#39;t,</span>
        <span class="c1"># we need to run `calculate_diagnostics` first.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">,</span> <span class="s2">&quot;variable_diagnostic_stats&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The `variable_diagnostic_stats` group does not exist. Please run &quot;</span>
                <span class="s2">&quot;`calculate_diagnostics` first.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># All metrics should be present in the `variable_diagnostic_stats` group.</span>
        <span class="c1"># pylint: disable=no-member</span>
        <span class="k">if</span> <span class="n">missing_metrics</span> <span class="o">:=</span> <span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;r_hat&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_tail&quot;</span><span class="p">}</span>
            <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_stats</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The following metrics are missing from the `variable_diagnostic_stats` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;group: </span><span class="si">{</span><span class="n">missing_metrics</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Update the ess threshold based on the number of chains</span>
        <span class="n">ess_thresh</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]</span>

        <span class="c1"># Run all tests and build a dataset</span>
        <span class="n">variable_tests</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_stats</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;r_hat&quot;</span><span class="p">)</span>
                <span class="o">&gt;=</span> <span class="n">r_hat_thresh</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_stats</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;ess_bulk&quot;</span><span class="p">)</span>
                <span class="o">&lt;=</span> <span class="n">ess_thresh</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_stats</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;ess_tail&quot;</span><span class="p">)</span>
                <span class="o">&lt;=</span> <span class="n">ess_thresh</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># pylint: enable=no-member</span>

        <span class="c1"># Add the new group to the ArviZ object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_group</span><span class="p">(</span><span class="s2">&quot;variable_diagnostic_tests&quot;</span><span class="p">,</span> <span class="n">variable_tests</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">variable_tests</span></div>


<div class="viewcode-block" id="SampleResults.identify_failed_diagnostics">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.identify_failed_diagnostics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">identify_failed_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="s2">&quot;custom_types.StrippedTestRes&quot;</span><span class="p">,</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;custom_types.StrippedTestRes&quot;</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify and report diagnostic test failures with comprehensive summary.</span>

<span class="sd">        :param silent: Whether to suppress printed output. Defaults to False.</span>
<span class="sd">        :type silent: bool</span>

<span class="sd">        :returns: Tuple of (sample_failures, variable_failures) dictionaries</span>
<span class="sd">        :rtype: tuple[custom_types.StrippedTestRes, dict[str, custom_types.StrippedTestRes]]</span>

<span class="sd">        This method analyzes the results of diagnostic tests and provides both</span>
<span class="sd">        programmatic access to failure information and human-readable summaries.</span>
<span class="sd">        It requires that diagnostic evaluation methods have been run previously.</span>

<span class="sd">        Return Structure:</span>
<span class="sd">        - **sample_failures**: Dictionary mapping test names to arrays of failed sample indices</span>
<span class="sd">        - **variable_failures**: Dictionary mapping metric names to dictionaries of failed variables</span>

<span class="sd">        The method processes test results to extract:</span>
<span class="sd">        - Indices of samples that failed each diagnostic test</span>
<span class="sd">        - Names of variables that failed each diagnostic metric</span>
<span class="sd">        - Summary statistics showing failure rates and percentages</span>

<span class="sd">        When not silent, provides detailed reporting including:</span>
<span class="sd">        - Failure counts and percentages for each test type</span>
<span class="sd">        - Variable-specific failure information organized by metric</span>
<span class="sd">        - Clear categorization of sample vs. variable-level issues</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; sample_fails, var_fails = results.identify_failed_diagnostics()</span>
<span class="sd">            &gt;&gt;&gt; # Check divergence issues</span>
<span class="sd">            &gt;&gt;&gt; diverged_samples = sample_fails[&#39;diverged&#39;]</span>
<span class="sd">            &gt;&gt;&gt; # Check convergence issues</span>
<span class="sd">            &gt;&gt;&gt; poor_rhat_vars = var_fails[&#39;r_hat&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process_test_results</span><span class="p">(</span>
            <span class="n">test_res_dataarray</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.ProcessedTestRes&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Process the test results from a DataArray into a dictionary of test results.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            test_res_dataarray : xr.Dataset</span>
<span class="sd">                The DataArray containing the test results.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            custom_types.ProcessedTestRes</span>
<span class="sd">                A dictionary where the keys are the variable names and the values are tuples</span>
<span class="sd">                containing the indices of the failed tests and the total number of tests.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">varname</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tests</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(),</span> <span class="n">tests</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">tests</span> <span class="ow">in</span> <span class="n">test_res_dataarray</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">strip_totals</span><span class="p">(</span>
            <span class="n">processed_test_results</span><span class="p">:</span> <span class="s2">&quot;custom_types.ProcessedTestRes&quot;</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;custom_types.StrippedTestRes&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Strip the totals from the test results.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            processed_test_results : custom_types.ProcessedTestRes</span>
<span class="sd">                The processed test results from the `process_test_results` function.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            custom_types.StrippedTestRes</span>
<span class="sd">                The processed test results with the totals stripped.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">processed_test_results</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">report_test_summary</span><span class="p">(</span>
            <span class="n">processed_test_results</span><span class="p">:</span> <span class="s2">&quot;custom_types.ProcessedTestRes&quot;</span><span class="p">,</span>
            <span class="n">type_</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">prepend_newline</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Report the summary of the test results.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            processed_test_results : dict[str, tuple[tuple[npt.NDArray, ...], int]]</span>
<span class="sd">                The processed test results from the `process_test_results` function.</span>
<span class="sd">            type_ : str</span>
<span class="sd">                The type of test results (e.g., &quot;sample&quot;, &quot;variable&quot;).</span>
<span class="sd">            prepend_newline : bool, optional</span>
<span class="sd">                Whether to prepend a newline before the summary, by default True.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">prepend_newline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
            <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2"> diagnostic tests results&#39; summaries:&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="p">(</span>
                <span class="n">failed_indices</span><span class="p">,</span>
                <span class="n">total_tests</span><span class="p">,</span>
            <span class="p">)</span> <span class="ow">in</span> <span class="n">processed_test_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">n_failures</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n_failures</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="k">for</span> <span class="n">failed</span> <span class="ow">in</span> <span class="n">failed_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_failures</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">total_tests</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_failures</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">total_tests</span><span class="si">:</span><span class="s2">.2%</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">type_</span><span class="si">}</span><span class="s2">s &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">message_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span><span class="w"> </span><span class="sa">f</span><span class="s1">&#39;tests failed for </span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Different messages for different test types</span>
        <span class="n">message_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;low_ebfmi&quot;</span><span class="p">:</span> <span class="s2">&quot;had a low energy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;max_tree_depth_reached&quot;</span><span class="p">:</span> <span class="s2">&quot;reached the maximum tree depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;diverged&quot;</span><span class="p">:</span> <span class="s2">&quot;diverged&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Get the indices of the sampling tests that failed and the total number of tests</span>
        <span class="c1"># performed</span>
        <span class="c1"># pylint: disable=no-member</span>
        <span class="n">sample_test_failures</span> <span class="o">=</span> <span class="n">process_test_results</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_diagnostic_tests</span>
        <span class="p">)</span>

        <span class="c1"># Get the indices of the variable diagnostic tests that failed and the total number</span>
        <span class="c1"># of tests performed</span>
        <span class="n">variable_test_failures</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">metric</span><span class="o">.</span><span class="n">item</span><span class="p">():</span> <span class="n">process_test_results</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_tests</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">variable_diagnostic_tests</span><span class="o">.</span><span class="n">metric</span>
        <span class="p">}</span>
        <span class="c1"># pylint: enable=no-member</span>

        <span class="c1"># Strip the totals from the test results and package as return values</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">strip_totals</span><span class="p">(</span><span class="n">sample_test_failures</span><span class="p">),</span>
            <span class="p">{</span>
                <span class="n">metric</span><span class="p">:</span> <span class="n">strip_totals</span><span class="p">(</span><span class="n">failures</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">failures</span> <span class="ow">in</span> <span class="n">variable_test_failures</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># If silent, return the test results now</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># Report sample test failures</span>
        <span class="n">report_test_summary</span><span class="p">(</span><span class="n">sample_test_failures</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="n">prepend_newline</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Report variable test failures</span>
        <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">failures</span> <span class="ow">in</span> <span class="n">variable_test_failures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">report_test_summary</span><span class="p">(</span><span class="n">failures</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleResults.diagnose">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.diagnose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">diagnose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_tree_depth</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ebfmi_thresh</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="n">DEFAULT_EBFMI_THRESH</span><span class="p">,</span>
        <span class="n">r_hat_thresh</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="n">DEFAULT_RHAT_THRESH</span><span class="p">,</span>
        <span class="n">ess_thresh</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Float</span> <span class="o">=</span> <span class="n">DEFAULT_ESS_THRESH</span><span class="p">,</span>
        <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="s2">&quot;custom_types.StrippedTestRes&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;custom_types.StrippedTestRes&quot;</span><span class="p">]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute complete MCMC diagnostic pipeline with comprehensive reporting.</span>

<span class="sd">        :param max_tree_depth: Maximum tree depth threshold. Uses model default if None.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :type max_tree_depth: Optional[custom_types.Integer]</span>
<span class="sd">        :param ebfmi_thresh: E-BFMI threshold for energy diagnostics. Defaults to 0.2.</span>
<span class="sd">        :type ebfmi_thresh: custom_types.Float</span>
<span class="sd">        :param r_hat_thresh: R-hat threshold for convergence assessment. Defaults to 1.01.</span>
<span class="sd">        :type r_hat_thresh: custom_types.Float</span>
<span class="sd">        :param ess_thresh: ESS threshold per chain. Defaults to 100.</span>
<span class="sd">        :type ess_thresh: custom_types.Float</span>
<span class="sd">        :param silent: Whether to suppress diagnostic output. Defaults to False.</span>
<span class="sd">        :type silent: bool</span>

<span class="sd">        :returns: Tuple of (sample_failures, variable_failures) as returned by</span>
<span class="sd">            identify_failed_diagnostics</span>
<span class="sd">        :rtype: tuple[custom_types.StrippedTestRes, dict[str, custom_types.StrippedTestRes]]</span>

<span class="sd">        This method provides a complete, one-stop diagnostic analysis by executing</span>
<span class="sd">        the full diagnostic pipeline in the correct order:</span>

<span class="sd">        Pipeline Steps:</span>
<span class="sd">        1. **calculate_diagnostics**: Compute all diagnostic metrics</span>
<span class="sd">        2. **evaluate_sample_stats**: Assess sample-level diagnostic failures</span>
<span class="sd">        3. **evaluate_variable_diagnostic_stats**: Assess variable-level failures</span>
<span class="sd">        4. **identify_failed_diagnostics**: Summarize and report all failures</span>

<span class="sd">        The method provides comprehensive assessment of MCMC sampling quality,</span>
<span class="sd">        identifying both immediate issues (divergences, energy problems) and</span>
<span class="sd">        convergence concerns (R-hat, effective sample size).</span>

<span class="sd">        All intermediate results are stored in the InferenceData object for</span>
<span class="sd">        later access and further analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Run the diagnostics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_diagnostics</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_sample_stats</span><span class="p">(</span>
            <span class="n">max_tree_depth</span><span class="o">=</span><span class="n">max_tree_depth</span><span class="p">,</span> <span class="n">ebfmi_thresh</span><span class="o">=</span><span class="n">ebfmi_thresh</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_variable_diagnostic_stats</span><span class="p">(</span>
            <span class="n">r_hat_thresh</span><span class="o">=</span><span class="n">r_hat_thresh</span><span class="p">,</span> <span class="n">ess_thresh</span><span class="o">=</span><span class="n">ess_thresh</span>
        <span class="p">)</span>

        <span class="c1"># Identify the failed diagnostics</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_failed_diagnostics</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">)</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_sample_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">display</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hv</span><span class="o">.</span><span class="n">HoloMap</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_sample_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">display</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hv</span><span class="o">.</span><span class="n">Overlay</span><span class="p">]:</span> <span class="o">...</span>

<div class="viewcode-block" id="SampleResults.plot_sample_failure_quantile_traces">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.plot_sample_failure_quantile_traces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_sample_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visualize quantile traces for samples that failed diagnostic tests.</span>

<span class="sd">        :param display: Whether to return formatted layout for display. Defaults to True.</span>
<span class="sd">        :type display: bool</span>
<span class="sd">        :param width: Width of plots in pixels. Defaults to 600.</span>
<span class="sd">        :type width: custom_types.Integer</span>
<span class="sd">        :param height: Height of plots in pixels. Defaults to 600.</span>
<span class="sd">        :type height: custom_types.Integer</span>

<span class="sd">        :returns: Quantile trace plots in requested format</span>
<span class="sd">        :rtype: Union[hv.HoloMap, dict[str, hv.Overlay]]</span>

<span class="sd">        :raises ValueError: If no samples failed diagnostic tests</span>

<span class="sd">        This method creates specialized trace plots showing how samples that</span>
<span class="sd">        failed diagnostic tests compare to those that passed. The visualization</span>
<span class="sd">        helps identify systematic patterns in sampling failures.</span>

<span class="sd">        Plot Structure:</span>

<span class="sd">        - **X-axis**: Cumulative fraction of parameters (0 to 1, sorted by typical quantile</span>
<span class="sd">            of failed samples)</span>
<span class="sd">        - **Y-axis**: Quantiles of failed samples relative to passing samples</span>
<span class="sd">        - **Individual traces**: Semi-transparent lines for each failed sample</span>
<span class="sd">        - **Typical trace**: Bold line showing median behavior across failures</span>
<span class="sd">        - **Reference line**: Diagonal indicating perfect calibration</span>

<span class="sd">        The plots reveal:</span>

<span class="sd">        - Whether failures are systematic across parameters</span>
<span class="sd">        - Patterns in how failed samples deviate from typical behavior</span>
<span class="sd">        - The severity and consistency of sampling problems</span>

<span class="sd">        Parameters are sorted by their typical failed quantiles to highlight</span>
<span class="sd">        systematic patterns, with x-axis labels hidden since absolute parameter</span>
<span class="sd">        identity is less important than relative patterns.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Display interactive traces</span>
<span class="sd">            &gt;&gt;&gt; results.plot_sample_failure_quantile_traces()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Access individual diagnostic plots</span>
<span class="sd">            &gt;&gt;&gt; traces = results.plot_sample_failure_quantile_traces(display=False)</span>
<span class="sd">            &gt;&gt;&gt; diverged_plot = traces[&#39;diverged&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># x-axis labels are meaningless, so we will use a hook to hide them</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">hook</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
            <span class="n">plot</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_tick_line_color</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">plot</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">minor_tick_line_color</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">plot</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_label_text_font_size</span> <span class="o">=</span> <span class="s2">&quot;0pt&quot;</span>

        <span class="c1"># If there are no failed samples, raise an error</span>
        <span class="c1"># pylint: disable=no-member</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_diagnostic_tests</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">any</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No samples failed the diagnostic tests. This error is a good thing!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># First, we need to get all samples and the diagnostic tests. We will reshape</span>
        <span class="c1"># both to be 2D, with the first dimension being the samples and the second</span>
        <span class="c1"># dimension being the parameter values or the test results, respectively.</span>
        <span class="n">sample_arr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">to_stacked_array</span><span class="p">(</span>
                <span class="n">new_dim</span><span class="o">=</span><span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="n">sample_dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">],</span> <span class="n">variable_dim</span><span class="o">=</span><span class="s2">&quot;parameter&quot;</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>
        <span class="n">sample_test_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_obj</span><span class="o">.</span><span class="n">sample_diagnostic_tests</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># pylint: enable=no-member</span>

        <span class="c1"># Now we need some metadata about the samples, such as the chain and draw</span>
        <span class="c1"># indices and the parameter names</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name_tuple</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">))])</span>
                <span class="k">for</span> <span class="n">name_tuple</span> <span class="ow">in</span> <span class="n">sample_arr</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="n">sample_arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">draws</span> <span class="o">=</span> <span class="n">sample_arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;draw&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># We will need the sample array as a numpy array from here</span>
        <span class="n">sample_arr</span> <span class="o">=</span> <span class="n">sample_arr</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># x-values are just incrementally increasing from 0 to 1 for the number of</span>
        <span class="c1"># parameters</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sample_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Now we process each of the diagnostic tests</span>
        <span class="n">plots</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">testname</span><span class="p">,</span> <span class="n">testmask</span> <span class="ow">in</span> <span class="n">sample_test_arr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Get the failed samples. If there are no failed samples, skip this</span>
            <span class="c1"># test</span>
            <span class="n">testmask</span> <span class="o">=</span> <span class="n">testmask</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">testmask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">failed_samples</span><span class="p">,</span> <span class="n">failed_chains</span><span class="p">,</span> <span class="n">failed_draws</span><span class="p">,</span> <span class="n">passed_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sample_arr</span><span class="p">[</span><span class="n">testmask</span><span class="p">],</span>
                <span class="n">chains</span><span class="p">[</span><span class="n">testmask</span><span class="p">],</span>
                <span class="n">draws</span><span class="p">[</span><span class="n">testmask</span><span class="p">],</span>
                <span class="n">sample_arr</span><span class="p">[</span><span class="o">~</span><span class="n">testmask</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Get the quantiles of the  failed samples relative to the passed ones</span>
            <span class="n">failed_quantiles</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">calculate_relative_quantiles</span><span class="p">(</span>
                <span class="n">passed_samples</span><span class="p">,</span> <span class="n">failed_samples</span>
            <span class="p">)</span>

            <span class="c1"># Get the typical quantiles of the failed samples</span>
            <span class="n">typical_failed_quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">failed_quantiles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Sort samples by the values of the typical failed samples</span>
            <span class="n">sorted_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">typical_failed_quantiles</span><span class="p">)</span>
            <span class="p">(</span>
                <span class="n">failed_samples</span><span class="p">,</span>
                <span class="n">failed_quantiles</span><span class="p">,</span>
                <span class="n">typical_failed_quantiles</span><span class="p">,</span>
                <span class="n">resorted_varnames</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">failed_samples</span><span class="p">[:,</span> <span class="n">sorted_inds</span><span class="p">],</span>
                <span class="n">failed_quantiles</span><span class="p">[:,</span> <span class="n">sorted_inds</span><span class="p">],</span>
                <span class="n">typical_failed_quantiles</span><span class="p">[</span><span class="n">sorted_inds</span><span class="p">],</span>
                <span class="n">varnames</span><span class="p">[</span><span class="n">sorted_inds</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Build the traces</span>
            <span class="n">plots</span><span class="p">[</span><span class="n">testname</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">Overlay</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">hv</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">x</span><span class="p">,</span>
                            <span class="n">quantile</span><span class="p">,</span>
                            <span class="n">resorted_varnames</span><span class="p">,</span>
                            <span class="n">failed_chains</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">failed_draws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">failed_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="p">),</span>
                        <span class="n">kdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Fraction of Parameters&quot;</span><span class="p">],</span>
                        <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Quantile&quot;</span><span class="p">,</span> <span class="s2">&quot;Parameter&quot;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">,</span> <span class="s2">&quot;Draw&quot;</span><span class="p">,</span> <span class="s2">&quot;Value&quot;</span><span class="p">],</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">line_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">line_alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;hover&quot;</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">failed_quantiles</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="o">+</span> <span class="p">[</span>
                    <span class="n">hv</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">typical_failed_quantiles</span><span class="p">),</span>
                        <span class="n">kdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Fraction of Parameters&quot;</span><span class="p">],</span>
                        <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Quantile&quot;</span><span class="p">],</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Typical Failed Quantiles&quot;</span><span class="p">,</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">line_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">hv</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span>
                        <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                        <span class="n">kdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Fraction of Parameters&quot;</span><span class="p">],</span>
                        <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Quantile&quot;</span><span class="p">],</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Idealized Quantiles&quot;</span><span class="p">,</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">line_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
                <span class="n">hooks</span><span class="o">=</span><span class="p">[</span><span class="n">hook</span><span class="p">],</span>
                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Quantiles of Samples Failing: </span><span class="si">{</span><span class="n">testname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># If requested, display the plots</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hv</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">plots</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">cols</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">shared_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plots</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_variable_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">display</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">plot_quantiles</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VariableAnalyzer</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_variable_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">display</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">custom_types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span>
        <span class="n">plot_quantiles</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pn</span><span class="o">.</span><span class="n">pane</span><span class="o">.</span><span class="n">HoloViews</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="SampleResults.plot_variable_failure_quantile_traces">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.plot_variable_failure_quantile_traces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_variable_failure_quantile_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="n">plot_quantiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create interactive analyzer for variables that failed diagnostic tests.</span>

<span class="sd">        :param display: Whether to return display-ready analyzer. Defaults to True.</span>
<span class="sd">        :type display: bool</span>
<span class="sd">        :param width: Width of plots in pixels. Defaults to 800.</span>
<span class="sd">        :type width: custom_types.Integer</span>
<span class="sd">        :param height: Height of plots in pixels. Defaults to 400.</span>
<span class="sd">        :type height: custom_types.Integer</span>
<span class="sd">        :param plot_quantiles: Whether to plot quantiles vs raw values. Defaults to False.</span>
<span class="sd">        :type plot_quantiles: bool</span>

<span class="sd">        :returns: Interactive analyzer or Panel layout</span>
<span class="sd">        :rtype: Union[VariableAnalyzer, pn.pane.HoloViews]</span>

<span class="sd">        This method creates an interactive analysis tool for examining individual</span>
<span class="sd">        variables that failed diagnostic tests. The analyzer provides widgets for</span>
<span class="sd">        selecting specific variables, diagnostic metrics, and array indices.</span>

<span class="sd">        Interactive Features:</span>
<span class="sd">        - **Variable Selection**: Choose from variables that failed any test</span>
<span class="sd">        - **Metric Selection**: Focus on specific diagnostic failures</span>
<span class="sd">        - **Index Selection**: Examine individual array elements for multi-dimensional parameters</span>

<span class="sd">        The resulting trace plots show:</span>
<span class="sd">        - Sample trajectories across MCMC chains with distinct colors</span>
<span class="sd">        - Quantile analysis relative to parameters that passed tests</span>
<span class="sd">        - Hover information with detailed sample metadata</span>
<span class="sd">        - Chain-specific behavior identification</span>

<span class="sd">        This tool is particularly valuable for:</span>
<span class="sd">        - Understanding the nature of convergence problems</span>
<span class="sd">        - Identifying problematic parameter regions</span>
<span class="sd">        - Diagnosing systematic vs. sporadic sampling issues</span>
<span class="sd">        - Planning model reparameterization strategies</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Interactive analysis in notebook</span>
<span class="sd">            &gt;&gt;&gt; analyzer = results.plot_variable_failure_quantile_traces()</span>
<span class="sd">            &gt;&gt;&gt; analyzer  # Display widget interface</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Programmatic access to analyzer</span>
<span class="sd">            &gt;&gt;&gt; analyzer_obj = results.plot_variable_failure_quantile_traces(display=False)</span>
<span class="sd">            &gt;&gt;&gt; # Access underlying data and interface components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build the analyzer object</span>
        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">VariableAnalyzer</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">plot_width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">plot_quantiles</span><span class="o">=</span><span class="n">plot_quantiles</span>
        <span class="p">)</span>

        <span class="c1"># Return the analyzer object if not displaying</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">display</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">analyzer</span>

        <span class="c1"># Otherwise, display the plots</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">display</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleResults.from_disk">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.SampleResults.from_disk">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_disk</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">csv_files</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_fit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_dask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SampleResults&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load SampleResults from saved NetCDF file with optional CSV metadata.</span>

<span class="sd">        :param path: Path to NetCDF file containing inference data</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :param csv_files: Paths to original CSV files or pattern. Defaults to None (auto-detect).</span>
<span class="sd">        :type csv_files: Optional[Union[list[str], str]]</span>
<span class="sd">        :param skip_fit: Whether to skip loading CSV metadata. Defaults to False.</span>
<span class="sd">        :type skip_fit: bool</span>
<span class="sd">        :param use_dask: Whether to enable Dask for computation. Defaults to False.</span>
<span class="sd">        :type use_dask: bool</span>

<span class="sd">        :returns: Loaded SampleResults object ready for analysis</span>
<span class="sd">        :rtype: SampleResults</span>

<span class="sd">        :raises FileNotFoundError: If the specified NetCDF file doesn&#39;t exist</span>

<span class="sd">        This class method enables loading of previously saved MCMC results from</span>
<span class="sd">        NetCDF format, with optional access to original CSV metadata for complete</span>
<span class="sd">        functionality.</span>

<span class="sd">        Loading Modes:</span>
<span class="sd">        - **Full loading**: NetCDF + CSV metadata (complete functionality)</span>
<span class="sd">        - **NetCDF only**: Fast loading without CSV metadata (limited functionality)</span>
<span class="sd">        - **Auto-detection**: Automatically finds CSV files based on NetCDF path</span>

<span class="sd">        The method supports flexible CSV file specification:</span>
<span class="sd">        - Explicit list of CSV file paths</span>
<span class="sd">        - Glob pattern for automatic discovery</span>
<span class="sd">        - Auto-detection based on NetCDF filename conventions</span>

<span class="sd">        When use_dask=True, the loaded data supports out-of-core computation</span>
<span class="sd">        for memory-efficient analysis of large datasets.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Load with auto-detected CSV files</span>
<span class="sd">            &gt;&gt;&gt; results = SampleResults.from_disk(&#39;model_results.nc&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Load with explicit CSV files</span>
<span class="sd">            &gt;&gt;&gt; results = SampleResults.from_disk(</span>
<span class="sd">            ...     &#39;results.nc&#39;, csv_files=[&#39;chain_1.csv&#39;, &#39;chain_2.csv&#39;]</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Fast loading without CSV metadata</span>
<span class="sd">            &gt;&gt;&gt; results = SampleResults.from_disk(&#39;results.nc&#39;, skip_fit=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The path to the netcdf file must exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> does not exist. Please provide a valid path.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If csv files are not provided and we are not skipping the fit, we need</span>
        <span class="c1"># to get them from the netcdf file</span>
        <span class="k">if</span> <span class="n">skip_fit</span><span class="p">:</span>
            <span class="n">csv_files</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">csv_files</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the path to the netcdf file does not end with &quot;.nc&quot;, raise a warning</span>
            <span class="c1"># that we cannot automatically find the csv files. If it does, find</span>
            <span class="c1"># the csv files</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
                <span class="n">csv_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;*.csv&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Could not identify csv files automatically. Loading without.&quot;</span>
                    <span class="s2">&quot;To be auto-detected, csv files must be named according to the&quot;</span>
                    <span class="s2">&quot;following pattern: &lt;extensionless_netcdf_filename&gt;*.csv&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Initialize the object</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fit</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">csv_files</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fit_from_csv_noload</span><span class="p">(</span><span class="n">csv_files</span><span class="p">),</span>
            <span class="n">inference_obj</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">use_dask</span><span class="o">=</span><span class="n">use_dask</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="fit_from_csv_noload">
<a class="viewcode-back" href="../../../../api/model/results/hmc.html#scistanpy.model.results.hmc.fit_from_csv_noload">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_from_csv_noload</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CmdStanMCMC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create CmdStanMCMC object from CSV files without loading data into memory.</span>
<span class="sd">    This function is adapted from `cmdstanpy.from_csv`.</span>

<span class="sd">    :param path: Path specification for CSV files (single file, list, or glob pattern)</span>
<span class="sd">    :type path: Union[str, list[str], os.PathLike]</span>

<span class="sd">    :returns: CmdStanMCMC object with metadata but no loaded sample data</span>
<span class="sd">    :rtype: CmdStanMCMC</span>

<span class="sd">    :raises ValueError: If path specification is invalid or no CSV files found</span>
<span class="sd">    :raises ValueError: If CSV files are not valid Stan output</span>

<span class="sd">    This function provides a memory-efficient way to create CmdStanMCMC objects</span>
<span class="sd">    by parsing only the metadata from CSV files without loading the actual</span>
<span class="sd">    sample data. This is particularly useful for large datasets where memory</span>
<span class="sd">    usage is a concern.</span>

<span class="sd">    Path Specifications:</span>
<span class="sd">    - **Single file**: Direct path to one CSV file</span>
<span class="sd">    - **File list**: List of paths to multiple CSV files</span>
<span class="sd">    - **Glob pattern**: Wildcard pattern for automatic file discovery</span>
<span class="sd">    - **Directory**: Directory containing CSV files (loads all .csv files)</span>

<span class="sd">    The function performs validation to ensure:</span>
<span class="sd">    - All specified files exist and are readable</span>
<span class="sd">    - Files contain valid Stan CSV output</span>
<span class="sd">    - Sampling method is compatible (only &#39;sample&#39; method supported)</span>
<span class="sd">    - Configuration is consistent across files</span>

<span class="sd">    This approach enables efficient processing workflows where sample data</span>
<span class="sd">    is converted to more efficient formats (like NetCDF) without requiring</span>
<span class="sd">    full memory loading of the original CSV files.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Load from glob pattern</span>
<span class="sd">        &gt;&gt;&gt; fit = fit_from_csv_noload(&#39;model_output_*.csv&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Load from explicit list</span>
<span class="sd">        &gt;&gt;&gt; fit = fit_from_csv_noload([&#39;chain1.csv&#39;, &#39;chain2.csv&#39;])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use for conversion without memory loading</span>
<span class="sd">        &gt;&gt;&gt; netcdf_path = cmdstan_csv_to_netcdf(fit, model)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">identify_files</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identifies CSV files from the given path.&quot;&quot;&quot;</span>
        <span class="n">csvfiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">csvfiles</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Invalid path specification, </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> unknown directory: </span><span class="si">{</span><span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="n">csvfiles</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
                        <span class="n">csvfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="n">csvfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid path specification: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid path specification: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">csvfiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No CSV files found in directory </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">csvfiles</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Bad CSV file path spec, includes non-csv file: </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">csvfiles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_config_dict</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the first CSV file and returns the configuration dictionary.&quot;&quot;&quot;</span>
        <span class="n">config_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csvfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
                <span class="n">scan_config</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">config_dict</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">PermissionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot read CSV file: </span><span class="si">{</span><span class="n">csvfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="s2">&quot;model&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config_dict</span> <span class="ow">or</span> <span class="s2">&quot;method&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">csvfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a Stan CSV file.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expecting Stan CSV output files from method sample, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot; found outputs from method </span><span class="si">{</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">config_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_sampler_args</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">SamplerArgs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds the sampler arguments&quot;&quot;&quot;</span>
        <span class="n">sampler_args</span> <span class="o">=</span> <span class="n">SamplerArgs</span><span class="p">(</span>
            <span class="n">iter_sampling</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">],</span>
            <span class="n">iter_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_warmup&quot;</span><span class="p">],</span>
            <span class="n">thin</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;thin&quot;</span><span class="p">],</span>
            <span class="n">save_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;save_warmup&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># bugfix 425, check for fixed_params output</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_sampler_csv</span><span class="p">(</span>
                <span class="n">csvfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">iter_sampling</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">],</span>
                <span class="n">iter_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_warmup&quot;</span><span class="p">],</span>
                <span class="n">thin</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;thin&quot;</span><span class="p">],</span>
                <span class="n">save_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;save_warmup&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_sampler_csv</span><span class="p">(</span>
                    <span class="n">csvfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">is_fixed_param</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">iter_sampling</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">],</span>
                    <span class="n">iter_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_warmup&quot;</span><span class="p">],</span>
                    <span class="n">thin</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;thin&quot;</span><span class="p">],</span>
                    <span class="n">save_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;save_warmup&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">sampler_args</span> <span class="o">=</span> <span class="n">SamplerArgs</span><span class="p">(</span>
                    <span class="n">iter_sampling</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">],</span>
                    <span class="n">iter_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;num_warmup&quot;</span><span class="p">],</span>
                    <span class="n">thin</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;thin&quot;</span><span class="p">],</span>
                    <span class="n">save_warmup</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;save_warmup&quot;</span><span class="p">],</span>
                    <span class="n">fixed_param</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid or corrupt Stan CSV output file, &quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">return</span> <span class="n">sampler_args</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_fit</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CmdStanMCMC</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds the CmdStanMCMC object&quot;&quot;&quot;</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">csvfiles</span><span class="p">)</span>
        <span class="n">cmdstan_args</span> <span class="o">=</span> <span class="n">CmdStanArgs</span><span class="p">(</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">],</span>
            <span class="n">model_exe</span><span class="o">=</span><span class="n">config_dict</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">],</span>
            <span class="n">chain_ids</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chains</span><span class="p">)],</span>
            <span class="n">method_args</span><span class="o">=</span><span class="n">sampler_args</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">runset</span> <span class="o">=</span> <span class="n">RunSet</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">cmdstan_args</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="n">chains</span><span class="p">)</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">runset</span><span class="o">.</span><span class="n">_csv_files</span> <span class="o">=</span> <span class="n">csvfiles</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">runset</span><span class="o">.</span><span class="n">_retcodes</span><span class="p">)):</span>
            <span class="n">runset</span><span class="o">.</span><span class="n">_set_retcode</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># pylint: enable=protected-access</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">CmdStanMCMC</span><span class="p">(</span><span class="n">runset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit</span>

    <span class="c1"># Run the functions to parse the CSV files</span>
    <span class="n">csvfiles</span> <span class="o">=</span> <span class="n">identify_files</span><span class="p">()</span>
    <span class="n">config_dict</span> <span class="o">=</span> <span class="n">get_config_dict</span><span class="p">()</span>
    <span class="n">sampler_args</span> <span class="o">=</span> <span class="n">build_sampler_args</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">build_fit</span><span class="p">()</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">SciStanPy API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../scistanpy.html">scistanpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Bruce Wittmann.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>