<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Utils API Reference &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=6b921976"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Operations API Reference" href="operations.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-scistanpy.utils">
<span id="utils-api-reference"></span><h1>Utils API Reference<a class="headerlink" href="#module-scistanpy.utils" title="Link to this heading">¶</a></h1>
<p>Utility functions and classes for the SciStanPy package.</p>
<p>This module provides various utility functions and classes that support
the core functionality of SciStanPy, including:</p>
<ul class="simple">
<li><p>Lazy importing mechanisms for performance optimization</p></li>
<li><p>Mathematical utility functions for numerical stability</p></li>
<li><p>Array chunking utilities for efficient memory management</p></li>
<li><p>Context managers for external library integration</p></li>
<li><p>Optimized statistical computation functions</p></li>
</ul>
<p>Users will not typically need to interact with this module directly–it is designed
to be used internally by SciStanPy.</p>
<section id="lazy-import-system">
<h2>Lazy Import System<a class="headerlink" href="#lazy-import-system" title="Link to this heading">¶</a></h2>
<p>To speed up initial import times, SciStanPy provides a lazy import system that defers loading of optional dependencies until they are actually needed.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scistanpy.utils.lazy_import">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">lazy_import</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scistanpy/utils.html#lazy_import"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.lazy_import" title="Link to this definition">¶</a></dt>
<dd><p>Import a module only when it is first needed.</p>
<p>This function implements lazy module importing to improve package import
performance by deferring module loading until actual use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The fully qualified module name to import</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The imported module</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>module</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ImportError</strong> – If the specified module cannot be found</p>
</dd>
</dl>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Module is not loaded until first use</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy_module</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now numpy is actually imported</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">numpy_module</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the module is already imported, returns the cached version
from sys.modules for efficiency.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scistanpy.utils.LazyObjectProxy">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">LazyObjectProxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scistanpy/utils.html#LazyObjectProxy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.LazyObjectProxy" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A proxy that delays importing a module and accessing an object until first use.</p>
<p>This class provides a lazy loading mechanism for specific objects within
modules, allowing fine-grained control over when imports occur. The proxy
forwards all method calls and attribute access to the actual object once
it’s loaded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module_name</strong> (<em>str</em>) – The fully qualified name of the module containing the object</p></li>
<li><p><strong>obj_name</strong> (<em>str</em>) – The name of the object to import from the module</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>_module_name</strong> – Stored module name for lazy loading</p></li>
<li><p><strong>_obj_name</strong> – Stored object name for lazy loading</p></li>
<li><p><strong>_cached_obj</strong> – Cached reference to the imported object (None until first use)</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a proxy for numpy.array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_proxy</span> <span class="o">=</span> <span class="n">LazyObjectProxy</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># numpy is not imported yet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_array</span> <span class="o">=</span> <span class="n">array_proxy</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># Now numpy is imported</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scistanpy.utils.lazy_import_from">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">lazy_import_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scistanpy/utils.html#lazy_import_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.lazy_import_from" title="Link to this definition">¶</a></dt>
<dd><p>Create a lazy import proxy for a specific object from a module.</p>
<p>This function provides a convenient way to create lazy import proxies,
equivalent to <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module_name</span> <span class="pre">import</span> <span class="pre">obj_name</span></code> but with deferred loading.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module_name</strong> (<em>str</em>) – The fully qualified module name to import from</p></li>
<li><p><strong>obj_name</strong> (<em>str</em>) – The name of the object to import from the module</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A proxy that will import and return the object when first accessed</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#scistanpy.utils.LazyObjectProxy" title="scistanpy.utils.LazyObjectProxy">LazyObjectProxy</a></p>
</dd>
</dl>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Equivalent to &#39;from numpy import array&#39; but lazy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">lazy_import_from</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># numpy imported here</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="backend-selection">
<h2>Backend Selection<a class="headerlink" href="#backend-selection" title="Link to this heading">¶</a></h2>
<p>Many SciStanPy operations can be performed using either NumPy or PyTorch as the underlying numerical backend. The utility function below automates the selection of the appropriate backend based on the input data type.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scistanpy.utils.choose_module">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">choose_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="s"><span class="pre">'custom_types.SampleType'</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ModuleType</span></span></span><a class="reference internal" href="../_modules/scistanpy/utils.html#choose_module"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.choose_module" title="Link to this definition">¶</a></dt>
<dd><p>Choose the appropriate computational module based on input type.</p>
<p>This function provides automatic backend selection between NumPy and
PyTorch based on the type of the input data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dist</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>np.ndarray</em><em>, </em><em>custom_types.SampleType</em><em>]</em>) – Input data whose type determines the module choice</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The appropriate module (torch for tensors, numpy for arrays)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch, np]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the input type is not supported</p>
</dd>
</dl>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">module</span> <span class="o">=</span> <span class="n">choose_module</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>  <span class="c1"># Returns torch module</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="numerical-stability">
<h2>Numerical Stability<a class="headerlink" href="#numerical-stability" title="Link to this heading">¶</a></h2>
<p>With probabilistic computations, numerical stability is often a concern. The following utility function provides a numerically stable implementation of the sigmoid function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scistanpy.utils.stable_sigmoid">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">stable_sigmoid</span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><span class="n"><span class="pre">exponent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>,</dd>
</dl>

<span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/scistanpy/utils.html#stable_sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.stable_sigmoid" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">stable_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">torch.Tensor</span></span></span></dt>
<dd><p>Compute sigmoid function in a numerically stable way.</p>
<p>This function implements a numerically stable version of the sigmoid
function that avoids overflow issues by using different computational
approaches for positive and negative inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>exponent</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>npt.NDArray</em><em>[</em><em>np.floating</em><em>]</em><em>]</em>) – Input values for sigmoid computation</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Sigmoid values with the same type and shape as input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, npt.NDArray[np.floating]]</p>
</dd>
</dl>
<p>The function uses the identity:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma(x) =
\begin{cases}
    \frac{1}{1 + e^{-x}} &amp; \text{if } x \geq 0 \\
    \frac{e^{x}}{1 + e^{x}} &amp; \text{if } x &lt; 0
\end{cases}\end{split}\]</div>
</dd></dl>

</section>
<section id="dask-integration">
<h2>Dask Integration<a class="headerlink" href="#dask-integration" title="Link to this heading">¶</a></h2>
<p>For particularly large models, sampling via Stan can yield more data than cat fit in memory. To handle such cases, SciStanPy integrates Dask to enable out-of-core computation and parallel processing, particularly with the <a class="reference internal" href="model/results/hmc.html#scistanpy.model.results.hmc.SampleResults" title="scistanpy.model.results.hmc.SampleResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleResults</span></code></a> class. The following utility functions assist with Dask integration.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">get_chunk_shape</span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><span class="n"><span class="pre">array_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">custom_types.Integer</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></em>,</dd>
<dd><em class="sig-param"><span class="n"><span class="pre">array_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'double'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'single'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'half'</span></span><span class="p"><span class="pre">]</span></span></span></em>,</dd>
<dd><em class="sig-param"><span class="n"><span class="pre">mib_per_chunk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">custom_types.Integer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>,</dd>
<dd><em class="sig-param"><span class="n"><span class="pre">frozen_dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Collection</span><span class="p"><span class="pre">[</span></span><span class="pre">custom_types.Integer</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">()</span></span></em>,</dd>
</dl>

<span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">custom_types.Integer</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/scistanpy/utils.html#get_chunk_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate optimal chunk shape for Dask arrays based on memory constraints.</p>
<p>This function determines the optimal chunking strategy for large arrays
processed with Dask, balancing memory usage with computational efficiency.
It respects frozen dimensions that should not be chunked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array_shape</strong> (<em>tuple</em><em>[</em><em>custom_types.Integer</em><em>, </em><em>...</em><em>]</em>) – Shape of the array to be chunked</p></li>
<li><p><strong>array_precision</strong> (<em>Literal</em><em>[</em><em>&quot;double&quot;</em><em>, </em><em>&quot;single&quot;</em><em>, </em><em>&quot;half&quot;</em><em>]</em>) – Numerical precision assumed in calculating memory usage.</p></li>
<li><p><strong>mib_per_chunk</strong> (<em>Union</em><em>[</em><em>custom_types.Integer</em><em>, </em><em>None</em><em>]</em>) – Target chunk size in MiB. If None, uses Dask default</p></li>
<li><p><strong>frozen_dims</strong> (<em>Collection</em><em>[</em><em>custom_types.Integer</em><em>]</em>) – Dimensions that should not be chunked</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimal chunk shape for the array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[custom_types.Integer, …]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If mib_per_chunk is negative</p></li>
<li><p><strong>IndexError</strong> – If frozen_dims contains invalid dimension indices</p></li>
</ul>
</dd>
</dl>
<p>The algorithm:</p>
<ol class="arabic simple">
<li><p>Calculates memory usage per array element based on precision</p></li>
<li><p>Sets frozen dimensions to their full size</p></li>
<li><p>Iteratively determines chunk sizes for remaining dimensions</p></li>
<li><p>Ensures total chunk memory stays within the specified limit (or as close to
it as possible if frozen dimensions result in a smallest possible size above
the limit)</p></li>
</ol>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Chunk a (1000, 2000, 100) array, keeping last dim intact</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="n">get_chunk_shape</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">frozen_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scistanpy.utils.az_dask">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scistanpy.utils.</span></span><span class="sig-name descname"><span class="pre">az_dask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dask_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'parallelized'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dtypes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scistanpy/utils.html#az_dask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.utils.az_dask" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Context manager for enabling Dask integration with ArviZ.</p>
<p>This context manager provides a convenient way to enable Dask-based
parallel computation within ArviZ operations, automatically handling
the setup and teardown of Dask configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dask_type</strong> (<em>str</em>) – Type of Dask computation to enable</p></li>
<li><p><strong>output_dtypes</strong> (<em>Union</em><em>[</em><em>list</em><em>[</em><em>object</em><em>]</em><em>, </em><em>None</em><em>]</em>) – Expected output data types for Dask operations</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>dask_type</strong> – Stored Dask computation type</p></li>
<li><p><strong>output_dtypes</strong> – Stored output data types configuration</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">az_dask</span><span class="p">()</span> <span class="k">as</span> <span class="n">dask_ctx</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># ArviZ operations here will use Dask parallelization</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">trace_data</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The context manager automatically disables Dask when exiting,
ensuring clean state management.</p>
</div>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SciStanPy API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="custom_types.html">Custom Types API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="defaults.html">Defaults API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="exceptions.html">Exceptions API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="model/index.html">Model API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotting/index.html">Plotting Subpackage API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="operations.html">Operations API Reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Utils API Reference</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">SciStanPy API Reference</a><ul>
      <li>Previous: <a href="operations.html" title="previous chapter">Operations API Reference</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Microsoft Corporation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/api/utils.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>