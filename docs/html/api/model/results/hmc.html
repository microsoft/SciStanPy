<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Hamiltonian Monte Carlo Results API Reference &#8212; SciStanPy Alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=6b921976"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Stan Integration" href="../stan/index.html" />
    <link rel="prev" title="Maximum Likelihood Estimation Results API Reference" href="mle.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="hamiltonian-monte-carlo-results-api-reference">
<h1>Hamiltonian Monte Carlo Results API Reference<a class="headerlink" href="#hamiltonian-monte-carlo-results-api-reference" title="Link to this heading">¶</a></h1>
<p>This reference covers the analysis and diagnostic tools for Hamiltonian Monte Carlo sampling results in SciStanPy.</p>
<section id="module-scistanpy.model.results.hmc">
<span id="hmc-results-module"></span><h2>HMC Results Module<a class="headerlink" href="#module-scistanpy.model.results.hmc" title="Link to this heading">¶</a></h2>
<p>Hamiltonian Monte Carlo (HMC) sampling results analysis and diagnostics.</p>
<p>This module provides tools for analyzing and diagnosing HMC sampling results from
Stan models. It offers specialized classes and functions for processing
MCMC output, conducting diagnostic tests, and creating interactive visualizations
for model validation and troubleshooting.</p>
<p>The module centers around the SampleResults class, which extends MLEInferenceRes
to provide HMC-specific functionality including convergence diagnostics, sample
quality assessment, and specialized visualization tools for identifying problematic
parameters and sampling behavior.</p>
<dl class="simple">
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>MCMC diagnostic test suites</p></li>
<li><p>Interactive visualization tools for failed diagnostics</p></li>
<li><p>Efficient CSV to NetCDF conversion for large datasets</p></li>
<li><p>Dask-enabled processing for memory-intensive operations</p></li>
<li><p>Specialized trace plot analysis for problematic variables</p></li>
<li><p>Automated detection and reporting of sampling issues</p></li>
</ul>
</dd>
<dt>Diagnostic Capabilities:</dt><dd><ul class="simple">
<li><p>R-hat convergence assessment</p></li>
<li><p>Effective sample size (ESS) evaluation</p></li>
<li><p>Energy fraction of missing information (E-BFMI) analysis</p></li>
<li><p>Divergence detection and analysis</p></li>
<li><p>Tree depth saturation monitoring</p></li>
<li><p>Variable-specific failure pattern identification</p></li>
</ul>
</dd>
</dl>
<p>The module is designed to handle both small-scale interactive analysis and
large-scale batch processing of MCMC results, with particular attention to
memory efficiency and computational performance for complex models.</p>
<dl class="simple">
<dt>Performance Considerations:</dt><dd><ul class="simple">
<li><p>NetCDF storage format for efficient large dataset handling</p></li>
<li><p>Dask integration for out-of-core computation</p></li>
<li><p>Chunked processing strategies for memory management</p></li>
<li><p>Optimized data structures for diagnostic computation</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">members<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">undoc-members<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">show-inheritance<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</section>
<section id="core-hmc-analysis-classes">
<h2>Core HMC Analysis Classes<a class="headerlink" href="#core-hmc-analysis-classes" title="Link to this heading">¶</a></h2>
<section id="sample-results-analysis">
<h3>Sample Results Analysis<a class="headerlink" href="#sample-results-analysis" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="scistanpy.model.results.hmc.SampleResults">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">SampleResults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'Model'</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">os.PathLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">CmdStanMCMC</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">npt.NDArray</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'double'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'single'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'half'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inference_obj</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">az.InferenceData</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mib_per_chunk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">custom_types.Integer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_dask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#SampleResults"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.model.results.hmc.SampleResults" title="Link to this definition">¶</a></dt>
<dd><p>Comprehensive analysis interface for HMC sampling results. This class should
never be instantiated directly. Instead, use the <cite>from_disk</cite> method to load the
appropriate results object from disk.</p>
<p>This class extends MLEInferenceRes to provide specialized functionality
for analyzing Hamiltonian Monte Carlo sampling results from Stan. It offers
comprehensive diagnostic capabilities, interactive visualization tools,
and efficient data management for large MCMC datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../model.html#scistanpy.model.model.Model" title="scistanpy.model.model.Model"><em>Model</em></a><em>]</em>) – SciStanPy model used for sampling. Defaults to None.</p></li>
<li><p><strong>fit</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>, </em><em>os.PathLike</em><em>, </em><em>CmdStanMCMC</em><em>]</em><em>]</em>) – CmdStanMCMC object or path to CSV files. Defaults to None.</p></li>
<li><p><strong>data</strong> (<em>Optional</em><em>[</em><em>dict</em><em>[</em><em>str</em><em>, </em><em>npt.NDArray</em><em>]</em><em>]</em>) – Observed data dictionary. Defaults to None.</p></li>
<li><p><strong>precision</strong> (<em>Literal</em><em>[</em><em>&quot;double&quot;</em><em>, </em><em>&quot;single&quot;</em><em>, </em><em>&quot;half&quot;</em><em>]</em>) – Numerical precision for arrays. Defaults to “single”.</p></li>
<li><p><strong>inference_obj</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>az.InferenceData</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Pre-existing InferenceData or NetCDF path. Defaults to None.</p></li>
<li><p><strong>mib_per_chunk</strong> (<em>Optional</em><em>[</em><em>custom_types.Integer</em><em>]</em>) – Memory limit per chunk in MiB. Defaults to None.</p></li>
<li><p><strong>use_dask</strong> (<em>bool</em>) – Whether to use Dask for computation. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fit</strong> – CmdStanMCMC object containing sampling metadata</p></li>
<li><p><strong>use_dask</strong> – Flag controlling Dask usage for computation</p></li>
</ul>
</dd>
</dl>
<p>The class provides comprehensive functionality for:
- MCMC convergence diagnostics and reporting
- Sample quality assessment and visualization
- Interactive analysis of problematic variables
- Efficient handling of large datasets with Dask integration
- Automated detection and reporting of sampling issues</p>
<p>Key Diagnostic Features:
- R-hat convergence assessment
- Effective sample size evaluation
- Energy-based diagnostics (E-BFMI)
- Divergence detection and analysis
- Tree depth saturation monitoring</p>
<p>The class automatically handles NetCDF conversion for efficient storage
and supports both in-memory and out-of-core computation depending on
dataset size and available memory.</p>
<p>Base class just initializes the ArviZ object.</p>
<dl class="field-list simple">
<dt class="field-odd">Members<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Undoc-members<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Show-inheritance<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p><strong>Comprehensive MCMC Diagnostics:</strong></p>
<p>The SampleResults class provides complete diagnostic capabilities for HMC sampling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">scistanpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ssp</span>

<span class="c1"># Get MCMC results</span>
<span class="n">mcmc_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">observed_data</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">iter_sampling</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

<span class="c1"># Complete diagnostic pipeline</span>
<span class="n">sample_failures</span><span class="p">,</span> <span class="n">var_failures</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">diagnose</span><span class="p">()</span>

<span class="c1"># Interactive analysis of problematic variables</span>
<span class="n">analyzer</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">plot_variable_failure_quantile_traces</span><span class="p">()</span>

<span class="c1"># Detailed calibration assessment</span>
<span class="n">calibration_analysis</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">check_calibration</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="variable-failure-analyzer">
<h3>Variable Failure Analyzer<a class="headerlink" href="#variable-failure-analyzer" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="scistanpy.model.results.hmc.VariableAnalyzer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">VariableAnalyzer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_results</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#scistanpy.model.results.hmc.SampleResults" title="scistanpy.model.results.hmc.SampleResults"><span class="pre">SampleResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_width</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">custom_types.Integer</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">800</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_height</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">custom_types.Integer</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">400</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_quantiles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#VariableAnalyzer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.model.results.hmc.VariableAnalyzer" title="Link to this definition">¶</a></dt>
<dd><p>Interactive analysis tool for variables that fail MCMC diagnostic tests.</p>
<p>This class provides an interactive interface for analyzing individual variables
that have failed diagnostic tests during MCMC sampling. It creates a dashboard
with widgets for selecting variables, metrics, and specific array indices,
along with trace plots showing the problematic sampling behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_results</strong> (<a class="reference internal" href="#scistanpy.model.results.hmc.SampleResults" title="scistanpy.model.results.hmc.SampleResults"><em>SampleResults</em></a>) – SampleResults object containing MCMC diagnostics</p></li>
<li><p><strong>plot_width</strong> (<em>custom_types.Integer</em>) – Width of plots in pixels. Defaults to 800.</p></li>
<li><p><strong>plot_height</strong> (<em>custom_types.Integer</em>) – Height of plots in pixels. Defaults to 400.</p></li>
<li><p><strong>plot_quantiles</strong> (<em>bool</em>) – Whether to plot quantiles vs raw values. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sample_results</strong> – Reference to source sampling results</p></li>
<li><p><strong>plot_quantiles</strong> – Flag controlling plot content type</p></li>
<li><p><strong>n_chains</strong> – Number of MCMC chains in the results</p></li>
<li><p><strong>x</strong> – Array of step indices for x-axis</p></li>
<li><p><strong>failed_vars</strong> – Dictionary mapping variable names to failure information</p></li>
<li><p><strong>varchoice</strong> – Widget for selecting variables to analyze</p></li>
<li><p><strong>metricchoice</strong> – Widget for selecting diagnostic metrics</p></li>
<li><p><strong>indexchoice</strong> – Widget for selecting array indices</p></li>
<li><p><strong>plot_width</strong> – Recorded width of plots</p></li>
<li><p><strong>plot_height</strong> – Recorded height of plots</p></li>
<li><p><strong>fig</strong> – HoloViews pane containing the current plot</p></li>
<li><p><strong>layout</strong> – Panel layout containing all interface elements</p></li>
</ul>
</dd>
</dl>
<p>The analyzer automatically identifies variables that have failed diagnostic
tests and organizes them by failure type. It provides trace plots that can
show either raw parameter values or their quantiles relative to passing
samples, helping identify the nature of sampling problems.</p>
<p>Key Features:
- Automatic identification of failed variables and metrics
- Interactive widget-based navigation
- Trace plots with chain-specific coloring
- Quantile-based analysis for identifying sampling bias
- Real-time plot updates based on widget selections</p>
<dl class="simple">
<dt>Note:</dt><dd><p>This class should not be instantiated directly. Use the
plot_variable_failure_quantile_traces method of SampleResults instead.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Members<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Undoc-members<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Show-inheritance<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p><strong>Interactive Diagnostic Analysis:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create interactive analyzer for failed variables</span>
<span class="n">analyzer</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">plot_variable_failure_quantile_traces</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">plot_quantiles</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Show quantiles vs raw values</span>
<span class="p">)</span>

<span class="c1"># Analyzer provides:</span>
<span class="c1"># - Variable selection widgets</span>
<span class="c1"># - Metric selection (r_hat, ess_bulk, ess_tail)</span>
<span class="c1"># - Index selection for multi-dimensional parameters</span>
<span class="c1"># - Real-time trace plot updates</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="efficient-data-processing">
<h2>Efficient Data Processing<a class="headerlink" href="#efficient-data-processing" title="Link to this heading">¶</a></h2>
<section id="csv-to-netcdf-conversion">
<h3>CSV to NetCDF Conversion<a class="headerlink" href="#csv-to-netcdf-conversion" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="scistanpy.model.results.hmc.CmdStanMCMCToNetCDFConverter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">CmdStanMCMCToNetCDFConverter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">CmdStanMCMC</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">os.PathLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../model.html#scistanpy.model.model.Model" title="scistanpy.model.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#CmdStanMCMCToNetCDFConverter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scistanpy.model.results.hmc.CmdStanMCMCToNetCDFConverter" title="Link to this definition">¶</a></dt>
<dd><p>Efficient converter from CmdStan CSV output to NetCDF format.</p>
<p>This class handles the conversion of CmdStan CSV output files to NetCDF
format, providing efficient storage and access for large MCMC datasets.
It properly organizes data into appropriate groups and handles dimension
naming and chunking strategies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fit</strong> (<em>Union</em><em>[</em><em>CmdStanMCMC</em><em>, </em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>, </em><em>os.PathLike</em><em>]</em>) – CmdStanMCMC object or path to CSV files</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="../model.html#scistanpy.model.model.Model" title="scistanpy.model.model.Model"><em>Model</em></a>) – SciStanPy model object for metadata extraction</p></li>
<li><p><strong>data</strong> (<em>Optional</em><em>[</em><em>dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Optional observed data dictionary. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fit</strong> – CmdStanMCMC object containing sampling results</p></li>
<li><p><strong>model</strong> – Reference to the original SciStanPy model</p></li>
<li><p><strong>data</strong> – Observed data used for model fitting</p></li>
<li><p><strong>config</strong> – Configuration dictionary from Stan sampling</p></li>
<li><p><strong>num_draws</strong> – Total number of draws including warmup if saved</p></li>
<li><p><strong>varname_to_column_order</strong> – Mapping from variables to csv column indices</p></li>
</ul>
</dd>
</dl>
<p>The converter handles:
- Automatic detection of variable types and dimensions
- Proper NetCDF group organization
- Chunking strategies for large datasets
- Data type optimization based on precision requirements</p>
<p>This class is used internally by the cmdstan_csv_to_netcdf function and
should not be instantiated directly in most use cases.</p>
<p>Initialization involves collecting information about the different variables
in the fit object. This includes the names of the variables, their shapes,
and their types. This information is used to create the HDF5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Members<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Undoc-members<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Show-inheritance<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p><strong>High-Performance Data Conversion:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Direct conversion from CSV to NetCDF</span>
<span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="s1">&#39;model_output_*.csv&#39;</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>    <span class="c1"># Memory optimization</span>
    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="mi">128</span>     <span class="c1"># Control chunk sizes</span>
<span class="p">)</span>

<span class="c1"># Load converted results</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span><span class="n">netcdf_path</span><span class="p">,</span> <span class="n">use_dask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">cmdstan_csv_to_netcdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">os.PathLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">CmdStanMCMC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../model.html#scistanpy.model.model.Model" title="scistanpy.model.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'double'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'single'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'half'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mib_per_chunk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">custom_types.Integer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#cmdstan_csv_to_netcdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert CmdStan CSV output to efficient NetCDF format.</p>
<p>This function provides a high-level interface for converting CmdStan
sampling results from CSV format to NetCDF, enabling efficient storage
and processing of large MCMC datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>, </em><em>os.PathLike</em><em>, </em><em>CmdStanMCMC</em><em>]</em>) – Path to CSV files or CmdStanMCMC object</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="../model.html#scistanpy.model.model.Model" title="scistanpy.model.model.Model"><em>Model</em></a>) – SciStanPy model used for sampling</p></li>
<li><p><strong>data</strong> (<em>Optional</em><em>[</em><em>dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Observed data dictionary. Uses model default if None. Defaults to None.</p></li>
<li><p><strong>output_filename</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Output NetCDF filename. Auto-generated if None. Defaults to None.</p></li>
<li><p><strong>precision</strong> (<em>Literal</em><em>[</em><em>&quot;double&quot;</em><em>, </em><em>&quot;single&quot;</em><em>, </em><em>&quot;half&quot;</em><em>]</em>) – Numerical precision for stored arrays. Defaults to “single”.</p></li>
<li><p><strong>mib_per_chunk</strong> (<em>Optional</em><em>[</em><em>custom_types.Integer</em><em>]</em>) – Memory limit per chunk in MiB. Defaults to None, meaning
use Dask default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Path to created NetCDF file</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p>The conversion process:
1. Analyzes model structure to determine optimal storage layout
2. Creates NetCDF file with appropriate groups and dimensions
3. Converts CSV data with proper chunking for memory efficiency
4. Organizes results into ArviZ-compatible structure</p>
<p>Benefits of NetCDF format:
- Significantly faster loading compared to CSV
- Memory-efficient access with chunking support
- Metadata preservation and self-describing format
- Integration with scientific Python ecosystem</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;model_output*.csv&#39;</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;single&#39;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span><span class="n">netcdf_path</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Batch Conversion Workflow:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert large datasets efficiently</span>
<span class="n">netcdf_file</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="n">cmdstan_fit</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">scistanpy_model</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="n">observed_data</span><span class="p">,</span>
    <span class="n">output_filename</span><span class="o">=</span><span class="s1">&#39;large_model_results.nc&#39;</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>
    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="mi">64</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="utility-functions">
<h3>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">fit_from_csv_noload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">PathLike</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">CmdStanMCMC</span></span></span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#fit_from_csv_noload"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create CmdStanMCMC object from CSV files without loading data into memory.
This function is adapted from <cite>cmdstanpy.from_csv</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>, </em><em>os.PathLike</em><em>]</em>) – Path specification for CSV files (single file, list, or glob pattern)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>CmdStanMCMC object with metadata but no loaded sample data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>CmdStanMCMC</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If path specification is invalid or no CSV files found</p></li>
<li><p><strong>ValueError</strong> – If CSV files are not valid Stan output</p></li>
</ul>
</dd>
</dl>
<p>This function provides a memory-efficient way to create CmdStanMCMC objects
by parsing only the metadata from CSV files without loading the actual
sample data. This is particularly useful for large datasets where memory
usage is a concern.</p>
<p>Path Specifications:
- <strong>Single file</strong>: Direct path to one CSV file
- <strong>File list</strong>: List of paths to multiple CSV files
- <strong>Glob pattern</strong>: Wildcard pattern for automatic file discovery
- <strong>Directory</strong>: Directory containing CSV files (loads all .csv files)</p>
<p>The function performs validation to ensure:
- All specified files exist and are readable
- Files contain valid Stan CSV output
- Sampling method is compatible (only ‘sample’ method supported)
- Configuration is consistent across files</p>
<p>This approach enables efficient processing workflows where sample data
is converted to more efficient formats (like NetCDF) without requiring
full memory loading of the original CSV files.</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load from glob pattern</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit</span> <span class="o">=</span> <span class="n">fit_from_csv_noload</span><span class="p">(</span><span class="s1">&#39;model_output_*.csv&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load from explicit list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit</span> <span class="o">=</span> <span class="n">fit_from_csv_noload</span><span class="p">([</span><span class="s1">&#39;chain1.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;chain2.csv&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use for conversion without memory loading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">dask_enabled_summary_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inference_obj</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">InferenceData</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#dask_enabled_summary_stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute summary statistics using Dask for memory efficiency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inference_obj</strong> (<em>az.InferenceData</em>) – ArviZ InferenceData object containing posterior samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dataset containing computed summary statistics</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
<p>This function computes basic summary statistics (mean, standard deviation,
and highest density intervals) using Dask for memory-efficient computation
on large datasets that might not fit in memory.</p>
<p>The function leverages Dask’s lazy evaluation to:
- Queue multiple computations for efficient execution
- Minimize memory usage through chunked processing
- Provide progress tracking for long-running computations</p>
<p>Computed Statistics:
- Mean across chains and draws
- Standard deviation across chains and draws
- 94% highest density intervals</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">dask_enabled_summary_stats</span><span class="p">(</span><span class="n">inference_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">dask_enabled_diagnostics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inference_obj</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">InferenceData</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#dask_enabled_diagnostics"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute MCMC diagnostics using Dask for memory efficiency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inference_obj</strong> (<em>az.InferenceData</em>) – ArviZ InferenceData object containing posterior samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dataset containing computed diagnostic metrics</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
<p>This function computes comprehensive MCMC diagnostic metrics using Dask
for memory-efficient computation on large datasets. All diagnostics are
computed simultaneously to maximize efficiency.</p>
<p>Computed Diagnostics:
- Monte Carlo standard errors (mean and sd methods)
- Effective sample sizes (bulk and tail)
- R-hat convergence diagnostic</p>
<p>The Dask implementation enables:
- Parallel computation across available cores
- Memory-efficient processing of large datasets
- Automatic load balancing and optimization</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diagnostics</span> <span class="o">=</span> <span class="n">dask_enabled_diagnostics</span><span class="p">(</span><span class="n">inference_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">diagnostics</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;r_hat&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scistanpy.model.results.hmc.</span></span><span class="sig-name descname"><span class="pre">_symmetrize_quantiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantiles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">custom_types.Float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">custom_types.Float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../_modules/scistanpy/model/results/hmc.html#_symmetrize_quantiles"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Symmetrize and validate quantile sequences for plotting.</p>
<p>This utility function takes a sequence of quantiles and creates a symmetric
set by adding complementary quantiles and ensuring the median is included.
It also validates that all quantiles are properly bounded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quantiles</strong> (<em>Sequence</em><em>[</em><em>custom_types.Float</em><em>]</em>) – Sequence of quantile values between 0 and 1</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Symmetrized and sorted list of quantiles including median</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[custom_types.Float]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If quantiles are not between 0 and 1</p></li>
<li><p><strong>AssertionError</strong> – If result doesn’t have odd length or include median</p></li>
</ul>
</dd>
</dl>
<p>The function ensures:
- All quantiles are between 0 and 1 (exclusive)
- Complementary quantiles are added (e.g., 0.1 → 0.1, 0.9)
- Median (0.5) is always included
- Result has odd length for symmetric confidence intervals</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quantiles</span> <span class="o">=</span> <span class="n">_symmetrize_quantiles</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Returns [0.1, 0.2, 0.5, 0.8, 0.9]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="comprehensive-diagnostic-framework">
<h2>Comprehensive Diagnostic Framework<a class="headerlink" href="#comprehensive-diagnostic-framework" title="Link to this heading">¶</a></h2>
<section id="complete-diagnostic-pipeline">
<h3>Complete Diagnostic Pipeline<a class="headerlink" href="#complete-diagnostic-pipeline" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Full diagnostic workflow</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">iter_sampling</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

<span class="c1"># Step 1: Calculate all diagnostic metrics</span>
<span class="n">diagnostics</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">calculate_diagnostics</span><span class="p">()</span>

<span class="c1"># Step 2: Evaluate sample-level issues</span>
<span class="n">sample_tests</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">evaluate_sample_stats</span><span class="p">(</span>
    <span class="n">ebfmi_thresh</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>           <span class="c1"># Energy threshold</span>
    <span class="n">max_tree_depth</span><span class="o">=</span><span class="kc">None</span>         <span class="c1"># Uses model default</span>
<span class="p">)</span>

<span class="c1"># Step 3: Evaluate variable-level issues</span>
<span class="n">var_tests</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">evaluate_variable_diagnostic_stats</span><span class="p">(</span>
    <span class="n">r_hat_thresh</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span>          <span class="c1"># Convergence threshold</span>
    <span class="n">ess_thresh</span><span class="o">=</span><span class="mi">100</span>              <span class="c1"># ESS per chain threshold</span>
<span class="p">)</span>

<span class="c1"># Step 4: Comprehensive failure analysis</span>
<span class="n">sample_failures</span><span class="p">,</span> <span class="n">var_failures</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">identify_failed_diagnostics</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="diagnostic-test-categories">
<h3>Diagnostic Test Categories<a class="headerlink" href="#diagnostic-test-categories" title="Link to this heading">¶</a></h3>
<p><strong>Sample-Level Diagnostics:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sample diagnostic tests</span>
<span class="n">sample_tests</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">evaluate_sample_stats</span><span class="p">()</span>

<span class="c1"># Tests performed:</span>
<span class="c1"># - low_ebfmi: Energy-based fraction of missing information</span>
<span class="c1"># - max_tree_depth_reached: Tree depth saturation</span>
<span class="c1"># - diverged: Hamiltonian divergences</span>

<span class="c1"># Access specific test results</span>
<span class="n">diverged_samples</span> <span class="o">=</span> <span class="n">sample_tests</span><span class="o">.</span><span class="n">diverged</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="n">energy_problems</span> <span class="o">=</span> <span class="n">sample_tests</span><span class="o">.</span><span class="n">low_ebfmi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="n">depth_issues</span> <span class="o">=</span> <span class="n">sample_tests</span><span class="o">.</span><span class="n">max_tree_depth_reached</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Variable-Level Diagnostics:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Variable diagnostic tests</span>
<span class="n">var_tests</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">evaluate_variable_diagnostic_stats</span><span class="p">()</span>

<span class="c1"># Tests performed:</span>
<span class="c1"># - r_hat: Split R-hat convergence diagnostic</span>
<span class="c1"># - ess_bulk: Bulk effective sample size</span>
<span class="c1"># - ess_tail: Tail effective sample size</span>

<span class="c1"># Identify problematic variables</span>
<span class="n">failed_convergence</span> <span class="o">=</span> <span class="n">var_tests</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;r_hat&#39;</span><span class="p">)</span>
<span class="n">poor_mixing</span> <span class="o">=</span> <span class="n">var_tests</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;ess_bulk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="advanced-visualization-tools">
<h2>Advanced Visualization Tools<a class="headerlink" href="#advanced-visualization-tools" title="Link to this heading">¶</a></h2>
<section id="failure-pattern-analysis">
<h3>Failure Pattern Analysis<a class="headerlink" href="#failure-pattern-analysis" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize sample failure patterns</span>
<span class="n">sample_failure_plots</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">plot_sample_failure_quantile_traces</span><span class="p">(</span>
    <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">600</span>
<span class="p">)</span>

<span class="c1"># Available plots:</span>
<span class="c1"># - Divergence quantile traces</span>
<span class="c1"># - Energy failure patterns</span>
<span class="c1"># - Tree depth saturation analysis</span>

<span class="c1"># Each plot shows:</span>
<span class="c1"># - Parameter fraction on x-axis (sorted by typical failure quantile)</span>
<span class="c1"># - Quantile of failed samples relative to passing samples</span>
<span class="c1"># - Individual failure traces and typical patterns</span>
</pre></div>
</div>
</section>
<section id="interactive-variable-analysis">
<h3>Interactive Variable Analysis<a class="headerlink" href="#interactive-variable-analysis" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Interactive analysis of problematic variables</span>
<span class="n">variable_analyzer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">plot_variable_failure_quantile_traces</span><span class="p">(</span>
    <span class="n">plot_quantiles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>     <span class="c1"># Show quantiles vs raw values</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">600</span>
<span class="p">)</span>

<span class="c1"># Interactive features:</span>
<span class="c1"># - Variable dropdown: Select from variables that failed tests</span>
<span class="c1"># - Metric dropdown: Choose diagnostic metric (r_hat, ess_bulk, ess_tail)</span>
<span class="c1"># - Index dropdown: For multi-dimensional parameters</span>
<span class="c1"># - Real-time plot updates with chain-specific coloring</span>
</pre></div>
</div>
</section>
</section>
<section id="memory-efficient-processing">
<h2>Memory-Efficient Processing<a class="headerlink" href="#memory-efficient-processing" title="Link to this heading">¶</a></h2>
<section id="dask-integration">
<h3>Dask Integration<a class="headerlink" href="#dask-integration" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Enable Dask for large datasets</span>
<span class="n">large_results</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span>
    <span class="s1">&#39;large_model.nc&#39;</span><span class="p">,</span>
    <span class="n">use_dask</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Enable out-of-core computation</span>
<span class="p">)</span>

<span class="c1"># Compute statistics efficiently</span>
<span class="n">summary_stats</span> <span class="o">=</span> <span class="n">large_results</span><span class="o">.</span><span class="n">calculate_summaries</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stats&#39;</span><span class="p">)</span>
<span class="n">diagnostics</span> <span class="o">=</span> <span class="n">large_results</span><span class="o">.</span><span class="n">calculate_diagnostics</span><span class="p">()</span>

<span class="c1"># Dask automatically handles:</span>
<span class="c1"># - Chunked computation</span>
<span class="c1"># - Memory management</span>
<span class="c1"># - Parallel processing</span>
</pre></div>
</div>
</section>
<section id="chunking-strategies">
<h3>Chunking Strategies<a class="headerlink" href="#chunking-strategies" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert with optimal chunking</span>
<span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="n">csv_files</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>        <span class="c1"># Reduce memory footprint</span>
    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="mi">64</span>          <span class="c1"># Control chunk size</span>
<span class="p">)</span>

<span class="c1"># Chunking optimizes:</span>
<span class="c1"># - Memory usage during conversion</span>
<span class="c1"># - Subsequent analysis performance</span>
<span class="c1"># - Parallel processing efficiency</span>
</pre></div>
</div>
</section>
</section>
<section id="scientific-workflow-integration">
<h2>Scientific Workflow Integration<a class="headerlink" href="#scientific-workflow-integration" title="Link to this heading">¶</a></h2>
<section id="model-validation-pipeline">
<h3>Model Validation Pipeline<a class="headerlink" href="#model-validation-pipeline" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_mcmc_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete MCMC model validation workflow.&quot;&quot;&quot;</span>

    <span class="c1"># 1. Sample from model</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
        <span class="n">chains</span><span class="o">=</span><span class="n">n_chains</span><span class="p">,</span>
        <span class="n">iter_sampling</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>

    <span class="c1"># 2. Run comprehensive diagnostics</span>
    <span class="n">sample_failures</span><span class="p">,</span> <span class="n">var_failures</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">diagnose</span><span class="p">()</span>

    <span class="c1"># 3. Check for critical issues</span>
    <span class="n">critical_issues</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check for excessive divergences</span>
    <span class="n">n_diverged</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fails</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">fails</span> <span class="ow">in</span> <span class="n">sample_failures</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">n_diverged</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">n_chains</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">:</span>  <span class="c1"># &gt;1% divergences</span>
        <span class="n">critical_issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;High divergence rate: </span><span class="si">{</span><span class="n">n_diverged</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check for convergence failures</span>
    <span class="n">rhat_failures</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_failures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;r_hat&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="k">if</span> <span class="n">rhat_failures</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">critical_issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Convergence issues: </span><span class="si">{</span><span class="n">rhat_failures</span><span class="si">}</span><span class="s2"> variables&quot;</span><span class="p">)</span>

    <span class="c1"># 4. Generate diagnostic report</span>
    <span class="k">if</span> <span class="n">critical_issues</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;⚠️  Critical Issues Detected:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">issue</span> <span class="ow">in</span> <span class="n">critical_issues</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   - </span><span class="si">{</span><span class="n">issue</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Interactive analysis for problem diagnosis</span>
        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">plot_variable_failure_quantile_traces</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">analyzer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✅ Model passed all diagnostic tests&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="simulation-based-validation">
<h3>Simulation-Based Validation<a class="headerlink" href="#simulation-based-validation" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Parameter recovery study</span>
<span class="k">def</span><span class="w"> </span><span class="nf">parameter_recovery_study</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">true_params</span><span class="p">,</span> <span class="n">n_sims</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test parameter recovery with known true values.&quot;&quot;&quot;</span>

    <span class="n">recovery_results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sims</span><span class="p">):</span>
        <span class="c1"># Generate synthetic data</span>
        <span class="n">sim_data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">simulate_data</span><span class="p">(</span><span class="n">true_params</span><span class="p">)</span>

        <span class="c1"># Fit model</span>
        <span class="n">mcmc_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">iter_sampling</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

        <span class="c1"># Check diagnostics</span>
        <span class="n">sample_fails</span><span class="p">,</span> <span class="n">var_fails</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">diagnose</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Compute recovery metrics</span>
        <span class="n">posterior_summary</span> <span class="o">=</span> <span class="n">mcmc_results</span><span class="o">.</span><span class="n">calculate_summaries</span><span class="p">()</span>

        <span class="n">recovery_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">true_val</span> <span class="ow">in</span> <span class="n">true_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">post_mean</span> <span class="o">=</span> <span class="n">posterior_summary</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">post_std</span> <span class="o">=</span> <span class="n">posterior_summary</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;sd&#39;</span><span class="p">)[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="n">recovery_metrics</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;bias&#39;</span><span class="p">:</span> <span class="n">post_mean</span> <span class="o">-</span> <span class="n">true_val</span><span class="p">,</span>
                <span class="s1">&#39;relative_bias&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">post_mean</span> <span class="o">-</span> <span class="n">true_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">true_val</span><span class="p">,</span>
                <span class="s1">&#39;coverage&#39;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">post_mean</span> <span class="o">-</span> <span class="n">true_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">post_std</span>
            <span class="p">}</span>

        <span class="n">recovery_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;simulation&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="p">,</span>
            <span class="s1">&#39;diagnostics_passed&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_fails</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;recovery_metrics&#39;</span><span class="p">:</span> <span class="n">recovery_metrics</span>
        <span class="p">})</span>

    <span class="k">return</span> <span class="n">recovery_results</span>
</pre></div>
</div>
</section>
</section>
<section id="performance-optimization">
<h2>Performance Optimization<a class="headerlink" href="#performance-optimization" title="Link to this heading">¶</a></h2>
<section id="loading-strategies">
<h3>Loading Strategies<a class="headerlink" href="#loading-strategies" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flexible loading for different use cases</span>

<span class="c1"># Fast loading without CSV metadata (limited functionality)</span>
<span class="n">results_fast</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span>
    <span class="s1">&#39;model_results.nc&#39;</span><span class="p">,</span>
    <span class="n">skip_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>      <span class="c1"># Skip CSV loading</span>
    <span class="n">use_dask</span><span class="o">=</span><span class="kc">False</span>      <span class="c1"># In-memory processing</span>
<span class="p">)</span>

<span class="c1"># Full loading with CSV metadata (complete functionality)</span>
<span class="n">results_full</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span>
    <span class="s1">&#39;model_results.nc&#39;</span><span class="p">,</span>
    <span class="n">csv_files</span><span class="o">=</span><span class="s1">&#39;model_output_*.csv&#39;</span><span class="p">,</span>  <span class="c1"># Explicit CSV files</span>
    <span class="n">use_dask</span><span class="o">=</span><span class="kc">True</span>                    <span class="c1"># Out-of-core processing</span>
<span class="p">)</span>

<span class="c1"># Auto-detection of CSV files</span>
<span class="n">results_auto</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span>
    <span class="s1">&#39;model_results.nc&#39;</span>  <span class="c1"># Automatically finds matching CSV files</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="precision-management">
<h3>Precision Management<a class="headerlink" href="#precision-management" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optimize storage precision based on needs</span>

<span class="c1"># High precision for critical analysis</span>
<span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="n">csv_files</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;double&#39;</span>    <span class="c1"># Full double precision</span>
<span class="p">)</span>

<span class="c1"># Memory-optimized for large datasets</span>
<span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="n">csv_files</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>   <span class="c1"># Reduced memory usage</span>
    <span class="n">mib_per_chunk</span><span class="o">=</span><span class="mi">32</span>     <span class="c1"># Small chunks for memory efficiency</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="integration-with-external-tools">
<h2>Integration with External Tools<a class="headerlink" href="#integration-with-external-tools" title="Link to this heading">¶</a></h2>
<section id="arviz-ecosystem">
<h3>ArviZ Ecosystem<a class="headerlink" href="#arviz-ecosystem" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Seamless ArviZ integration (inherits from MLEInferenceRes)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">arviz</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">az</span>

<span class="c1"># Use ArviZ plotting functions</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_rank</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_energy</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>

<span class="c1"># ArviZ diagnostics</span>
<span class="n">az</span><span class="o">.</span><span class="n">rhat</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">ess</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">mcse</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">)</span>

<span class="c1"># Model comparison</span>
<span class="n">az</span><span class="o">.</span><span class="n">compare</span><span class="p">({</span>
    <span class="s1">&#39;model1&#39;</span><span class="p">:</span> <span class="n">results1</span><span class="o">.</span><span class="n">inference_obj</span><span class="p">,</span>
    <span class="s1">&#39;model2&#39;</span><span class="p">:</span> <span class="n">results2</span><span class="o">.</span><span class="n">inference_obj</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="stan-ecosystem-compatibility">
<h3>Stan Ecosystem Compatibility<a class="headerlink" href="#stan-ecosystem-compatibility" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Work with raw Stan outputs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cmdstanpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">CmdStanModel</span>

<span class="c1"># Convert Stan results to SciStanPy format</span>
<span class="n">stan_fit</span> <span class="o">=</span> <span class="n">cmdstan_model</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stan_data</span><span class="p">)</span>

<span class="c1"># Convert to SciStanPy results</span>
<span class="n">netcdf_path</span> <span class="o">=</span> <span class="n">cmdstan_csv_to_netcdf</span><span class="p">(</span>
    <span class="n">path</span><span class="o">=</span><span class="n">stan_fit</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">scistanpy_model</span>
<span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">SampleResults</span><span class="o">.</span><span class="n">from_disk</span><span class="p">(</span><span class="n">netcdf_path</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="best-practices">
<h2>Best Practices<a class="headerlink" href="#best-practices" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><strong>Always run complete diagnostics</strong> before interpreting MCMC results</p></li>
<li><p><strong>Use interactive analyzers</strong> to understand the nature of sampling problems</p></li>
<li><p><strong>Convert to NetCDF format</strong> for efficient storage and analysis</p></li>
<li><p><strong>Enable Dask for large datasets</strong> to prevent memory issues</p></li>
<li><p><strong>Monitor convergence metrics</strong> (R-hat &lt; 1.01, ESS &gt; 100 per chain)</p></li>
<li><p><strong>Investigate divergences immediately</strong> as they indicate model problems</p></li>
<li><p><strong>Use simulation studies</strong> to validate model implementation</p></li>
<li><p><strong>Save diagnostic results</strong> for reproducible analysis workflows</p></li>
</ol>
<p>The HMC results framework provides comprehensive tools for diagnosing and analyzing MCMC sampling results, enabling robust Bayesian inference with clear identification of potential issues and their solutions.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SciStanPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">SciStanPy API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../index.html#scope">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#top-level-package">Top-Level Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#module-overview">Module Overview</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html#quick-navigation">Quick Navigation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../custom_types.html">Custom Types API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../defaults.html">Defaults API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../exceptions.html">Exceptions API Reference</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Model API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plotting/index.html">Plotting API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../operations.html">Operations API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../utils.html">Utils API Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#usage-notes">Usage Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#stability">Stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#missing-something">Missing Something?</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">SciStanPy API Reference</a><ul>
  <li><a href="../index.html">Model API Reference</a><ul>
  <li><a href="index.html">Model Results API Reference</a><ul>
      <li>Previous: <a href="mle.html" title="previous chapter">Maximum Likelihood Estimation Results API Reference</a></li>
      <li>Next: <a href="../stan/index.html" title="next chapter">Stan Integration</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Bruce Wittmann.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/api/model/results/hmc.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>